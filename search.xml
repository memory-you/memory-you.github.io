<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[从URL输入到页面展现]]></title>
    <url>%2F2019%2F08%2F19%2F%E4%BB%8EURL%E8%BE%93%E5%85%A5%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[在浏览器中输入URL到整个页面显示在用户面前时这个过程中到底发生了什么？经历怎样的一个过程？ 总体来说分为以下几个过程： DNS解析：将域名分析成IP地址 TCP连接：TCP三次握手 发生HTTP请求 服务器处理请求并返回HTTP报文 浏览器解析渲染页面 断开连接：TCP四次握手 URL到底是啥URL（Uniform Resource Locator），统一资源定位符，用来定位互联网资源，俗称网址。 1scheme://host.domain:port/path/filename 各部分解释如下： scheme - 定义因特网服务的类型。常见的协议有http、https、ftp和file，其中最常见的类型是http，而https则是进行加密的网络传输。 host - 定义域主机(http的默认主机是www)。 domain - 定义因特网域名，比如w3school.com.cn。 port - 定义主机上的端口号（http的默认端口是80）。 path - 定义服务器上的路径（如果省略，则文档必须位于网站的根目录中）。 filename - 定义文档/资源的名称。 域名解析（DNS）在浏览器输入网址后，首先要经过域名解析，因为浏览器并不能直接通过域名找到对应的服务器，而是要通过IP地址。大家这里或许会有个疑问——计算机既可以被赋予IP地址，又可以被赋予主机名和域名。那怎么不一开始就赋予个 IP 地址？这样就可以省去解析麻烦。我们先来了解下什么是 IP 地址。 IP地址 IP地址是指互联网协议地址，是IP Address的缩写。IP地址是IP协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。IP地址是一个32位的二进制数，比如127.0.0.1为本机地址。 什么是域名解析 DNS协议提供通过域名查找IP地址，或逆向从IP地址反查找域名的服务。DNS是一个网络服务器，我们的域名解析简单来说就是在DNS上记录一条信息记录。 1例如 baidu.com 220.114.23.56（服务器外网IP地址）80（服务器端口号） 浏览器如何通过域名去查询URL对应的IP呢 浏览器缓存：浏览器会按照一定的频率缓存DNS记录。 操作系统缓存：如果浏览器缓存中找不到需要的DNS记录，那就去操作系统中找。 路由缓存：路由器也是有DNS缓存的。 ISP的DNS服务器：ISP是互联网服务提供商（Internet Service Provider）的简称，ISP有专门的DNS服务器应对DNS查询请求。 根服务器：ISP的DNS服务器还找不到的话，它就会向根服务器发出请求，进行递归查询（DNS 服务器先问根域名服务器.com 域名服务器的 IP 地址，然后再问.baidu 域名服务器，依次类推）。 小结 浏览器通过向 DNS 服务器发送域名，DNS 服务器查询到与域名相对应的 IP 地址，然后返回给浏览器，浏览器再将 IP 地址打在协议上，同时请求参数也会在协议搭载，然后一并发送给对应的服务器。接下来介绍向服务器发送 HTTP 请求阶段，HTTP 请求分为三个部分：TCP 三次握手、http 请求响应信息、关闭 TCP 连接。 TCP三次握手在客户端发送数据之前会发起 TCP 三次握手用以同步客户端和服务端的序列号和确认号，并交换 TCP 窗口大小信息。 TCP三次握手的过程如下： 客户端发送一个带SYN，Seq=X的数据包到服务器端口（第一次握手，由浏览器发起，告诉服务器我要发送请求了）。 服务器发回一个带 SYN=1， ACK=X+1， Seq=Y 的响应包以示传达确认信息（第二次握手，由服务器发起，告诉浏览器我准备接受了，你赶紧发送吧）。 客户端再回传一个带 ACK=Y+1， Seq=Z 的数据包，代表“握手结束”（第三次握手，由浏览器发送，告诉服务器，我马上就发了，准备接受吧）。 为什么需要三次握手 谢希仁著《计算机网络》中讲“三次握手”的目的是“为了防止已失效的连接请求报文段突然又传送到服务器端，因而产生错误”。 发送HTTP请求TCP三次握手结束后，开始发送HTTP请求报文。 请求报文由请求行（request line）、请求头（header）、空行、请求体四个部分组成，如下图所示： 请求行包含请求方法、URL、协议版本 请求方法包含8种：GET、POST、PUT、DELETE、PATCH、HEAD、OPTIONS、TRACE。 URL即请求地址，由&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;&lt;参数&gt;组成 协议版本即http版本号 1POST /chapter17/user.html HTTP/1.1 以上代码中“POST”代表请求方法，“/chapter17/user.html”表示 URL，“HTTP/1.1”代表协议和协议的版本。现在比较流行的是 Http1.1 版本。 请求头包含请求的附加信息，由关键字/值对组成，每行一对，关键字和值由英文冒号“:”分割。 请求头部通知服务器有关客户端请求的信息。它包含许多有关的客户端环境和请求正文的有用信息。其中比如：Host，表示主机名，虚拟主机；Connection，HTTP/1.1增加的，使用keep-alive，即持续连接，一个链接可以发送多个请求；User-Agent，请求发送者，兼容性以及定制化需求。 请求体，可以承载多个请求参数的数据，包含回车符、换行符和请求数据，并不是所有请求都具有请求数据。 1name=tom&amp;password=1234&amp;realName=tomson 上面代码，承载着 name、password、realName 三个请求参数。 服务器处理请求并返回HTTP报文 服务器 服务器是网络环境中的高性能计算机，它侦听网络上的其他计算机（客户机）提交的服务请求，并提供相应的服务，比如网页服务、文件下载服务、邮件服务、视频服务。而客户端主要的功能是浏览网页、看视频、听音乐等等，两者截然不同。 每台服务器上都会安装处理请求的应用——web server。常见的 web server 产品有 apache、nginx、IIS 或 Lighttpd 等。web server 担任管控的角色，对于不同用户发送的请求，会结合配置文件，把不同请求委托给服务器上处理相应请求的程序进行处理（例如 CGI 脚本，JSP 脚本，servlets，ASP 脚本，服务器端 JavaScript，或者一些其它的服务器端技术等），然后返回后台程序处理产生的结果作为响应。 MVC 后台处理阶段后台开发现在有很多框架，但大部分都还是按照 MVC 设计模式进行搭建的。MVC 是一个设计模式，将应用程序分成三个核心部件：模型（model）– 视图（view）–控制器（controller），它们各自处理自己的任务，实现输入、处理和输出的分离。 http 响应报文响应报文由响应行（request line）、响应头部（header）、响应主体三个部分组成。如下图所示： 响应行包含：协议版本，状态码，状态码描述 状态码规则如下：1xx：指示信息–表示请求已接收，继续处理。2xx：成功–表示请求已被成功接收、理解、接受。3xx：重定向–要完成请求必须进行更进一步的操作。4xx：客户端错误–请求有语法错误或请求无法实现。5xx：服务器端错误–服务器未能实现合法的请求。 响应头部包含响应报文的附加信息，由 名/值 对组成 响应主体包含回车符、换行符和响应返回数据，并不是所有响应报文都有响应数据 浏览器解析渲染页面浏览器拿到响应文本HTML后，接下来介绍下浏览器渲染机制 浏览器解析渲染页面分为以下五个步骤： 根据HTML解析出DOM树 根据CSS解析生成CSS规则树 结合DOM树和CSS规则树，生成渲染树 根据渲染树计算每一个节点的信息 根据计算好的信息绘制页面 根据HTML解析DOM树 根据HTML的内容，将标签按照结构解析成为DOM树，DOM树解析的过程是一个深度优先遍历，即先构建当前节点的所有子节点，再构建下一个兄弟节点。 再读取HTML文档，构建DOM树的过程中，若遇到script标签则DOM树的构建会暂停，直到脚本执行完毕。 根据CSS解析生成CSS规则树 解析CSS规则树时js执行将暂停，直到CSS规则树就绪 浏览器在CSS规则树生成之前不会进行渲染 结合DOM树和CSS规则树，生成渲染树 DOM 树和 CSS 规则树全部准备好了以后，浏览器才会开始构建渲染树。 精简 CSS 并可以加快 CSS 规则树的构建，从而加快页面相应速度。 根据渲染树计算每一个节点的信息（布局） 布局：通过渲染树中渲染对象的信息，计算出每一个渲染对象的位置和尺寸 回流：在布局完成后，发现了某个部分发生了变化影响了布局，那就需要倒回去重新渲染 根据计算好的信息绘制页面 绘制阶段，系统会遍历呈现树，并调用呈现器的“paint”方法，将呈现器的内容显示在屏幕上。 重绘：某个元素的背景颜色，文字颜色等，不影响元素周围或内部布局的属性，将只会引起浏览器的重绘。 回流：某个元素的尺寸发生了变化，则需重新计算渲染树，重新渲染。 断开连接当数据传送完毕，需要断开 tcp 连接，此时发起 tcp 四次挥手 发起方向被动方发送报文，Fin、Ack、Seq，表示已经没有数据传输了。并进入 FIN_WAIT_1 状态。(第一次挥手：由浏览器发起的，发送给服务器，我请求报文发送完了，你准备关闭吧) 被动方发送报文，Ack、Seq，表示同意关闭请求。此时主机发起方进入 FIN_WAIT_2 状态。(第二次挥手：由服务器发起的，告诉浏览器，我请求报文接受完了，我准备关闭了，你也准备吧) 被动方向发起方发送报文段，Fin、Ack、Seq，请求关闭连接。并进入 LAST_ACK 状态。(第三次挥手：由服务器发起，告诉浏览器，我响应报文发送完了，你准备关闭吧) 发起方向被动方发送报文段，Ack、Seq。然后进入等待 TIME_WAIT 状态。被动方收到发起方的报文段以后关闭连接。发起方等待一定时间未收到回复，则正常关闭。(第四次挥手：由浏览器发起，告诉服务器，我响应报文接受完了，我准备关闭了，你也准备吧)]]></content>
  </entry>
  <entry>
    <title><![CDATA[如何居中一个元素]]></title>
    <url>%2F2019%2F08%2F18%2F%E5%A6%82%E4%BD%95%E5%B1%85%E4%B8%AD%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[水平居中行内元素水平居中利用text-align:center可以实现在块级元素内部的行内元素水平居中。此方法对inline、inline-block、inline-table和inline-flex元素水平居中都有效。 123.parent&#123;//在父容器设置 text-align:center; &#125; 此外，如果块级元素内部包着也是一个块级元素，我们可以先将其有块级元素改变为行内块元素，再通过设置行内块元素居中以达到水平居中。 1234567891011&lt;div class="parent"&gt; &lt;div class="child"&gt;Demo&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .parent&#123; text-align:center; &#125; .child &#123; display: inline-block; &#125;&lt;/style&gt; 块级元素的水平居中这种情形可以有多种实现方式，下面我们详细介绍： 将该块级元素左右外边距margin-left和margin-right设置为auto 1234.child&#123; width: 100px;//确保该块级元素定宽 margin:0 auto;&#125; 使用table+margin 先将子元素设置为块级表格来显示（类似），再将其设置水平居中。display:table在表现上类似block元素，但是宽度为内容宽。 123456789&lt;div class="parent"&gt; &lt;div class="child"&gt;Demo&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .child &#123; display: table; margin: 0 auto; &#125;&lt;/style&gt; 使用absolute+transform 先将父元素设置为相对定位，再将子元素设置为绝对定位，向右移动子元素，移动距离为父容器的一半，最后通过向左移动子元素的一半宽度以达到水平居中。 12345678910111213&lt;div class="parent"&gt; &lt;div class="child"&gt;Demo&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .child &#123; position:absolute; left:50%; transform:translateX(-50%); &#125; .parent &#123; position:relative; &#125;&lt;/style&gt; 不过transform属于css3内容，兼容性存在一定问题，高版本浏览器需要添加一些前缀。 使用flex+justify-content 通过CSS3中的布局利器flex中的justify-content属性来达到水平居中。 123456789&lt;div class="parent"&gt; &lt;div class="child"&gt;Demo&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .parent &#123; display: flex; justify-content:center; &#125;&lt;/style&gt; 使用flex-margin 通过flex将父容器设置为flex布局，再设置子元素居中。 1234567891011&lt;div class="parent"&gt; &lt;div class="child"&gt;Demo&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .parent &#123; display: flex; &#125; .child &#123; margin:0 auto; &#125;&lt;/style&gt; 多块级元素水平居中 利用flex布局 利用弹性布局(flex)，实现水平居中，其中justify-content用于设置弹性盒子元素在主轴(默认横轴)方向上的对齐方式，本例中设置子元素水平居中显示。 1234 #container &#123; display: flex; justify-content: center;&#125; 利用inline-block 将要水平排列的块级元素设为display:inline-block，然后在父级元素上设置text-align:center，达到与上面的行内元素的水平居中一样的效果。 123456.container &#123; text-align: center;&#125;.inline-block &#123; display: inline-block;&#125; 浮动元素水平居中 定宽的浮动元素，通过子元素设置relative+负margin 12345678.child &#123; position:relative; left:50%; margin-left:-250px;&#125;&lt;div class="parent"&gt; &lt;span class="child" style="float: left;width: 500px;"&gt;我是要居中的浮动元素&lt;/span&gt;&lt;/div&gt; 不定宽的浮动元素，父子容器都用相对定位 1234567891011121314&lt;div class="box"&gt; &lt;p&gt;我是浮动的&lt;/p&gt; &lt;p&gt;我也是居中的&lt;/p&gt;&lt;/div&gt;.box&#123; float:left; position:relative; left:50%;&#125;p&#123; float:left; position:relative; right:50%;&#125; 通用办法flex布局 利用弹性布局(flex)的justify-content属性，实现水平居中。 1234567891011.parent &#123; display:flex; justify-content:center;&#125;.chlid&#123; float: left; width: 200px;//有无宽度不影响居中&#125;&lt;div class="parent"&gt; &lt;span class="chlid"&gt;我是要居中的浮动元素&lt;/span&gt;&lt;/div&gt; 绝对定位元素水平居中 这种方式非常独特，通过子元素绝对定位，外加margin:0 auto来实现 123456789101112131415&lt;div class="parent"&gt; &lt;div class="child"&gt;让绝对定位的元素水平居中对齐。&lt;/div&gt;&lt;/div&gt; .parent&#123; position:relative; &#125; .child&#123; position: absolute; /*绝对定位*/ width: 200px; height:100px; background: yellow; margin: 0 auto; /*水平居中*/ left: 0; /*此处不能省略，且为0*/ right: 0;/*此处不能省略，且为0*/ &#125; 垂直居中单行内联元素垂直居中12345678910&lt;div id="box"&gt; &lt;span&gt;单行内联元素垂直居中。&lt;/span&gt;。&lt;/div&gt;&lt;style&gt; #box &#123; height: 120px; line-height: 120px; border: 2px dashed #f69c55; &#125;&lt;/style&gt; 多行内联元素垂直居中 利用flex布局 利用flex布局实现垂直居中，其中flex-direction:column定义主轴为纵向。这种方式在较老的浏览器存在兼容性问题。 1234567891011121314&lt;div class="parent"&gt; &lt;p&gt;Dance like nobody is watching, code like everybody is. Dance like nobody is watching, code like everybody is. Dance like nobody is watching, code like everybody is.&lt;/p&gt;&lt;/div&gt;&lt;style&gt; .parent &#123; height: 140px; display: flex; flex-direction: column; justify-content: center; border: 2px dashed #f69c55; &#125;&lt;/style&gt; 块级元素垂直居中 使用absolute+负margin(已知高度宽度) 通过绝对定位元素距离顶部50%，并设置margin-top向上偏移元素高度的一半，就可以实现了。 123456789101112&lt;div class="parent"&gt; &lt;div class="child"&gt;固定高度的块级元素垂直居中。&lt;/div&gt;&lt;/div&gt;.parent &#123; position: relative;&#125;.child &#123; position: absolute; top: 50%; height: 100px; margin-top: -50px;&#125; 使用absolute+tranform 当垂直居中的元素的高度和宽度未知时，可以借助CSS3的transform属性向Y轴反向偏移50%的方法实现垂直居中。但是部分浏览器存在兼容性的问题 1234567891011&lt;div class="parent"&gt; &lt;div class="child"&gt;未知高度的块级元素垂直居中。&lt;/div&gt;&lt;/div&gt;.parent &#123; position: relative;&#125;.child &#123; position: absolute; top: 50%; transform: translateY(-50%);&#125; 使用flex+align-items 通过设置flex布局中的属性align-items，使子元素垂直居中。 1234567&lt;div class="parent"&gt; &lt;div class="child"&gt;未知高度的块级元素垂直居中。&lt;/div&gt;&lt;/div&gt;.parent &#123; display:flex; align-items:center;&#125; 使用table-cell+vertical-align 通过将父元素转化为一个表格单元格显示（类似 和 ），再通过设置 vertical-align属性，使表格单元格内容垂直居中。 123456789&lt;div class="parent"&gt; &lt;div class="child"&gt;Demo&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .parent &#123; display: table-cell; vertical-align: middle; &#125;&lt;/style&gt; 水平垂直居中绝对定位与负边距实现(已知高度宽度) 这种方式需要知道被垂直居中元素的高和宽，才能计算出margin值，兼容所有浏览器 12345678910// css部分 #container &#123; position: relative; &#125; #center &#123; position: absolute; top: 50%; left: 50%; margin: -50px 0 0 -50px; &#125; 123456// html部分(这部分不做变化,下面例子直接共用)&lt;body&gt; &lt;div id='container'&gt; &lt;div id='center' style="width: 100px;height: 100px;background-color: #666"&gt;center&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;绝对定位与matgin：auto(已知高度宽度)这种方式无序知道被垂直居中元素的高和宽，但不能兼容低版本的IE浏览器 ​123456789101112#container &#123; position: relative; height:100px;//必须有个高度 &#125;#center &#123; position: absolute; top: 0; left: 0; right: 0; bottom: 0; margin: auto;//注意此处的写法 &#125; 绝对定位+CSS3(未知元素的高宽)利用CSS3的transform，可以轻松的在未知元素的高度的情况下实现元素的垂直居中。 123456789#container &#123; position: relative; &#125;#center &#123; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); &#125; flex布局利用flex布局，其中justify-content用于设置或检索弹性盒子元素在主轴(横轴)方向上的对齐方式，而align-items属性定义flex子项在容器的当前行的侧轴(纵轴)方向上的对齐方式。不兼容低版本的IE浏览器。 123456#container &#123;//直接在父容器设置即可 height: 100vh;//必须有高度 display: flex; justify-content: center; align-items: center; &#125; flex/grid与margin：auto(最简单写法)容器元素设为flex布局或是grid布局，子元素只要写margin：auto即可，不能兼容低版本的IE浏览器 1234567#container &#123; height: 100vh;//必须有高度 display: grid; &#125; #center &#123; margin: auto; &#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[懒加载和预加载]]></title>
    <url>%2F2019%2F08%2F16%2F%E6%87%92%E5%8A%A0%E8%BD%BD%E5%92%8C%E9%A2%84%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[懒加载什么是懒加载懒加载也叫延迟加载，指的是在长网页中延迟加载图像，是一种很好优化网页性能的方式。 用户滚动到他们之前，可视区域外的图像不会加载。这与图像预加载相反，在长网页上使用延迟加载将使网页加载更快。在某些情况下，它还可以帮助减少服务器负载。常适用图片很多，页面很长的电商网站场景中。 为什么要用懒加载 能提升用户的体验，不妨设想下，用户打开想手机淘宝长页面的时候，如果页面上所有的图片都需要加载，由于图片数目较大，等待时间很长，用户难免会心生抱怨，这就严重影响用户体验。 减少无效资源的加载，这样能明显减少服务器的压力和流量，也能够减少浏览器的负担。 防止并发加载的资源过多会阻塞js的加载，影响网站的正常使用。 懒加载的原理首先将页面上的图片的src属性设为空字符串，而图片的真实路径则设置在data-original属性中，当页面滚动的时候需要去监听scroll事件，在scrool事件的回调中，判断我们的懒加载的图片是否进入可视区域，如果图片在可视区内将图片的src属性设置为data-original的值，这样就可以实现延迟加载。 懒加载实现步骤12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Lazyload&lt;/title&gt; &lt;style&gt; .image-item &#123; display: block; margin-bottom: 50px; height: 200px;//一定记得设置图片高度 &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;img src="" class="image-item" lazyload="true" data-original="images/1.png"/&gt;&lt;img src="" class="image-item" lazyload="true" data-original="images/2.png"/&gt;&lt;img src="" class="image-item" lazyload="true" data-original="images/3.png"/&gt;&lt;img src="" class="image-item" lazyload="true" data-original="images/4.png"/&gt;&lt;img src="" class="image-item" lazyload="true" data-original="images/5.png"/&gt;&lt;img src="" class="image-item" lazyload="true" data-original="images/6.png"/&gt;&lt;img src="" class="image-item" lazyload="true" data-original="images/7.png"/&gt;&lt;img src="" class="image-item" lazyload="true" data-original="images/8.png"/&gt;&lt;img src="" class="image-item" lazyload="true" data-original="images/9.png"/&gt;&lt;img src="" class="image-item" lazyload="true" data-original="images/10.png"/&gt;&lt;img src="" class="image-item" lazyload="true" data-original="images/11.png"/&gt;&lt;img src="" class="image-item" lazyload="true" data-original="images/12.png"/&gt;&lt;script&gt;var viewHeight =document.documentElement.clientHeight//获取可视区高度function lazyload()&#123; var eles=document.querySelectorAll（'img[data-original][lazyload]'）Array.prototype.forEach.call(eles,function(item,index)&#123;var rectif(item.dataset.original==="") returnrect=item.getBoundingClientRect()// 用于获得页面中某个元素的左，上，右和下分别相对浏览器视窗的位置if(rect.bottom&gt;=0 &amp;&amp; rect.top &lt; viewHeight)&#123;!function()&#123; var img=new Image() img.src=item.dataset.original img.onload=function()&#123; item.src=img.src &#125;item.removeAttribute（"data-original"）//移除属性，下次不再遍历item.removeAttribute（"lazyload"） &#125;() &#125; &#125;)&#125;lazyload()//刚开始还没滚动屏幕时，要先触发一次函数，初始化首页的页面图片document.addEventListener（"scroll"，lazyload)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 预加载什么是预加载资源预加载是另一个性能优化技术，我们可以使用该技术来预先告知浏览器某些资源可能会被使用到。预加载简单来说就是将所有所需的资源提取请求到本地，这样后面在需要用时就直接从缓存取资源。 为什么要用预加载在网页全部加载之前，对一些主要内容进行加载，以提供给用户更好的体验，减少等待的时间。否则，如果一个页面的内容过于庞大，没有使用预加载技术的页面就会长时间的展现为一片空白，直到所有内容加载完毕。 实现预加载的几种办法 使用HTML标签 1&lt;img src="http://pic26.nipic.com/20121213/6168183 0044449030002.jpg" style="display:none"/&gt; 使用Image对象 1&lt;script src="./myPreload.js"&gt;&lt;/script&gt; 123//myPreload.js文件var image= new Image()image.src="http://pic26.nipic.com/20121213/6168183 004444903000 2.jpg" 使用XMLHttpReq对象，虽然存在跨域问题，但会精细控制预加载过程 123456789101112131415161718var xmlhttprequest = new XMLHttpRequest()xmlhttprequest.onreadystatechange = callbackxmlhttprequest.onprogress = progressCallbackxmlhttprequest.open("GET", "http://image.baidu.com/mouse,jpg", true)xmlhttprequest.send()function callback() &#123; if(xmlhttprequest.readyState==4&amp;&amp; xmlhttprequest.status==200)&#123; var responseText=xmlhttprequest.responseText &#125;else&#123; console.log("Request was unsuccessful:"+xmlhttprequest.status) &#125;&#125;function progressCallback(e) &#123; e= e || event if(e.lengthComputable) &#123; console.log("Received"+e.loaded+"of"+e.total+"bytes") &#125;&#125; 使用PreloadJS库 PreloadJS提供了一种预加载内容的一致方式，以便在HTML应用程序中使用。预加载可以使用HTML标签以及XHR来完成。默认情况下，PreloadJS会尝试使用XHR加载内容，因为它提供对进度和完成事件的更好支持，但是由于跨域问题，使用基于标记的加载可能更好。 1234567891011//使用preload.jsvar queue=new createjs.LoadQueue();//默认是xhr对象，如果是new createjs.LoadQueue(false)是指使用HTML标签，可以跨域queue.on("complete",handleComplete,this);queue.loadManifest([&#123;id:"myImage",src:"http://pic26.nipic.com/20121213/6168183 0044449030002.jpg"&#125;,&#123;id："myImage2"，src:"http://pic9.nipic.com/20100814/2839526 1931471581702.jpg"&#125;]);function handleComplete()&#123; var image=queue.getResuLt("myImage"); document.body.appendChild(image);&#125; 懒加载和预加载的对比两者都是提高页面性能有效的办法，两者主要区别是一个提前加载，一个是延迟甚至不加载。懒加载对服务器端有一定的缓解压力作用，预加载则会增加服务器前端压力。]]></content>
  </entry>
  <entry>
    <title><![CDATA[HTTP常见的状态码]]></title>
    <url>%2F2019%2F07%2F10%2FHTTP%E5%B8%B8%E8%A7%81%E7%9A%84%E7%8A%B6%E6%80%81%E7%A0%81%2F</url>
    <content type="text"><![CDATA[状态码的职责是当客户端向服务器发送请求时，描述返回的请求结果。借助状态码，用户可以知道服务端时正常处理了请求还是出现了错误。 状态码的类别： 123 类别 原因短语 1XX Informational (信息性状态码) 接受的请求正在处理 2XX Success (成功状态码) 请求正常处理完毕 3XX Redirection (重定向状态码) 需要进行附加操作以完成请求 4XX Client Error (客户端错误状态码) 服务器无法处理请求 5XX Server Error (服务器错误状态码) 服务器处理请求出错 2XX——表明请求被正常处理了 200 OK：请求已正常处理。 204 No Content：请求处理成功，但没有任何资源可以返回给客户端。]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Markdown语法]]></title>
    <url>%2F2019%2F07%2F09%2FMarkdown%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[标题在想要设置为标题的文字面前加#来表示，一个#是一级标题，两个#是二级标题以此类推。支持六级标题。 注：标准语法一般在#后跟一个空格再写文。 示例： 123456# 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题###### 这是六级标题 效果如下： 字体斜体要倾斜的文字左右分别用一个*号抱起来 加粗要加粗的文字左右分别用两个*号抱起来 斜体加粗要倾斜和加粗的文字左右分别用三个*号包起来 删除线要加删除线的文字左右分别用两个~号包起来 示例： 1234*这是倾斜的文字***这是加粗的文字*****这是斜体加粗的文字***~~这是加删除线的文字~~ 效果如下： 这是倾斜的文字这是加粗的文字这是斜体加粗的文字这是加删除线的文字 引用在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt; 示例： 123&gt;这是引用的内容&gt;&gt;这是引用的内容&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容 效果如下： 这是引用的内容 这是引用的内容 这是引用的内容 分割线三个或三个以上的-或者*都可以。示例： 1234-------******* 效果如下： 可以看到，显示效果都是一样的。 图片语法： 123![图片alt](图片位置 "图片titlle")图片alt就是显示在图片下面的文字，相当于对图片内容的解释。图片titile是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加 示例： 12![blockchain](https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=702257389,1274025419&amp;fm=27&amp;gp=0.jpg "区块链") 效果如下： ![blockchain](https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=702257389,1274025419&amp;fm=27&amp;gp=0.jpg “区块链”) 超链接语法： 12[超链接](超链接地址 "超链接title")title 可加不可加 示例： 12[简书](http://jianshu.com)[百度](http://baidu.com) 效果如下： 简书百度 列表无序列表语法： 无序列表用-、+、*任何一种都可以。 12345- 列表内容+ 列表内容* 列表内容注意： - + * 跟内容之间都要有一个空格 效果如下： 列表内容 列表内容 列表内容 有序列表语法：数字加点 123451. 列表内容2. 列表内容3. 列表内容注意： 序号跟内容之间要有空格 效果如下： 列表内容 列表内容 列表内容 列表嵌套上一级与下一级之间桥三个空格即可 一级无序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 一级无序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 一级无序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 表格语法： 1234567891011表头|表头|表头---| :--: |---:内容|内容|内容内容|内容|内容第二行分割表头和内容。- 有一个就行，为了对齐，就多加了几个文字默认居左-两边加：表示文字居中-右边加：表示文字居右注意：原生的语法两边都要用 示例： 姓名 技能 排行 刘备 哭 大哥 关羽 打 二哥 张飞 骂 三弟 代码语法：单行代码： 代码之间分别用一个反引号抱起来 1`代码内容` 代码块： 代码之间分别用三个反引号包起来，且两边的反引号单独占一行。 12345(```)代码...代码...代码...(```) 注意： 为了防止转义，前后三个反引号处加了小括号，实际是没有的。 示例： 单行代码 1`create database hero;` 代码块： 123456(```) function fun()&#123; echo "这是一句非常牛逼的代码"; &#125; fun();(```) 效果如下： 单行代码 create database hero; 代码块： 1234function fun()&#123; echo "这是一句非常牛逼的代码";&#125;fun(); 流程图123456789(```)flowst=&gt;start: 开始op=&gt;operation: My Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op&amp;(```) 注意： 为了防止转义，前后三个反引号处加了小括号，实际是没有的。 效果如下： ```st=>start: 开始 op=>operation: My Operation cond=>condition: Yes or No? e=>end st->op->cond cond(yes)->e cond(no)->op &{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12} var code = document.getElementById("flowchart-0-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value)); var diagram = flowchart.parse(code); diagram.drawSVG("flowchart-0", options);]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F06%2F15%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
