<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[如何居中一个元素]]></title>
    <url>%2F2019%2F08%2F18%2F%E5%A6%82%E4%BD%95%E5%B1%85%E4%B8%AD%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[水平居中行内元素水平居中利用text-align:center可以实现在块级元素内部的行内元素水平居中。此方法对inline、inline-block、inline-table和inline-flex元素水平居中都有效。 123.parent&#123;//在父容器设置 text-align:center; &#125; 此外，如果块级元素内部包着也是一个块级元素，我们可以先将其有块级元素改变为行内块元素，再通过设置行内块元素居中以达到水平居中。 1234567891011&lt;div class="parent"&gt; &lt;div class="child"&gt;Demo&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .parent&#123; text-align:center; &#125; .child &#123; display: inline-block; &#125;&lt;/style&gt; 块级元素的水平居中这种情形可以有多种实现方式，下面我们详细介绍： 将该块级元素左右外边距margin-left和margin-right设置为auto 1234.child&#123; width: 100px;//确保该块级元素定宽 margin:0 auto;&#125; 使用table+margin 先将子元素设置为块级表格来显示（类似），再将其设置水平居中。display:table在表现上类似block元素，但是宽度为内容宽。 123456789&lt;div class="parent"&gt; &lt;div class="child"&gt;Demo&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .child &#123; display: table; margin: 0 auto; &#125;&lt;/style&gt; 使用absolute+transform 先将父元素设置为相对定位，再将子元素设置为绝对定位，向右移动子元素，移动距离为父容器的一半，最后通过向左移动子元素的一半宽度以达到水平居中。 12345678910111213&lt;div class="parent"&gt; &lt;div class="child"&gt;Demo&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .child &#123; position:absolute; left:50%; transform:translateX(-50%); &#125; .parent &#123; position:relative; &#125;&lt;/style&gt; 不过transform属于css3内容，兼容性存在一定问题，高版本浏览器需要添加一些前缀。 使用flex+justify-content 通过CSS3中的布局利器flex中的justify-content属性来达到水平居中。 123456789&lt;div class="parent"&gt; &lt;div class="child"&gt;Demo&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .parent &#123; display: flex; justify-content:center; &#125;&lt;/style&gt; 使用flex-margin 通过flex将父容器设置为flex布局，再设置子元素居中。 1234567891011&lt;div class="parent"&gt; &lt;div class="child"&gt;Demo&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .parent &#123; display: flex; &#125; .child &#123; margin:0 auto; &#125;&lt;/style&gt; 多块级元素水平居中 利用flex布局 利用弹性布局(flex)，实现水平居中，其中justify-content用于设置弹性盒子元素在主轴(默认横轴)方向上的对齐方式，本例中设置子元素水平居中显示。 1234 #container &#123; display: flex; justify-content: center;&#125; 利用inline-block 将要水平排列的块级元素设为display:inline-block，然后在父级元素上设置text-align:center，达到与上面的行内元素的水平居中一样的效果。 123456.container &#123; text-align: center;&#125;.inline-block &#123; display: inline-block;&#125; 浮动元素水平居中 定宽的浮动元素，通过子元素设置relative+负margin 12345678.child &#123; position:relative; left:50%; margin-left:-250px;&#125;&lt;div class="parent"&gt; &lt;span class="child" style="float: left;width: 500px;"&gt;我是要居中的浮动元素&lt;/span&gt;&lt;/div&gt; 不定宽的浮动元素，父子容器都用相对定位 1234567891011121314&lt;div class="box"&gt; &lt;p&gt;我是浮动的&lt;/p&gt; &lt;p&gt;我也是居中的&lt;/p&gt;&lt;/div&gt;.box&#123; float:left; position:relative; left:50%;&#125;p&#123; float:left; position:relative; right:50%;&#125; 通用办法flex布局 利用弹性布局(flex)的justify-content属性，实现水平居中。 1234567891011.parent &#123; display:flex; justify-content:center;&#125;.chlid&#123; float: left; width: 200px;//有无宽度不影响居中&#125;&lt;div class="parent"&gt; &lt;span class="chlid"&gt;我是要居中的浮动元素&lt;/span&gt;&lt;/div&gt; 绝对定位元素水平居中 这种方式非常独特，通过子元素绝对定位，外加margin:0 auto来实现 123456789101112131415&lt;div class="parent"&gt; &lt;div class="child"&gt;让绝对定位的元素水平居中对齐。&lt;/div&gt;&lt;/div&gt; .parent&#123; position:relative; &#125; .child&#123; position: absolute; /*绝对定位*/ width: 200px; height:100px; background: yellow; margin: 0 auto; /*水平居中*/ left: 0; /*此处不能省略，且为0*/ right: 0;/*此处不能省略，且为0*/ &#125; 垂直居中单行内联元素垂直居中12345678910&lt;div id="box"&gt; &lt;span&gt;单行内联元素垂直居中。&lt;/span&gt;。&lt;/div&gt;&lt;style&gt; #box &#123; height: 120px; line-height: 120px; border: 2px dashed #f69c55; &#125;&lt;/style&gt; 多行内联元素垂直居中 利用flex布局 利用flex布局实现垂直居中，其中flex-direction:column定义主轴为纵向。这种方式在较老的浏览器存在兼容性问题。 1234567891011121314&lt;div class="parent"&gt; &lt;p&gt;Dance like nobody is watching, code like everybody is. Dance like nobody is watching, code like everybody is. Dance like nobody is watching, code like everybody is.&lt;/p&gt;&lt;/div&gt;&lt;style&gt; .parent &#123; height: 140px; display: flex; flex-direction: column; justify-content: center; border: 2px dashed #f69c55; &#125;&lt;/style&gt; 块级元素垂直居中 使用absolute+负margin(已知高度宽度) 通过绝对定位元素距离顶部50%，并设置margin-top向上偏移元素高度的一半，就可以实现了。 123456789101112&lt;div class="parent"&gt; &lt;div class="child"&gt;固定高度的块级元素垂直居中。&lt;/div&gt;&lt;/div&gt;.parent &#123; position: relative;&#125;.child &#123; position: absolute; top: 50%; height: 100px; margin-top: -50px;&#125; 使用absolute+tranform 当垂直居中的元素的高度和宽度未知时，可以借助CSS3的transform属性向Y轴反向偏移50%的方法实现垂直居中。但是部分浏览器存在兼容性的问题 1234567891011&lt;div class="parent"&gt; &lt;div class="child"&gt;未知高度的块级元素垂直居中。&lt;/div&gt;&lt;/div&gt;.parent &#123; position: relative;&#125;.child &#123; position: absolute; top: 50%; transform: translateY(-50%);&#125; 使用flex+align-items 通过设置flex布局中的属性align-items，使子元素垂直居中。 1234567&lt;div class="parent"&gt; &lt;div class="child"&gt;未知高度的块级元素垂直居中。&lt;/div&gt;&lt;/div&gt;.parent &#123; display:flex; align-items:center;&#125; 使用table-cell+vertical-align 通过将父元素转化为一个表格单元格显示（类似 和 ），再通过设置 vertical-align属性，使表格单元格内容垂直居中。 123456789&lt;div class="parent"&gt; &lt;div class="child"&gt;Demo&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .parent &#123; display: table-cell; vertical-align: middle; &#125;&lt;/style&gt; 水平垂直居中绝对定位与负边距实现(已知高度宽度) 这种方式需要知道被垂直居中元素的高和宽，才能计算出margin值，兼容所有浏览器 12345678910// css部分 #container &#123; position: relative; &#125; #center &#123; position: absolute; top: 50%; left: 50%; margin: -50px 0 0 -50px; &#125; 123456// html部分(这部分不做变化,下面例子直接共用)&lt;body&gt; &lt;div id='container'&gt; &lt;div id='center' style="width: 100px;height: 100px;background-color: #666"&gt;center&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;绝对定位与matgin：auto(已知高度宽度)这种方式无序知道被垂直居中元素的高和宽，但不能兼容低版本的IE浏览器 ​123456789101112#container &#123; position: relative; height:100px;//必须有个高度 &#125;#center &#123; position: absolute; top: 0; left: 0; right: 0; bottom: 0; margin: auto;//注意此处的写法 &#125; 绝对定位+CSS3(未知元素的高宽)利用CSS3的transform，可以轻松的在未知元素的高度的情况下实现元素的垂直居中。 123456789#container &#123; position: relative; &#125;#center &#123; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); &#125; flex布局利用flex布局，其中justify-content用于设置或检索弹性盒子元素在主轴(横轴)方向上的对齐方式，而align-items属性定义flex子项在容器的当前行的侧轴(纵轴)方向上的对齐方式。不兼容低版本的IE浏览器。 123456#container &#123;//直接在父容器设置即可 height: 100vh;//必须有高度 display: flex; justify-content: center; align-items: center; &#125; flex/grid与margin：auto(最简单写法)容器元素设为flex布局或是grid布局，子元素只要写margin：auto即可，不能兼容低版本的IE浏览器 1234567#container &#123; height: 100vh;//必须有高度 display: grid; &#125; #center &#123; margin: auto; &#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[懒加载和预加载]]></title>
    <url>%2F2019%2F08%2F16%2F%E6%87%92%E5%8A%A0%E8%BD%BD%E5%92%8C%E9%A2%84%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[懒加载什么是懒加载懒加载也叫延迟加载，指的是在长网页中延迟加载图像，是一种很好优化网页性能的方式。 用户滚动到他们之前，可视区域外的图像不会加载。这与图像预加载相反，在长网页上使用延迟加载将使网页加载更快。在某些情况下，它还可以帮助减少服务器负载。常适用图片很多，页面很长的电商网站场景中。 为什么要用懒加载 能提升用户的体验，不妨设想下，用户打开想手机淘宝长页面的时候，如果页面上所有的图片都需要加载，由于图片数目较大，等待时间很长，用户难免会心生抱怨，这就严重影响用户体验。 减少无效资源的加载，这样能明显减少服务器的压力和流量，也能够减少浏览器的负担。 防止并发加载的资源过多会阻塞js的加载，影响网站的正常使用。 懒加载的原理首先将页面上的图片的src属性设为空字符串，而图片的真实路径则设置在data-original属性中，当页面滚动的时候需要去监听scroll事件，在scrool事件的回调中，判断我们的懒加载的图片是否进入可视区域，如果图片在可视区内将图片的src属性设置为data-original的值，这样就可以实现延迟加载。 懒加载实现步骤12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Lazyload&lt;/title&gt; &lt;style&gt; .image-item &#123; display: block; margin-bottom: 50px; height: 200px;//一定记得设置图片高度 &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;img src="" class="image-item" lazyload="true" data-original="images/1.png"/&gt;&lt;img src="" class="image-item" lazyload="true" data-original="images/2.png"/&gt;&lt;img src="" class="image-item" lazyload="true" data-original="images/3.png"/&gt;&lt;img src="" class="image-item" lazyload="true" data-original="images/4.png"/&gt;&lt;img src="" class="image-item" lazyload="true" data-original="images/5.png"/&gt;&lt;img src="" class="image-item" lazyload="true" data-original="images/6.png"/&gt;&lt;img src="" class="image-item" lazyload="true" data-original="images/7.png"/&gt;&lt;img src="" class="image-item" lazyload="true" data-original="images/8.png"/&gt;&lt;img src="" class="image-item" lazyload="true" data-original="images/9.png"/&gt;&lt;img src="" class="image-item" lazyload="true" data-original="images/10.png"/&gt;&lt;img src="" class="image-item" lazyload="true" data-original="images/11.png"/&gt;&lt;img src="" class="image-item" lazyload="true" data-original="images/12.png"/&gt;&lt;script&gt;var viewHeight =document.documentElement.clientHeight//获取可视区高度function lazyload()&#123; var eles=document.querySelectorAll（'img[data-original][lazyload]'）Array.prototype.forEach.call(eles,function(item,index)&#123;var rectif(item.dataset.original==="") returnrect=item.getBoundingClientRect()// 用于获得页面中某个元素的左，上，右和下分别相对浏览器视窗的位置if(rect.bottom&gt;=0 &amp;&amp; rect.top &lt; viewHeight)&#123;!function()&#123; var img=new Image() img.src=item.dataset.original img.onload=function()&#123; item.src=img.src &#125;item.removeAttribute（"data-original"）//移除属性，下次不再遍历item.removeAttribute（"lazyload"） &#125;() &#125; &#125;)&#125;lazyload()//刚开始还没滚动屏幕时，要先触发一次函数，初始化首页的页面图片document.addEventListener（"scroll"，lazyload)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 预加载什么是预加载资源预加载是另一个性能优化技术，我们可以使用该技术来预先告知浏览器某些资源可能会被使用到。预加载简单来说就是将所有所需的资源提取请求到本地，这样后面在需要用时就直接从缓存取资源。 为什么要用预加载在网页全部加载之前，对一些主要内容进行加载，以提供给用户更好的体验，减少等待的时间。否则，如果一个页面的内容过于庞大，没有使用预加载技术的页面就会长时间的展现为一片空白，直到所有内容加载完毕。 实现预加载的几种办法 使用HTML标签 1&lt;img src="http://pic26.nipic.com/20121213/6168183 0044449030002.jpg" style="display:none"/&gt; 使用Image对象 1&lt;script src="./myPreload.js"&gt;&lt;/script&gt; 123//myPreload.js文件var image= new Image()image.src="http://pic26.nipic.com/20121213/6168183 004444903000 2.jpg" 使用XMLHttpReq对象，虽然存在跨域问题，但会精细控制预加载过程 123456789101112131415161718var xmlhttprequest = new XMLHttpRequest()xmlhttprequest.onreadystatechange = callbackxmlhttprequest.onprogress = progressCallbackxmlhttprequest.open("GET", "http://image.baidu.com/mouse,jpg", true)xmlhttprequest.send()function callback() &#123; if(xmlhttprequest.readyState==4&amp;&amp; xmlhttprequest.status==200)&#123; var responseText=xmlhttprequest.responseText &#125;else&#123; console.log("Request was unsuccessful:"+xmlhttprequest.status) &#125;&#125;function progressCallback(e) &#123; e= e || event if(e.lengthComputable) &#123; console.log("Received"+e.loaded+"of"+e.total+"bytes") &#125;&#125; 使用PreloadJS库 PreloadJS提供了一种预加载内容的一致方式，以便在HTML应用程序中使用。预加载可以使用HTML标签以及XHR来完成。默认情况下，PreloadJS会尝试使用XHR加载内容，因为它提供对进度和完成事件的更好支持，但是由于跨域问题，使用基于标记的加载可能更好。 1234567891011//使用preload.jsvar queue=new createjs.LoadQueue();//默认是xhr对象，如果是new createjs.LoadQueue(false)是指使用HTML标签，可以跨域queue.on("complete",handleComplete,this);queue.loadManifest([&#123;id:"myImage",src:"http://pic26.nipic.com/20121213/6168183 0044449030002.jpg"&#125;,&#123;id："myImage2"，src:"http://pic9.nipic.com/20100814/2839526 1931471581702.jpg"&#125;]);function handleComplete()&#123; var image=queue.getResuLt("myImage"); document.body.appendChild(image);&#125; 懒加载和预加载的对比两者都是提高页面性能有效的办法，两者主要区别是一个提前加载，一个是延迟甚至不加载。懒加载对服务器端有一定的缓解压力作用，预加载则会增加服务器前端压力。]]></content>
  </entry>
  <entry>
    <title><![CDATA[HTTP常见的状态码]]></title>
    <url>%2F2019%2F07%2F10%2FHTTP%E5%B8%B8%E8%A7%81%E7%9A%84%E7%8A%B6%E6%80%81%E7%A0%81%2F</url>
    <content type="text"><![CDATA[状态码的职责是当客户端向服务器发送请求时，描述返回的请求结果。借助状态码，用户可以知道服务端时正常处理了请求还是出现了错误。 状态码的类别： 123 类别 原因短语 1XX Informational (信息性状态码) 接受的请求正在处理 2XX Success (成功状态码) 请求正常处理完毕 3XX Redirection (重定向状态码) 需要进行附加操作以完成请求 4XX Client Error (客户端错误状态码) 服务器无法处理请求 5XX Server Error (服务器错误状态码) 服务器处理请求出错 2XX——表明请求被正常处理了 200 OK：请求已正常处理。 204 No Content：请求处理成功，但没有任何资源可以返回给客户端。]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Markdown语法]]></title>
    <url>%2F2019%2F07%2F09%2FMarkdown%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[标题在想要设置为标题的文字面前加#来表示，一个#是一级标题，两个#是二级标题以此类推。支持六级标题。 注：标准语法一般在#后跟一个空格再写文。 示例： 123456# 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题###### 这是六级标题 效果如下： 字体斜体要倾斜的文字左右分别用一个*号抱起来 加粗要加粗的文字左右分别用两个*号抱起来 斜体加粗要倾斜和加粗的文字左右分别用三个*号包起来 删除线要加删除线的文字左右分别用两个~号包起来 示例： 1234*这是倾斜的文字***这是加粗的文字*****这是斜体加粗的文字***~~这是加删除线的文字~~ 效果如下： 这是倾斜的文字这是加粗的文字这是斜体加粗的文字这是加删除线的文字 引用在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt; 示例： 123&gt;这是引用的内容&gt;&gt;这是引用的内容&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容 效果如下： 这是引用的内容 这是引用的内容 这是引用的内容 分割线三个或三个以上的-或者*都可以。示例： 1234-------******* 效果如下： 可以看到，显示效果都是一样的。 图片语法： 123![图片alt](图片位置 "图片titlle")图片alt就是显示在图片下面的文字，相当于对图片内容的解释。图片titile是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加 示例： 12![blockchain](https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=702257389,1274025419&amp;fm=27&amp;gp=0.jpg "区块链") 效果如下： ![blockchain](https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=702257389,1274025419&amp;fm=27&amp;gp=0.jpg “区块链”) 超链接语法： 12[超链接](超链接地址 "超链接title")title 可加不可加 示例： 12[简书](http://jianshu.com)[百度](http://baidu.com) 效果如下： 简书百度 列表无序列表语法： 无序列表用-、+、*任何一种都可以。 12345- 列表内容+ 列表内容* 列表内容注意： - + * 跟内容之间都要有一个空格 效果如下： 列表内容 列表内容 列表内容 有序列表语法：数字加点 123451. 列表内容2. 列表内容3. 列表内容注意： 序号跟内容之间要有空格 效果如下： 列表内容 列表内容 列表内容 列表嵌套上一级与下一级之间桥三个空格即可 一级无序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 一级无序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 一级无序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 表格语法： 1234567891011表头|表头|表头---| :--: |---:内容|内容|内容内容|内容|内容第二行分割表头和内容。- 有一个就行，为了对齐，就多加了几个文字默认居左-两边加：表示文字居中-右边加：表示文字居右注意：原生的语法两边都要用 示例： 姓名 技能 排行 刘备 哭 大哥 关羽 打 二哥 张飞 骂 三弟 代码语法：单行代码： 代码之间分别用一个反引号抱起来 1`代码内容` 代码块： 代码之间分别用三个反引号包起来，且两边的反引号单独占一行。 12345(```)代码...代码...代码...(```) 注意： 为了防止转义，前后三个反引号处加了小括号，实际是没有的。 示例： 单行代码 1`create database hero;` 代码块： 123456(```) function fun()&#123; echo "这是一句非常牛逼的代码"; &#125; fun();(```) 效果如下： 单行代码 create database hero; 代码块： 1234function fun()&#123; echo "这是一句非常牛逼的代码";&#125;fun(); 流程图123456789(```)flowst=&gt;start: 开始op=&gt;operation: My Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op&amp;(```) 注意： 为了防止转义，前后三个反引号处加了小括号，实际是没有的。 效果如下： ```st=>start: 开始 op=>operation: My Operation cond=>condition: Yes or No? e=>end st->op->cond cond(yes)->e cond(no)->op &{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12} var code = document.getElementById("flowchart-0-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value)); var diagram = flowchart.parse(code); diagram.drawSVG("flowchart-0", options);]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F06%2F15%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
