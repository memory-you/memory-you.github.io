<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[HTML标签列表]]></title>
    <url>%2F2019%2F11%2F17%2FHTML%E6%A0%87%E7%AD%BE%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[这里列出的所有标准化的HTML5元素，使用起始标签描述，按照功能分组。这些都是有效的HTML5元素，新网站应当只使用这里列出的元素。 根元素 Element Description &lt;html&gt; 代表HTML或XHTML文档的根。其他所有元素必须是这个元素的子节点。 文档元数据元素 Element Description &lt;head&gt; 代表关于文档元数据的一个集合，保活脚本和样式表的链接或内容。 &lt;title&gt; 定义文档的标题，将显示在浏览器的标题栏或标签页上。该元素只能包含文本，包含的标签不会被解释 &lt;base&gt; 定义页面上相对URL的基准URL。 &lt;link&gt; 永固链接外部的CSS到该文档。 &lt;meta&gt; 定义其他HTML元素无法描述的元数据。 &lt;style&gt; 用于内联CSS。 脚本 Element Description &lt;script&gt; 定义一个内联脚本或链接到外部脚本。脚本语言是 JavaScript。 &lt;noscript&gt; 定义当浏览器不支持脚本时显示的替代文字。 &lt;template&gt; 通过JavaScript在运行时实例化内容的容器。 章节 Element Description &lt;body&gt; 代表HTML文档的内容，在文档中只能由一个body元素。 &lt;section&gt; 定义文档中的一个章节。 &lt;nav&gt; 定义只包含导航链接的章节。 &lt;article&gt; 定义可以独立于内容其余部分的完整独立内容块。 &lt;aside&gt; 定义和页面关联度较低的内容——如果被删除，剩下的内容仍然很合理。 &lt;h1&gt;、&lt;h2&gt;、&lt;h3&gt;、&lt;h4&gt;、&lt;h5&gt;、&lt;h6&gt; 标题元素实现了六层文档标题，标题元素简要地描述章节的主题。 &lt;header&gt; 定义页面或章节的头部，它经常包含logo、页面标题和导航性的目录。 &lt;footer&gt; 定义页面或章节的尾部，它经常包含版权信息、法律信息链接和反馈建议用的地址。 &lt;address&gt; 定义可以独立于内容其余部分的完整独立内容块 &lt;main&gt; 定义文档中主要或重要的内容。 组织内容 Element Description &lt;p&gt; 定义了一个段落。 &lt;hr&gt; 代表章节、文章或其他长内容中段落之间的分隔符。 &lt;pre&gt; 代表其内容已经预先排版过，格式应当保留。 &lt;blockquote&gt; 代表引用自其他来源的内容。 &lt;ol&gt; 定义一个有序列表。 &lt;ul&gt; 定义一个无序列表。 &lt;li&gt; 定义列表中的一个列表项。 &lt;dl&gt; 定义一个定义列表（一系列术语和其） &lt;dt&gt; 定义一个由下一个&lt;dd&gt;定义的术语。 &lt;dd&gt; 代表出现在它之前术语的定义 &lt;figure&gt; 代表一个和文档有关的图例。 &lt;figcaption&gt; 代表一个图例的说明。 &lt;div&gt; 代表一个通用的容器，没有特殊含义。 组织内容 Element Description &lt;a&gt; 代表一个链接到其他资源的超链接。 &lt;em&gt; 代表强调文字。 &lt;strong&gt; 代表特别重要文字。 &lt;small&gt; 代表注释，如免责声明、版权声明等，对理解文档不重要。 &lt;s&gt; 代表不准确或不相关的内容。 &lt;cite&gt; 代表作品标题。 &lt;q&gt; 代表内联的引用。 &lt;dfn&gt; 代表一个术语包含在其最近祖先内容中的定义。 &lt;abbr&gt; 代表省略或缩写，其完整内容在title属性中。 &lt;data&gt; 关联一个内容的机器可读的等价形式 （该元素只在 WHATWG 版本的 HTML 标准中，不在 W3C 版本的 HTML5 标准中）。 &lt;time&gt; 代表日期 和时间 值；机器可读的等价形式通过 datetime 属性指定。 &lt;code&gt; 代表计算机代码。 &lt;var&gt; 代表代码中的变量。 &lt;smap&gt; 代表程序或电脑的输出。 &lt;kbd&gt; 代表用户输入，一般从键盘输出，但也可以代表其他输入，如语音输入。 &lt;sub&gt;,&lt;sup&gt; 代表一个通用的容器，没有特殊含义。 &lt;i&gt; 代表一段不同性质的文字，如技术术语、外文短语等。 &lt;b&gt; 代表一段需要被关注的文字。 &lt;u&gt; 代表一段需要下划线呈现的文本注释，如标记出拼写错误的文字等。 &lt;mark&gt; 代表一段需要被高亮的引用文字。 &lt;ruby&gt; 代表被ruby注释标记的文本，如中文汉字和它的拼音。 &lt;rt&gt; 代表ruby 注释，如中文拼音。 &lt;rp&gt; 代表 ruby 注释两边的额外插入文本 ，用于在不支持 ruby 注释显示的浏览器中提供友好的注释显示。 &lt;bdi&gt; 代表需要脱离 父元素文本方向的一段文本。它允许嵌入一段不同或未知文本方向格式的文本。 &lt;bdo&gt; 指定子元素的文本方向 ，显式地覆盖默认的文本方向。 &lt;span&gt; 代表一段没有特殊含义的文本，当其他语义元素都不适合文本时候可以使用该元素。 &lt;br&gt; 代表换行 。 &lt;wbr&gt; 代表建议换行 (Word Break Opportunity) ，当文本太长需要换行时将会在此处添加换行符。 编辑 Element Description &lt;ins&gt; 定义增加到文档的内容。 &lt;del&gt; 定义从文档移除的内容 嵌入内容 Element Description &lt;img&gt; 代表一张图片。 &lt;iframe&gt; 代表一个内联的框架。 &lt;embed&gt; 代表一个嵌入的外部资源，如应用程序或交互内容。 &lt;object&gt; 代表一个外部资源*，如图片、HTML 子文档、插件等。 &lt;param&gt; 代表 &lt;object&gt; 元素所指定的插件的参数 。 &lt;video&gt; 代表一段视频 及其视频文件和字幕，并提供了播放视频的用户界面。 &lt;audio&gt; 代表一段声音或音频流。 &lt;source&gt; 为 &lt;video&gt; 或 &lt;audio&gt; 这类媒体元素指定媒体源 。 &lt;track&gt; 为 &lt;video&gt; 或 &lt;audio&gt; 这类媒体元素指定文本轨道（字幕）。 &lt;canvas&gt; 代表位图区域 ，可以通过脚本在它上面实时呈现图形，如图表、游戏绘图等。 &lt;map&gt; 与&lt;area&gt;元素共同定义图像映射区域。 &lt;area&gt; 与&lt;map&gt;元素共同定义图像映射区域。 &lt;svg&gt; 定义一个嵌入式矢量图。 &lt;math&gt; 定义一段数学公式。 表格 Element Description &lt;table&gt; 定义多维数据。 &lt;caption&gt; 代表表格的标题。 &lt;colgroup&gt; 代表表格中一组单列或多列。 &lt;col&gt; 代表表格中的列。 &lt;tbody&gt; 代表表格中一块具体数据（表格主体）。 &lt;thead&gt; 代表表格中一块列标签（表头）。 &lt;tfoot&gt; 代表表格中一块列摘要（表尾）。 &lt;tr&gt; 代表表格中的行 。 &lt;td&gt; 代表表格中的单元格 。 &lt;th&gt; 代表表格中的头部单元格 。 表单 Element Description &lt;form&gt; 代表一个表单，由控件组成。 &lt;fieldset&gt; 代表控件组。 &lt;legend&gt; 代表&lt;fieldset&gt;控件组的标题。 &lt;label&gt; 代表表单控件的标题。 &lt;input&gt; 代表允许用户编辑数据的数据区（文本框、单选框、复选框等）。 &lt;button&gt; 代表按钮。 &lt;select&gt; 代表下拉框。 &lt;datalist&gt; 代表提供给其他控件的一组预定义选项。 &lt;optgroup&gt; 代表一个选项分组。 &lt;option&gt; 代表一个 &lt;select&gt; 元素或 &lt;datalist&gt; 元素中的一个选项 &lt;textarea&gt; 代表多行文本框。 &lt;keygen&gt; 代表一个密钥对生成器控件。 &lt;output&gt; 代表计算值。 &lt;progress&gt; 代表进度条。 &lt;meter&gt; 代表滑动条。 交互元素 Element Description &lt;details&gt; 代表一个用户可以（点击）获取额外信息或控件的小部件。 &lt;summary&gt; 代表&lt;details&gt;元素的综述或标题。 &lt;menuitem&gt; 代表用户可以点击的菜单项。 &lt;menu&gt; 代表菜单。]]></content>
  </entry>
  <entry>
    <title><![CDATA[HTML5新特性]]></title>
    <url>%2F2019%2F11%2F16%2FHTML5%E6%96%B0%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[HTML5作为HTML的代替者，成为了新的标准，而且时至今日，在前端开发中，已经被大家广泛应用，但是对于HTML5有哪些具体的功能和特性，就有不少人不太清楚。下面是我总结的一些HTML5新特性。 语义化标签HTML标签一直是前端界面的骨架，但是我们之前一直使用div标签进行布局，div标签的语义十分不清晰，对此HTML5给出了一系列的语义化标签。引入语义化标签的好处主要有： 去掉或丢失样式的情况下，使得页面呈现清晰的结构。 方便搜索引擎识别页面的各个部分。 方便其他设备的解析。 增强性表单HTML5拥有多个新的表单元素，也增加了表单属性和&lt;input&gt;标签的类型，这些新特性提供了更好的输入控制和验证。 视频和音频视频&lt;video&gt;和音频&lt;audio&gt;，也是HTML5新提供的标签，它们的功能类似于&lt;img&gt;标签，&lt;img&gt;标签引用的是图片，它们引用的是视频文件和音频文件，不仅如此，html5针对视频文件和音频文件的特殊性，给&lt;video&gt;和&lt;audio&gt;提供了非常丰富的方法,属性和事件，用于操控这俩元素。 Canvas绘图 &lt;canvas&gt; 元素用于在网页上绘制图形,&lt;canvas&gt;标签本身只是个图型容器，需要使用javaScript脚本来绘制图形。 SVGSVG是指可伸缩的矢量图形，SVG也是一种使用XML表述2D图形的语言。由于SVG基于XML，这意味着SVG DOM中的每个元素都是可用的。我们可以为某个元素附加JavaScript时间处理器，在SVG中，每个被绘制的图形均视为对象。如果SVG对象的属性发送变化，那么浏览器能够自动重现图形。 拖放 （Drag 和 Drop）拖放是HTML5提供一个新的特性，这个特性增加了拖拽事件的api,和定义可以拖拽的属性。举个例子，在h5之前实现拖拽功能，其实用的是一种模拟方式，鼠标onmousedown时，获取当前的一些信息，然后在onmousemove时不断更新推拽对象的left和top值，最后在onmouseup时对推拽对象彻底赋值，并进行释放后一系列的程序操作。现在h5出来后呢，不在需要模拟了，因为它已经有标准的事件api了。 地理定位 地理定位这个特性，故名思意，就是获取用户位置信息的。通过getCurrentPosition()获取一系列定位信息，getCurrentPosition()有两个回调函数参数，获取地理位置成功的回调和失败的回调。 离线缓存HTML5通过创建 cache manifest 文件，可以创建 web 应用的离线版本。如果要启用应用程序缓存，必须在文档的 &lt;html&gt;标签中包含 manifest 属性：每个指定了 manifest 的页面在用户对其访问时都会被缓存。如果未指定 manifest 属性，则页面不会被缓存（除非在 manifest 文件中直接指定了该页面）。 Web 存储如果说离线存储是对web的资源文件存储，那么web 存储就是对应用程序里的数据做存储了。web存储提供了两个存储方式: localStorage,没有时间限制的数据存储 sessionStorage,就是网页还没有关闭的情况下的存储，网页窗口关闭，则数据销毁。 在之前，这些都是由 cookie 完成的。但是 cookie 不适合大量数据的存储，因为它们由每个对服务器的请求来传递，这使得 cookie 速度很慢而且效率也不高。 WebSocketWebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。 WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。 Web Workers web worker 是运行在后台的 JavaScript，独立于其他脚本，不会影响页面的性能。您可以继续做任何愿意做的事情：点击、选取内容等等，而此时 web worker 在后台运行。 服务器发送事件（server-sent event）Server-Sent 事件指的是网页自动获取来自服务器的更新。 以前也可能做到这一点，前提是网页不得不询问是否有可用的更新。通过服务器发送事件，更新能够自动到达。]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈CSS的选择器]]></title>
    <url>%2F2019%2F11%2F10%2F%E8%B0%88%E8%B0%88CSS%E7%9A%84%E9%80%89%E6%8B%A9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[CSS选择器有哪些类型？ 简单选择器：标签选择器、类选择器、ID选择器、通配符选择器。 标签选择器 123html &#123; color: black;&#125; 类选择器 123.header &#123; color: black;&#125; ID选择器 123#nav &#123; color: black;&#125; 通配符选择器 123* &#123; color: black;&#125; 组合选择器：后代选择器、子代选择器、普通兄弟选择器、相邻兄弟选择器。 后代选择器 后代选择器作用的范围是作为某元素后代的元素，如下面 p 标签的123 与 456 颜色都为黑色。 123p span &#123; color: black;&#125; 1234567&lt;p&gt; &lt;span&gt;123 &lt;em&gt;abc &lt;span&gt;456&lt;/span&gt; &lt;/em&gt; &lt;/span&gt;&lt;/p&gt; 子代选择器 子代选择器作用的范围是作为某元素的子元素，如下面 p 标签里面只有 123 的颜色为黑色。 123p &gt; span &#123; color: black;&#125; 1234567&lt;p&gt; &lt;span&gt;123 &lt;em&gt;abc &lt;span&gt;456&lt;/span&gt; &lt;/em&gt; &lt;/span&gt;&lt;/p&gt; 普通兄弟选择器 普通兄弟选择器作用的范围是拥有同一个父元素，且在第一个元素后面的元素。如下面的h1标签后的456 与 789 颜色为黑色。 123h1 ~ p &#123; color: black;&#125; 1234567&lt;div&gt; &lt;p&gt;123&lt;/p&gt; &lt;h1&gt;abc&lt;/h1&gt; &lt;p&gt;456&lt;/p&gt; &lt;span&gt;ABC&lt;/span&gt; &lt;p&gt;789&lt;/p&gt;&lt;/div&gt; 相邻兄弟选择器 普通兄弟选择器作用的范围是拥有同一个父元素，且紧跟跟在第一个元素后面的元素。如下面的h1标签后只有 456 颜色为黑色。 123h1 ~ p &#123; color: black;&#125; 1234567&lt;div&gt; &lt;p&gt;123&lt;/p&gt; &lt;h1&gt;abc&lt;/h1&gt; &lt;p&gt;456&lt;/p&gt; &lt;span&gt;ABC&lt;/span&gt; &lt;p&gt;789&lt;/p&gt;&lt;/div&gt; 属性选择器 选择器 描述 [attribute】 用于选取带有指定属性的元素。 [attribute=value] 用于选取带有指定属性和值的元素。 [attribute~=value] 用于选取属性值中包含指定词汇的元素。 [attribute|=value] 用于选取带有以指定值开头的属性值的元素，该值必须是整个单词。 [attribute^=value] 匹配属性值以指定值开头的每个元素。 [attribute$=value] 匹配属性值以指定值结尾的每个元素。 [attribute*=value] 匹配属性值中包含指定值的每个元素。 伪类选择器与伪元素选择器 伪类选择器使用单引号:，伪元素选择器使用双引号::。 交集选择器与并集选择器 交集选择器——下面表示要是div标签且类为header的元素的颜色为黑色。 123div.header &#123; color: black;&#125; 并集选择器 ——下图表示html 与 body 的 字体颜色都为黑色 123html, body &#123; color: black;&#125; 优先级定义CSS样式时，经常出现两个或者更多规则应用在同一元素上，这时就会出现优先级的问题。 CSS优先级高低排序：!important &gt; 行内样式 &gt; ID选择器 &gt; 类选择器 &gt; 标签选择器 &gt; 通配符选择器 &gt; 继承 &gt; 浏览器默认属性。可以给各个选择器一个权值：行内样式为1000、ID选择器为0100、类选择器（属性选择器 伪类选择器）为0100、标签选择器（伪元素选择器）为0001、通配符选择器为0000。对于那些组合选择器，需要将它拆分为两个选择器再计算。注意的是，选择器的权值是不进位的，若11个类选择器的权值任然小于一个ID选择器。 不管父元素样式的权重有多大，继承样式没有权值。 权重相同时，CSS遵循就近原则，也就是说靠近元素的样式具有最大的优先级，或者说排在最后的样式优先级最大。 CSS定义了 !important 命令，这个命名被赋予了最大的优先级，也就是说不管权重如何以及样式位置的远近，!important都具有最大优先级。]]></content>
  </entry>
  <entry>
    <title><![CDATA[谈谈CSS的伪类与伪元素]]></title>
    <url>%2F2019%2F11%2F10%2F%E8%B0%88%E8%B0%88CSS%E7%9A%84%E4%BC%AA%E7%B1%BB%E4%B8%8E%E4%BC%AA%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[CSS中伪类与伪元素的概念是很容易混淆的，今天就来谈谈伪类与伪元素之间的区别。 定义首先看看 伪类 A CSS pseudo-class is a keyword added to a selector that specifies a special state of the selected element(s). CSS 伪类 是添加到选择器的关键字，指定要选择的元素的特殊状态。 伪类本质上是为了弥补常规CSS选择器的不足，以便获取到更多信息。 伪元素 A CSS pseudo-element is a keyword added to a selector that lets you style a specific part of the selected element(s). 伪元素是一个附加至选择器末的关键字，允许你对被选择元素的特定部分修改样式。 伪元素本质上是创建了一个有内容的虚拟容器。 伪元素需要配合content属性一起使用，伪元素不会出现在DOM中，所以不能通过js来操作，仅仅是在CSS渲染层加入。并且伪元素的 特效通常要使用:hover伪类样式来激活 。 伪类与伪元素的区别 它们之间的根本区别在于：它们是否创造了新的元素，这个新创造的元素就叫“伪元素”。 伪元素：不存在DOM文档中，是虚拟的元素，是创建新元素，这个新元素是某个元素的子元素。 伪类：存在DOM文档中，（无标签，找不到，只有符号触发条件时才能看到），逻辑上存在，但在文档树 但在文档树中却无须标识的“幽灵”分类。 因为伪类是类似于添加类所以在一个选择器中可以有多个，而伪元素在一个选择器中只能出现一次，并且只能出现在末尾。 伪类使用单引号:，伪元素使用双引号::。因为CSS2的时候，伪类与伪元素都是用单引号，而CSS3中伪元素使用双引号。 锚伪类在支持CSS的浏览器中，链接的不同状态都可以不同的方式显示，这些状态包括：活动转台，已被访问状态，未被访问状态，和鼠标悬停状态。 123456789101112131415a:link &#123; color: #FF0000 /* 未访问的链接 */&#125;a:visited &#123; color: #00FF00 /* 已访问的链接 */&#125;a:hover &#123; color: #FF00FF /* 鼠标移动到链接上 */&#125;a:active &#123; color: #0000FF /* 选定的链接 */&#125; 注意：在CSS定义中，a:hover 必须被置于 a:link 和 a:visited 之后，才是有效的。a:active 必须被置于 a:hover 之后，才是有效的。]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>选择器</tag>
        <tag>伪类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[fetch如何请求数据]]></title>
    <url>%2F2019%2F11%2F10%2Ffetch%E5%A6%82%E4%BD%95%E8%AF%B7%E6%B1%82%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[在传统Ajax时代，进行API等网络请求都是通过XMLHttpRequest或者封装后的框架进行网络请求，然而配置和调用方式非常混乱， 对于刚入门的新手并不友好。今天我们介绍的Fetch提供了一个更好的替代方法，它不仅提供了一种简单，合乎逻辑的方式来跨网络异步获取资源，而且可以很容易地被其他技术使用，例如 Service Workers。 与Ajax对比使用Ajax请求一个JSON数据一般是这样： 1234567891011121314var xhr = new XMLHttpRequest()xhr.open('GET', url/file, true)xhr.onreadystatechange = function() &#123; if (xhr.readyState === 4) &#123; if (xhr.status === 200) &#123; var data = xhr.responseText console.log(data) &#125; &#125;&#125;xhr.onerror = function() &#123; console.log('Oh, error')&#125;xhr.send() 同样我们使用fetch请求JSON数据： 123fetch(rul).then(res =&gt; res.json) // 解析为可读数据 .then(data =&gt; console.log(data)) // 执行结果是 resolve 就调用then方法 .catch(err =&gt; console.log('Oh, error', err))//执行结果是 reject就调用catch方法 这两者对比来看，fetch代码精简许多，业务逻辑更清晰明了，使得代码易于维护，可读性更高。总而言之，Fetch优点主要有： 语法简洁，更加语义化，业务逻辑更清晰 基于标准Promise实现，支持async / await 同构方便 Promise简介由于 Fetch API 是基于 Promise 设计，接下来我们简单介绍下Promise工作流程，方便大家更好理解Fetch。 fetch方法返回一个Promise对象, 根据 Promise Api 的特性, fetch可以方便地使用then方法将各个处理逻辑串起来, 使用 Promise.resolve() 或 Promise.reject() 方法将分别返会肯定结果的Promise或否定结果的Promise, 从而调用下一个then 或者 catch。一旦then中的语句出现错误, 也将跳到catch中。 请求常见数据格式接下来将介绍如何使用fetch请求本地文本数据，请求本地JSON数据以及请求网络接口。其实操作相比于Ajax，简单很多。 12345678910//HTML部分 &lt;div class="container"&gt; &lt;h1&gt;Fetch Api sandbox&lt;/h1&gt; &lt;button id="button1"&gt;请求本地文本数据&lt;/button&gt; &lt;button id="button2"&gt;请求本地json数据&lt;/button&gt; &lt;button id="button3"&gt;请求网络接口&lt;/button&gt; &lt;br&gt;&lt;br&gt; &lt;div id="output"&gt;&lt;/div&gt; &lt;/div&gt; &lt;script src="app.js"&gt;&lt;/script&gt; fetch请求本地文本数据 本地有一个test.txt文档，通过以下代码就可以获取其中的数据，并且显示在页面上。 12345678910document.getElementById('button1').addEventListener('click',getText);function getText() &#123; fetch('test.txt') .then((res) =&gt; res.text()) // 注意：此处是res.text() .then(data =&gt; &#123; console.log(data) document.getElementById('output').innerHTML = data; &#125;) .catch(err =&gt; console.log(err))&#125; fetch请求本地JSON数据 本地有个post.json数据，与请求本地文本不同的是，得到数据后还要用forEach遍历，最后呈现在页面上。 1234567891011121314document.getElementById('button2').addEventListener('click',getJson);function getJson() &#123; fetch('post.json') .then((res) =&gt; res.json()) .tehn(data =&gt; &#123; console.log(data) let output = '' data.forEach((post) =&gt; &#123; output += `&lt;li&gt;$&#123;post.title&#125;&lt;/li&gt;`; &#125;) document.getElementById('output').innerHTML = output; &#125;) .catch(err =&gt; console.log(err));&#125; fetch请求网络接口 获取 https://api.github.com/users中的数据，做法与获取本地JSON的方法类似,得到数据后，同样要经过处理 。 1234567891011121314document.getElementById('button3').addEventListener('click',getExternal);function getExternal() &#123; fetch('https://api.github.com/users') .then((res) =&gt; res.json()) .then(data =&gt; &#123; console.log(data) let output = '' data.forEach((user) =&gt; &#123; output += `&lt;li&gt;$&#123;user.login&#125;&lt;/li&gt;`; &#125;) document.getElementById('output').innerHTML = output; &#125;) .catch(err =&gt; console.log(err));&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Ajax原理]]></title>
    <url>%2F2019%2F11%2F10%2FAjax%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[Ajax是一种异步请求数据的Web开发技术，对于改善用户的体验和页面性能很有帮助。简单的说，在不需要重新刷新页面的情况下，Ajax通过异步请求加载后台数据，并在网页上呈现出来。常见运用场景有表单验证是否登入成功、百度搜索下拉框提示和快递单号查询等等。Ajax的目的是提高用户体验，较少网络数据的传输量。同时，由于Ajax请求获取的是数据而不是HTML文档，因此它也节省了网络带宽，让互联网用户的网络冲浪体验变得更加顺畅。 Ajax原理是什么在解释Ajax原理之前，我们不妨先举个“领导想找小李汇报一下工作”例子，领导想找小李问点事，就委托秘书去叫小李，自己就接着做其他事情，直到秘书告诉他小李已经到了，最后小李跟领导汇报工作。 Ajax请求数据流程与“领导想找小李汇报一下工作”类似。其中最核心的依赖是浏览器提供的XMLHttpRequest对象，它扮演的角色相当于秘书，使得浏览器可以发出HTTP请求与接收HTTP响应。浏览器接着做其他事情，等收到XHR返回来的数据再渲染页面。 理解了Ajax的工作原理后，接下来我们探讨下如何使用Ajax。 Ajax的使用 创建Ajax核心对象XMLHttpRequest 12345678var xhr = null;if (window.XMLHttpRequest) &#123; // 兼容 IE7+, Firefox, Chrome, Opera, Safari xhr = new XMLHttpRequest();&#125; else &#123; // 兼容 IE6, IE5 xhr = new ActiveXObject("Microsoft.XMLHTTP")&#125; 向服务器发送请求 12xhr.open(method, url, async)send(string); // post请求时才使用字符串参数，否则不用带参数 method：请求的类型：GET 或 POST。 url：文件在服务器上的位置。 async：true （异步）或 false （同步） 注意：post请求一定要设置请求头的格式内容 123xhr.open('POST', 'test.html', true)xhr.setRequestHeader('Content-type', 'application/x-www-form-urlencoded')xhr.send('fname=Henry&amp;lname=Ford') // post请求参数放在send里面，即请求体 服务器响应处理（区分同步跟异步两种情况） responseText 获得字符串形式的响应数据 responseXML 获得XML形式的响应数据。 同步处理 123xhr.open('GET', 'info.txt', false)xhr.send()document.getElementById("myDiv").innerHTML=xhr.responseText; //获取数据直接显示在页面上 异步处理 相对来说比较复杂，要在请求状态改变事件中处理。 12345xhr.onreadystatechange = function() &#123; if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) &#123; document.getElementById("myDiv").innerHTML=xhr.responseText; &#125;&#125; 什么是readyState？ readyState是XMLHttpRequest对象的一个属性，用来标识当前XMLHttpRequest对象处于什么状态。readyState总共有5个状态值，分别为0-4，每个值代表了不同的含义。 0：未初始化——尚未调用open()方法。 1：启动——已经调用open()方法，但未调用send()方法。 2：发送——已经调用send()方法，但尚未接收到响应。 3：接收——已经接收到部分响应数据。 4：完成——已经接收到全部响应数据，而且已经可以在客户端使用了。 GET和POST请求数据区别 使用GET请求时，参数在URL中显示，而使用POST方式，则放在send里面。 使用GET请求发送数据量小，POST请求发送数据量大。 使用GET安全性低，会被缓存，而POST请求反之。]]></content>
  </entry>
  <entry>
    <title><![CDATA[浏览器的缓存机制]]></title>
    <url>%2F2019%2F11%2F10%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[缓存可以说是性能优化中简单高效的一种优化方式了，一个优秀的缓存策略可以缩短网页请求资源的距离，减少延迟，并且由于缓存文件可以重复利用，还可以减少带宽，降低网络负荷。 对于一个数据请求来说，可以分为发起网络请求、后端处理、浏览器响应三个步骤。浏览器缓存可以帮助我们在第一和第三步骤中优化性能。比如说直接使用缓存而不发起请求，或者发起了请求但后端存储的数据和前端一致，那么就没有必要再将数据回传回来，这样就减少了响应数据。 缓存位置从缓存位置上来说分为四种，并且各自有优先级，当依次查找缓存且都没有命中的适合，才会去请求网络。 Service Worker Memory Cache Disk Cache Push Cache Service Worker Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用Service Worker的话，传输协议必须为HTTPS。因为Service Workder中涉及到请求拦截，所有必须使用HTTPS协议来保障安全。Service Worker的缓存于浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存时持续性的。 Service Workder实现缓存功能一般分为三个步骤：首先需要先注册Service Workder，然后监听到install时间以后就可以缓存需要的文件，那么在下一次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。 当Service Worker 没有命中缓存的时候，我们需要去调用fetch函数获取数据。也就是说，如果我们没有在Service Worker命中缓存的话，会根据缓存查找优先级去查找数据。但是不管我们是从Memory Cache中还是从网络请求中获取的数据，浏览器都会显示我们从Service Workder中获取的内容。 Memory Cache Memory Cache也就是内存中的缓存，主要包含的是当前中页面中已经抓取到的资源，例如页面上已经下载的样式、脚本、图片等。读取内存中的数据肯定比磁盘块，内存缓存虽然读取高效，但缓存持久型很端，会随着进程的释放而释放。一旦我们关闭Tab页面，内存中的缓存也就被释放了。 那么既然内存缓存这么高效。我们是不是能让数据都存放在内存中呢？ 这时不可能的，计算机中的内存一定比硬盘容量小得多，操作系统需要精打细算内存的使用，所有能让我们使用的内存必然不多。 当我们访问过页面以后，再次刷新页面，可以发现很多数据都来自于内存缓存 内存缓存中有一块重要的缓存资源是preloader相关指令 （例如&lt;link rel=&quot;prefetch&quot;） 下载的资源。总所周知preloader的相关指令已经是页面优化的常见手段之一，它可以一边解析js/css文件，一边网络请求下一个资源。 需要注意的事情是，内存缓存在缓存资源时并不关心返回资源的HTTP缓存头Cache-Control是什么值，同时资源的匹配也并非仅仅是对URL做匹配，还可能会对Content-Type，CORS等其他特征做校验。 Disk CacheDisk Cache 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之Memory Cache胜在容量和存储时效性上。 在所有浏览器缓存中，Disk Cache覆盖面基本是最大的。它会根据HTTP Header 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。绝大部分的缓存都来自Disk Cache，关于HTTP的协议头的缓存字段，我们会在下文进行详细介绍。 浏览器会把哪些文件丢进内存中？哪些丢进硬盘中？关于这点，网上说法不一，不过以下观点比较靠得住： 对于大文件来说，大概率是不存储在内存中的，反之优先 当前系统内存使用率高的话，文件优先存储进硬盘 Push Cache Push Cache （推送缓存）是HTTP/2中的内容，当以上三种缓存都没有命中时，它才会被使用。它只在会话（session）中存在，一旦会话结束就被释放，并且缓存时间也很短暂，在Chrome浏览器中只有5分钟左右，同时它也并非严格执行HTTP头中的缓存指令。 Push Cache 在国内能够查到的资料很少，也是因为 HTTP/2 在国内不够普及。这里推荐阅读Jake Archibald的 HTTP/2 push is tougher than I thought 这篇文章，文章中的几个结论： 所有的资源都能被推送，并且能够被缓存， 但是 Edge 和 Safari 浏览器支持相对比较差 。 可以推送 no-cache 和 no-store 的资源 一旦连接被关闭， Push Cache就被释放 多个页面可以使用同一个HTTP/2的连接，也就可以使用同一个Push Cache。这主要还是依赖浏览器的实现而定，出于对性能的考虑， 有的浏览器会对相同域名但不同的tab标签使用同一个HTTP连接。 Push Cache 中的缓存只能被使用一次 浏览器可以拒绝接受已经存在的资源推送 你可以给其他域名推送资源 如果以上四种缓存都没有命中的话，那么只能发送请求来获取资源了。 那么为了性能上的考虑，大部分的接口都应该选择好缓存策略，通常浏览器缓存策略分为两种：强缓存和协商皇城，并且缓存策略都是通过设置HTTP Header来是实现的。 缓存过场分析浏览器与服务器通信的方式为应答模式，即是：浏览器发起HTTP请求-服务器响应该庆幸，那么浏览器怎么确定一个资源该不该缓存，如何去缓存呢？浏览器第一次向服务器发起该请求后拿到请求结果后，将请求结果和缓存标识存入浏览器缓存，浏览器对缓存的处理是根据第一次请求资源时返回的响应头来确定的。具体过程如下图： 由上图我们可以知道： 浏览器每次发送请求，都会现在浏览器缓存中查找该请求的结果以及缓存标识 浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中 以上两点结论就是浏览器缓存机制的关键，它确保了每个请求的缓存存入与读取，只要我们再理解了浏览器缓存的使用规则，那么所有的问题就迎刃而解了，本文也将围绕着这点进行详细分析。为了方便大家理解，这里我们根据是否需要向服务器重新发起HTTP请求将缓存过程分为两部分，分别时强缓存和协商缓存。 强缓存强缓存：不会向服务器发送请求，直接从缓存中读取资源，在chrome控制台的Network选项中可以看到该请求返回200的状态码，并且Size显示from disk cache 或from memory cahce。强缓存可以通过设置两种HTTP Header实现：Expires 和 Cache-Control。 Expires 缓存过期时间，用来资源到期的时间，是服务器端的具体的时间点。也就是说，Expires = max-age + 请求时间，需要和Last-modified结合使用。Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。 Expires 是 HTTP/1 的产物，受限于本地时间，如果修改了本地时间，可能会造成缓存失效。 Expires: Wed, 22 Oct 2018 08:41:00 GMT表示资源会在 Wed, 22 Oct 2018 08:41:00 GMT 后过期，需要再次请求。 Cache-Control 在HTTP/1.1中，Cache-Control是最重要的规则，主要用于控制网页缓存。比如当Cache-Control:max-age=300时，则代表在这个请求正确返回时间（浏览器也会记录下来）的5分钟内再次加载资源，就会命中强缓存。 Cache-Control可以在请求头部或者响应头中设置，并且可以组合使用多种指令： public: 所有内容都将被缓存（客户端和代理服务端都可缓存）。具体来说响应可被任何中间节点缓存，如 Browser &lt;– proxy1 &lt;– proxy2 &lt;– Server，中间的proxy可以缓存资源，比如下次再请求同一资源proxy1直接把自己缓存的东西给 Browser 而不再向proxy2要。 private：所有内容只有客户端可以缓存，Cache-Control的默认取值。具体来说，表示中间节点不允许缓存， 对于Browser &lt;– proxy1 &lt;– proxy2 &lt;– Server，proxy 会老老实实把Server 返回的数据发送给proxy1,自己不缓存任何数据。当下次Browser再次请求时proxy会做好请求转发而不是自作主张给自己缓存的数据。 no-cache：客户端缓存内容，是否使用缓存则需要进行协商缓存来检验决定。表示不使用Cache-Control的缓存控制方式做前置验证，而是使用Etag或者Last-Modified字段来控制缓存。需要注意的是，no-cache这个命名有点误导，设置了no-cache之后，并不是说浏览器就不再缓存数据，只是浏览器在使用缓存数据时，需要先确认一下数据是否还跟服务器保持一致。 no-store：所有内容都不hi被缓存，即不使用强制缓存，也不使用协商缓存。 max-age：max-age= xxx (xxx is numeric)表示缓存内容将在xxx秒后失效 。 s-maxage（单位为s)：同max-age作用一样，只在代理服务器中生效（比如CDN缓存）。比如当s-maxage=60时，在这60秒中，即使更新了CDN的内容，浏览器也不会进行请求。max-age用于普通缓存，而s-maxage用于代理缓存。s-maxage的优先级高于max-age。如果存在s-maxage，则会覆盖掉max-age和Expires header。 max-stale：能容忍的最大过期时间。max-stale指令标示了客户端愿意接收一个已经过期了的响应。如果指定了max-stale的值，则最大容忍时间为对应的秒数。如果没有指定，那么说明浏览器愿意接收任何age的响应（age表示响应由源站生成或确认的时间与当前时间的差值） min-fresh：能够容忍的最小新鲜度。min-fresh标示了客户端不愿意接受新鲜度不多于当前的age加上min-fresh设定的时间之和的响应。 从图中我们可以看到，我们可以将多个指令配合起来一起使用，达到多个目的，比如我们希望资源能被缓存下来，并且时客户端和代理服务器都能缓存，还能设置缓存失效时间等等。 Expire 和 Cache-Control两者对比 其实这两者差别不大，区别就在于 Expires 是http1.0的产物，Cache-Control是http1.1的产物，两者同时存在的话，Cache-Control优先级高于Expires；在某些不支持HTTP1.1的环境下，Expires就会发挥用处。所以Expires其实是过时的产物，现阶段它的存在只是一种兼容性的写法 。 强缓存判断是否缓存的依据来自于是否曹处某个时间或者某个时间段，而不关心服务器端文件是否已经更新，这可能会导致加载文件不是服务器端最新的内容，那我们如何获知服务器端内容是否已经发生了更新呢？此时我们需要用到协商缓存策略。 协商缓存协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两者情况： 协商缓存生效，返回304 和Not Modified 协商缓存失效，返回200和请求结果 协商缓存可以通过设置两种HTTP Header实现： Last-Modified 和 ETag。 Last-Modified 和 If-Modified-Since 浏览器在第一次返回资源时，服务器返回资源的同时，在response header中添加 Last-Modified的header，指的这个资源在服务器上的最后修改时间，浏览器接受后缓存文件和header： 1Last-Modified: Fri, 22 Jul 2016 01:47:00 GMT 浏览器下一次请求这个资源，浏览器检测到有Last-Modified这个header，于是添加If-Modified-Since这个header，值就是Last-Modified中的值；服务器再次收到这个资源请求，会根据 If-Modified-Since 中的值与服务器中这个资源的最后修改时间对比，如果没有变化，返回 304 和空的响应头，直接从缓存读取，如果If-Modified-Since的时间小于服务器端中这个资源的最后修改时间，说明文件有更新，于是返回新的资源文件和200. 但是 Last-Modified 存在一些弊端： 如果本地打开缓存文件，即使没有对文件进行修改，但还是会造成 Last-Modified 被修改，服务端不能命中缓存导致发送相同的资源 因为 Last-Modified 只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源 既然根据文件修改时间来决定是否缓存尚有不足，能否可以直接根据文件内容是否修改来决定缓存策略？所以在 HTTP/1.1 出现了 ETag 和If-None-Match。 Etage和If-Ntone-Match Etag时服务器响应请求时，返回当前文件的一个唯一标识（由服务器生成），只要资源有变化，Etag就会重新生成。浏览器在下一次加载资源向服务器发送请求时，会将上一次返回的Etag值放到request header里的If-None-Match里，服务器子需要比较客户端传来的If-None-Match跟自己服务器上该资源是u发一致，技能很好地判断资源相对客户端而言是否被修改过了。如果服务器发送Etage匹配不上，那么直接以常规GET 200汇报形式将新的资源（当然也包括了新的Etag）发给客户端。如果Etag是一致的，则直接返回304告知客户端直接使用本地缓存即可。 两者之间对比： 首先在精确度上，Etag要优于Last-Modified。 Last-Modified的时间单位是秒，如果某个文件在1秒内改变多次，那么他的Last-Modified其实并没体现出来修改，但是Etag每次都会改变确保了精度； 如果是负载均衡的服务器，各个服务器生成的Last-Modified也有可能不一致。 然后在性能上，Etag要逊于Last-Modified，毕竟Last-Modified只需要记录时间，而Etag需要服务器通过算法来计算出一个hash值。 第三在优先级上，服务器校验优先考虑Etag。 缓存机制强制缓存优先于协商缓存进行，若强制缓存(Expires 和 Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存（Last-Modified / If-Modified-Since 和 Etah / If-Node-Match），协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，返回200，重新返回资源和缓存标识，再粗如浏览器缓存中，生效则返回304，继续使用缓存。具体流程图如下： 看到这里，不知道你是否存在这样一个疑问：如果什么缓存策略都没设置，那么浏览器会怎么处理？ 对于这种情况，浏览器会采用一个启发式的算法，通常会取响应头的 Date 减去 Last-Modified 值的10%作为缓存时间。 实际场景应用缓存策略 频繁变动的资源 1Cache-Control: no-cache 对于频繁变动的资源，首先需要使用Cache-Control:no-cache使浏览器每次都请求服务器，然后配合Etag或者Last-Modified来验证资源是否有效。这种做法虽然不能节省请求数量，但是能显著减少响应数据大小。 不常变化的资源 Cache-Control:max-age=31536000 通常在处理这类资源时，给它们的Cache-Control配置一个很大的max-age=31536000（一年），这样浏览器之后请求相同的URL会命中强制缓存。而为了解决更新问题，就需要在文件名（或者路径）中添加hash，版本号等动态字符，之后更改动态字符，从而达到更改URL的目的，让之前的强制缓存失效（ 其实并未立即失效，只是不再使用了而已 ）。 用户行为对浏览器缓存的影响所谓用户行为对浏览器缓存的影响，指的就是用户在浏览器如何操作时，会触发怎样的缓存策略。主要有3种： 打开网页，地址栏输入地址：查找disk cache中是否有匹配。如有则使用，如没有则发送网络请求。 普通刷新（F5）：因为TAB并没有关闭，因此memory cache 时可用的，会被优先使用（如果匹配的话），其次才是disk cache。 强制刷新（Ctrl + F5）：浏览器不使用缓存，因此发送的请求头部均带有 Cache-control: no-cache(为了兼容，还带了 Pragma: no-cache),服务器直接返回 200 和最新内容。]]></content>
  </entry>
  <entry>
    <title><![CDATA[浏览器存储]]></title>
    <url>%2F2019%2F11%2F09%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AD%98%E5%82%A8%2F</url>
    <content type="text"><![CDATA[随着移动网络的发展与演化，我们手机现在除了有原生APP，还能跑“WebApp”——它即开即用，用完即走。一个优秀的WebApp甚至用于和原生App媲美的功能和体验。WebApp优异的性能表现，有一部分原因要归功于浏览器存储技术的提升。cookie存储数据的功能已经很难满足开发所需，逐渐被WebStorage、IndexedDB所取代，本文将介绍这几种存储方式的差异和优缺点。 Cookie Cookie的来源 Cookie的本职工作并非本地存储，而是“维持状态”。 因为HTTP协议是无状态的，HTTP协议自身不对请求和响应之间的通信状态进行保存，通俗来说，服务器不知道用户上一次做了什么，这严重阻碍了交互式Web应用程序的实现。在典型的网上购物场景中，用户浏览了几个页面，买了一盒饼干和两瓶饮料。最好结账时，由于HTTP的无状态性，不通过额外的手段，服务器并不知道用户到底买了什么，于是就诞生了Cookie。它就是用来绕过HTTP的无状态性的“额外手段”之一。服务器可以设置或读取Cookies中包含信息，借此维护用户跟服务器会话中的状态。 我们可以把Cookie理解为一个存储在浏览器里的一个小小的文本文件，它附在HTTP请求上，在浏览器和服务器之间“飞来飞去”。它可以携带用户信息，当服务器检测Cookie的时候，便可以获取到客户端的状态。 在刚才的购物场景中，当用户选购了第一项商品，服务器在向用户发送网页的同时，还发送了一段Cookie，记录着那项商品的信息。当用户访问另一个页面，浏览器会把Cookie发送给服务器， 于是服务器知道他之前选购了什么。用户继续选购饮料，服务器就在原来那段Cookie里追加新的商品信息。结帐时，服务器读取发送来的Cookie就行了。 什么是Cookie及应用场景 Cookie是指某些网址为了辨别用户身份而储存在用户本地终端上的数据(通常经过加密0)。cookie是服务器端生成，客户端进行维护和存储。通过cookie，可以让服务器知道请求来源于哪个客户端，就可以进行客户端状态的维护，比如登陆后刷新，请求头就会携带登录时response header 中的set-cookie，Web服务器接到请求时也能读出cookie的值，根据cookie值的内容就可以判断和恢复一些用户的信息状态。 如上图所示，Cookie以键值对的形式存在。 典型的应用场景用： 记住密码，下次自动登录。 购物车功能。 记录用户浏览数据，进行商品(广告)推荐。 Cookie的原理及生成方式 第一次访问网站的时候，浏览器发出请求，服务器响应请求后，会在响应头里面添加一个Set-Cookie选项，将cookie放入到响应请求中，在浏览器第二次发请求的时候，会通过Cookie请求头部将Cookie信息发送给服务器，服务器会辨别用户身份，另外，Cookie的过期时间、域、路径、有效期、适用站点都可以根据需要来指定。 Cookie的生成方式猪妖有两种： 生成方式一： http response header 中的set-cookie 我们可以通过响应头的Set-Cookie指定要存储的Cookie值。默认情况下，domain被设置为Cookie页面的主机名，我们也可以手动设置domain的值。 1Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2018 07:28:00 GMT;//可以指定一个特定的过期时间（Expires）或有效期（Max-Age） 当Cookie的过期时间被设定时，设定的日期和时间只与客户端相关，而不是服务端。 生成方式二：js中可以通过documnet.cookie可以读写cookie，以键值对的形式展示。 例如我们在掘金社区控制台输入以下三句代码，便可以在Chrome的Application面板查看生成的cookie： 123document.cookie="userName=hello";document.cookie="gender=male";document.cookie='age=20;domain=.baidu.com' 从上图中我们可以得出： Domain标识指定了哪些域名可以接受Cookie。如果没有设置domain，就会自动绑定到执行语句的当前域。 如果设置为“.baidu.com”，则所有以“baidu.com”结尾的域名都可以访问该cookie，所以在掘金社区上读取不到第三条代码存储cookie值。 Cookie的缺陷 Cookie不够大 Cookie的大小限制在4KB左右，对于复杂的存储需求来说时不够用的。当Cookie超过4KB时，它将面临被裁切的命运。这样看来，Cookie只能用来存取少量的信息。此外，很多浏览器对一个站点的cookie个数也是有限制的。 这里需要注意：各浏览器的cookie每个name=value的value值大概在4k，所以4k并不是一个域名下所有的cookie共享的，而是一个name的大小。 过多的Cookie会带来巨大的性能浪费 Cookie时紧跟域名的。同一域名下的所有请求，都会携带Cookie。 大家试想，如果我们此刻仅仅是请求一张图片或者一个 CSS 文件，我们也要携带一个 Cookie 跑来跑去（关键是 Cookie 里存储的信息并不需要），这是一件多么劳民伤财的事情。Cookie 虽然小，请求却可以有很多，随着请求的叠加，这样的不必要的 Cookie 带来的开销将是无法想象的。 Cookie是用来维护用户信息的，而域名(domain)下所有请求都会携带cookie，但对于静态文件的请求，携带cookie信息根本没有用，此时可以通过CDN(存储静态文件的)的域名和主站的域名分开来解决。 由于在HTTP请求中的Cookie是明文传递的，所以安全性成问题，除非用HTTPS。 Cookie与安全 对于Cookie来说，我们还需要注意安全性。 HttpOnly不支持读写，浏览器不允许脚本操作document.cookie去更改cookie，所以为了避免跨域脚本(XSS)攻击，通过JavaScript的Document.cookie API无法访问带有HttpOnly标记的cookie，它们只应该发送给服务端。如果包含服务端Session信息的Cookie不像被客户端JavaScript脚本调用，那么就应该为其设置HttpOnly标记。 1Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly 标记为Secure的Cookie只应通过被HTTPS协议加密过的请求发送给服务端。但即便设置了Secure标记，敏感信息也不应该通过Cookie传输，因为Cookie有其固有的不安全性，Secure标记也不会提供确实的安全保障。 为了弥补Cookie的局限性，让“专业的人做专业的事情”，Web Storage出现了。 HTML5中新增了本地存储的解决方案——Web Storage，它分成两类：sessionStorage和localStorage。这样有了Web Storage后，Cookie能只做它应该做的事情了——作为客户端与服务器交互的通道，保持客户端状态。 LocalStorage LocalStorage的特点 保存的数据长期存在，下一次访问该网站的时候，网页可以直接读取以前保存的数据。 大小为5M左右。 仅在客户端使用，不和服务端进行通信。 接口封装较好。 基于以上的特点，LocalStorage可以作为浏览器本地缓存方案，用来提升网页首屏渲染速度(根据第一请求返回时，将一些不变信息直接存储在本地). 存入/读取数据 localStorage保存的数据，以“键值对”的形式存在。也就是说，每一项数据都有一个键名和对应的值。所有的数据都是以文本格式保存。 存入数据使用setItem方法，它接受两个参数，第一个时键名，第二个是保存的数据。 localStorage.setItem(&quot;key&quot;, &quot;value&quot;); 读取数据使用getItem方法，它只有一个参数，就是键名。 var valueLocal = localStorage.getItem(&quot;key&quot;) 具体步骤，请看下面的例子： 1234if (window.localStorage) &#123; localStorage.setItem('name', 'world'); localStorage.setItem('gender', 'female');&#125; 12345678910&lt;body&gt; &lt;div id="name"&gt;&lt;/div&gt; &lt;div id="gender"&gt;&lt;/div&gt;&lt;script&gt; var name=localStorage.getItem('name') var gender=localStorage.getItem('gender') document.getElementById('name').innerHTML=name document.getElementById('gender').innerHTML=gender&lt;/script&gt;&lt;/body&gt; 使用场景 LocalStorage在存储方面没有什么特别的限制，理论上Cookie无法胜任的、可以用简单的键值对来存取的数据存储任务，都可以交给LocalStorage来做。 这里给大家举个例子，考虑到LocalStorage的特点之一是持久，有时我们更倾向于用它来存储一些内容稳定的资源。比如图片内容丰富的电商网站会用它来存储Base64格式的图片字符串： sessionStoragesessionStorage保存的数据用于浏览器的一次会话，当会话结束(通常是该窗口关闭)，数据被清空；sessionStorage特别的一点在于，即便是相同域名下的两个页面，只要它们不在同一个浏览器窗口中打开，那么它们的sessionStorage内容便无法共享；localStorage在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。除了保存期限的长短不同，sessionStorage的属性和方法与localStorage完全一样。 sessionStorage的特点 会话级别的浏览器存储 大小为5M左右 仅在客户端使用，不和服务端进行通信 接口封装较好 基于上面的特点，sessionStorage可以有效对表单信息进行维护，比如刷新时，表单信息不丢失。 使用场景 sessionStorage更适合用来存储生命周期和它同步的会话级别的信息。这些信息只适用于当前会话，当你开启新的会话时，它也需要相应的更新或释放。比如微博的sessionStorage就主要是存储你本次会话的浏览足迹： lasturl对应的就是你上一次访问的URL地址，这个地址是即时的。当你切换URL时，它随之更新，当你关闭页面时，留着它也确实没有什么意义，干脆释放把，这样的数据用sessionStorage来处理再合适不过了。 sessionStorage、localStorage与cookie之间的区别 共同点：都是保存在浏览器端、且都遵循同源策略。 不同点：在于生命周期与作用域的不同。 作用域：localStorage只要在相同的协议、相同的主机名、相同的端口下，就能读取/修改到同一个份localStorage数据。sessionStorage比localStorage更 严苛一点，除了协议、主机名、端口外，还要求在同一窗口（也就是浏览器的标签页）下 。 生命周期：localStorage是持久化的本地存储，存储在其中的数据是永远不会过期的，使其消失的唯一办法是手动删除；而sessionStorage是临时性的本地存储，它是会话级别的存储，当会话结束（页面被关闭）时，存储内容也随之被释放。 Web Storage是一个从定义到使用都非常简单的东西。它使用键值对的形式进行存储，这种模式有点类似于对象，却甚至链对象都不是——它只能存储字符串，要想得到对象，我们还要先对字符串进行一轮解析。 说到底，Web Storage是对Cookie的拓展，它只能用来存储少量的简单数据。当遇到大规模的、结构复杂的数据时，Web Storage也爱莫能助了。这时候我们就要清除我们的终极大Boss——indexedDB！ IndexedDBIndexedDB 是一种低级的API，用来客户端存储大量结构化数据(包括文件和blobs)。该API使用索引来实现对该数据的高性能搜索。IndexedDB是一个允许在浏览器上的非关系型数据库。既然是数据库了，那就不是5M、10M这样小打小闹级别了。理论上来说，IndexedDB是没有存储上限的（一般来说不会小于250M）。它不仅可以存储字符串，还可以存储二进制数据。 IndexedDB的特点 键值对存储 IndexedDB内部采用对象仓库（object store）存放数据。所有类型的数据都可以直接存入，包括JavaScript对象。对象仓库中，数据以“键值对”的形式保存，每一个数据记录都有对应的主键，主键是独一无二的，不能有重复，否则会抛出一个错误。 异步 IndexedDB操作时不会锁死浏览器，用户依然可以进行其他操作，这与LocalStorage形成对比，后者的操作是同步的。异步设计是为了防止大量数据的读写，拖慢网页的表现。 支持事务 IndexedDB支持事务(transaction)，这意味着一系列操作步骤之中，只要有一步失败，整个事务就都取消，数据库回滚到事务发送之前的状态，不存在只改写一部分数据的情况。 同源限制 IndexedDB受到同源限制，每一个数据库对应创建它的域名。网页只能访问自身域名下的数据库，而不能访问跨域的数据库。 储存空间大 IndexedDB的储存空间比LocalStorage大得多，一般来说不少于250MB，甚至没有上限。 支持二进制储存 IndexedDB不仅可以存储字符串，还可以存储二进制数据(ArrayBuffer对象和Blob对象)。 IndexedDB的常见操作 在IndexedDB大部分操作并不是我们常见的调用方法，返回结果的模式，而是请求——响应的模式。 建立打开IndexedDB—— window.indexedDB.open(&#39;textDB&#39;) 这条指令并不会返回一个DB对象的句柄，我们得到的是一个IDBOpenDBRequest对象，而我们希望得到的DB对象在其result属性中。 除了result，IDBOpenDBRequest接口定义了几个重要属性： onerror：请求失败的回调函数句柄 onsuccess：请求成功的回调函数句柄 onupgradeneeded：请求数据库版本变化句柄 12345678910111213141516function openDB(name)&#123; var request=window.indexedDB.open(name)//建立打开IndexedDB request.onerror=function (e)&#123; console.log('open indexdb error') &#125; request.onsuccess=function (e)&#123; myDB.db=e.target.result//这是一个 IDBDatabase对象，这就是IndexedDB对象 console.log(myDB.db)//此处就可以获取到db实例 &#125;&#125;var myDB=&#123; name:'testDB', version:'1', db:null&#125;openDB(myDB.name) 控制台得到了一个IDBDatabase对象，这就是IndexedDB对象 关闭IndexedDB——indexdb.close() 123function closeDB(db) &#123; db.close()&#125; 删除IndexedDB——window.indexedDB.deleteDatabase(index) 123function deleteDB(name) &#123; indexedDB.deleteDatabase(name)&#125; WebStorage、cookie和IndexedDB之间的区别 从上表可以看到，cookie已经不建议用来存储。如果没有大量数据存储需求的话，可以使用localStorage和sessionStorage。 对于不怎么改变的数据尽量使用 localStorage 存储，否则可以用 sessionStorage 存储。]]></content>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2019%2F11%2F08%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[正则表达式(Regular Expression)是一种文本模式，包括普通字符（例如，a到z之间的字母）和特殊字符（称为元字符）。正则表达式使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。 正则表达式的使用，可以通过简单的办法来实现强大的功能，下面先给出一个简单的示例： ^为匹配输入字符串的开始位置。 [0-9]+匹配多个数字，[0-9]匹配单个数字,+匹配一个或者多个。 abc$匹配字母abc并以abc结尾，$为匹配输入字符串的开始位置。 语法正则表达式描述了一种字符串匹配的模式(pattern)，可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的字串等。 普通字符：没有显式指定为元字符的所有可打印和不可打印字符。这包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号。 特殊字符：所谓特殊字符就是一些由特殊含义的字符。当要匹配元字符的时候，我们需要先将字符”转义”。即，将反斜杠字符\放在元字符前面。 限定符：指定正则表达式的一个给定嘴贱必须要出现多少次才能满足匹配。由*或+或?或{n}或{n, }或{n, m}共6种。 字符 描述 * 匹配前面的子表达式零次或多次。* 相当于{0，} + 匹配前面的子表达式一次或多次。+ 相当于{1，} ？ 匹配前面的子表达式零次或一次。？相当于{0，1} {n} n是一个非负整数，匹配确定的n次。 {n,} n是一个非法整数，至少匹配n次。 {n,m} n和m均为非负整数，其中n &lt;= m。最少匹配n次且最多匹配m次。 注意：在逗号和两个数之间不能有空格。 定位符：能够将正则表达式固定固定到行首或者行尾。 字符 描述 ^ 匹配输入字符串开始的位置. $ 匹配输入字符串结尾的位置. \b 匹配一个单词边界，即字与空格间的位置。 \B 非单词边界匹配 注意：不要将限定符与定位符一起使用。由于在紧靠换行或者单词边界的前面或后面不能有一个以上位置。 选择：用圆括号将所有选择项括起来，相邻的选择项之间用 | 分隔。但用圆括号会有一个副作用，使相关的匹配会被缓存，此时可用 ?: 放在第一个选项前来消除这种副作用。 其中 ?:是非捕获元之一， 还有两个非捕获元是 ?= 和 ?!，这两个还有更多的含义，前者为正向预查，在任何开始匹配圆括号内的正则表达式模式的位置来匹配搜索字符串，后者为负向预查，在任何开始不匹配该正则表达式模式的位置来匹配搜索字符串。 反向引用： 对一个正则表达式模式或部分模式两边添加圆括号将导致相关匹配存储到一个临时缓冲区中，所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。 最多可存储 99 个捕获的子表达式。每个缓冲区都可以使用 \n 访问，其中 n 为一个标识特定缓冲区的一位或两位十进制数。 可以使用非捕获元字符 ?:、?= 或 ?! 来重写捕获，忽略对相关匹配的保存。 运算符优先级正则表达式从左到右进行计算，并遵循优先级顺序。相同优先级的从左到右进行元素，不同优先级的运算先高后低。 下表从高到低说明了各类正则表达式运算符的优先级顺序。 运算符 描述 \ 转义符 (), (?:), (?=), [] 圆括号和方括号 *, +, ?, {n}, {n, }, {n, m} 限定符 ^, $, \ 任何元字符、任何字符 定位符和序列 | 替换，“或”操作 匹配规则 基本匹配规则 一起从最基本的开始。模式，是正则表达式最基本的元素，它们是一组描述字符串特征的字符。 1^once 这个模式包含一个特殊字符 ^ ，表示该模式只匹配那些以once开头的字符串。 在该模式中的字母(o-n-c-e)是字母的字符，也就是说，它们表示该字母本身，数字也是一样的。其他一些稍微复杂的字符，如标点字符和白字符，要用到转义序列。所有的转义序列都用反斜杠()打头，制表符的转义序列是\t。所以如果我们要检测一个字符串是否以制表符开头，可以用这个模式： 1^\t 字符簇 我们常常用正则表达式来验证用户的输入，当用户提交一个form以后，要判断输入的电话号码、地址、EMAIL地址、信用卡号码等是否有效，用普通的基于字面的字符是不够的。 所以要用一组更自由的描述我们要的模式的办法，它就是字符簇。 123456[a-z] //匹配所有的小写字母 [A-Z] //匹配所有的大写字母 [a-zA-Z] //匹配所有的字母 [0-9] //匹配所有的数字 [0-9\.\-] //匹配所有的数字，句号和减号 [ \f\r\t\n] //匹配所有的白字符 这些只能表示一个字符，这是非常重要的。如果要匹配一个由一个小写字母和一个数字组成的字符串的话，用这个模式： 1^[a-z][0-9]$ 尽管[a-z]代表26个字母的范围，但在这里它只能与第一个字符是小写的字符的字符串匹配。 在这里使用的 ^ ，表示字符串的开头。但它还有一个含义，当在一组方括号里面使用^，它表示“非”或“排除”的意思，常常用来剔除某个字符，还有前面的例子，我们要求第一个字符不能是数字： 1^[^0-9][0-9]$ 这个模式与”&amp;5”、”g7”及”-2”是匹配的，但与”12”、”66”是不匹配的。下面是几个排除特定字符的例子： 123[^a-z] // 除了小写字母以外的所有字符[^\\\/\^] //除了(\)(/)(^)之外的所有字符 [^\&quot;\&apos;] //除了双引号(&quot;)和单引号(&apos;)之外的所有字符 特殊字符.在正则表达式中用来表示除了“新行”以外的所有字符。 所以模式 ^.5$ 与任何两个字符的、以数字5结尾和以其他非”新行”字符开头的字符串匹配。模式 . 可以匹配任何字符串，除了空串和只包括一个“新行”的字符串 确认重复出现 在现在为止，我们知道了如何取匹配一个字母或数字，但更多的情况下，可能匹配一个单词或一组数字。一个单词由若干个字母组成，一组数字有若干个单数组成。跟在字符或字符簇后面的花括号({})用来确定前面的内容的重复出现的次数。 字符簇 描述 ^[a-zA-Z_]$ 所有的字母和下划线 ^[[:alpha:]]{3}$ 所有的3个字母的单词 ^a$ 字母a ^a{4}$ aaaa ^a{2,4}$ aa,aaa或aaaa ^a{1,3}$ a,aa或aaa ^a{2,}$ 包含多于两个a的字符串 ^a{2,} 如：aardvark和aaab，但apple不行 a{2,} 如：baad和aaa，但Nantucket不行 \t{2} 两个制表符 .{2} 所有的两个字符 元字符 字符 描述 \ 将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。 ^ 匹配输入字符串的开始位置。 $ 匹配输入字符串的结束位置。 * 匹配前面的子表达式零次或多次。 + 匹配前面的子表达式一次或多次。 ？ 匹配前面的子表达式零次或一次。 {n} n是一个非负整数，匹配确定的n次 {n,} n是一个非负整数，至少匹配n次。 {n,m} n,m均为非负整数，其中n&lt;=m。最少匹配n次且最多匹配m次。 ？ 当该字符紧跟在任何一个限定符(*, +, ?, {n}, {n,}, {n,m})后面时，匹配模式时非坦然的。 . 匹配除换行符（\n、\r）之外的任何单个字符 (pattern) 匹配pattern并获取这一匹配，所获取的匹配可以从产生的Matches集合得到。 (?:pattern) 匹配pattern但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。 (?=pattern) 正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配。 (?!pattern) 正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配。 (?&lt;=pattern) 反向肯定预查，与正向肯定预查类似，只是方向相反。 (?&lt;!pattern) 反向否定预查，与正向否定预查类似，只是方向相反。 x|y 匹配x或y。 [xyz] 字符集合，匹配所包含的任意一个字符。 [^xyz] 负值字符集合，匹配未包含的任意字符。 [a-z] 字符范围，匹配指定范围内的任意字符。 [^a-z] 负值字符范围，匹配任何不在指定范围内的任意字符。 \b 匹配一个单词边界，也就是指单词和空格间的位置。 \B 匹配非单词边界。 \cx 匹配由x指明的控制字符。 \d 匹配一个数字字符，等价于[0-9]。 \D 匹配一个非数字字符，等价于[^0-9]。 \f 匹配一个换页符，等价于 \x0c 和 \cL 。 \n 匹配一个换行符，等价于\x0a 和 \cM。 \r 匹配一个回车符，等价于 \x0d 和 \cj。 \s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。 \S 匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。 \t 匹配一个制表符。等价于 \x09 和 \cI。 \v 匹配一个垂直制表符。等价于 \x0b 和 \cK \w 匹配字母、数字、下划线。等价于’[A-Za-z0-9_]’ \W 匹配非字母、数字、下划线。等价于&#39;[^A-Za-z0-9_]&#39;。 \xn 匹配 n，其中 n 为十六进制转义值。 \num 匹配 num，其中 num 是一个正整数。 \n 标识一个八进制转义值或一个向后引用。 \nm 标识一个八进制转义值或一个向后引用 \nml 如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。 \un 匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Grid布局]]></title>
    <url>%2F2019%2F11%2F02%2FGrid%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[网格布局（Grid）是最强大的CSS布局方案。 它将网页划分为一个个网格，可以任意组合不同的网格，作出各种各样的布局。以前，只能通过复杂的CSS框架达到的效果，现在浏览器内置了。 Flex布局与Grid布局有一定的相似性，都可以指定容器内部多个项目的位置。但是，它们也存在重大区别。 Flex布局是轴线布局，只能指定“项目”针对轴线的位置，可以看作一维布局。Grid布局则是将容器划分成“行”和“列”，产生单元格，然后指定“项目所在”的单元格，可以看作是二维布局。Grid布局远比FLex布局强大。 基本概念 容器和项目 采用网格布局的区域，称为“容器”（container）。容器内部采用网格定位的子元素，称为“项目”（item）。 12345&lt;div&gt; &lt;div&gt;&lt;p&gt;1&lt;/p&gt;&lt;/div&gt; &lt;div&gt;&lt;p&gt;2&lt;/p&gt;&lt;/div&gt; &lt;div&gt;&lt;p&gt;3&lt;/p&gt;&lt;/div&gt;&lt;/div&gt; 上面代码中，最外层的&lt;div&gt;元素就是容器，内层的三个&lt;div&gt;元素就是项目。 注意：项目只能是容器的顶层子元素，不包含项目的子元素，比如上面代码的&lt;p&gt;元素就不是项目。Grid布局只对项目生效。 行与列 容器里面的水平区域称为“行”（row），垂直区域称为“列”（column）。 上图中，水平的深色区域就是“行”，垂直的深色区域就是“列”。 单元格 行与列的交叉区域，称为“单元格”（cell）. 正常情况下，n行与m列会产生n x m 个单元格。比如，3行3列会产生9个单元格。 网格线 划分网格的线，称为“网格线”（grid line）。水平网格线划分为行，垂直网格线划分为列。 正常情况下，n行有n + 1根水平网格线，m列有m + 1根垂直网格线，比如三行就有四根水平网格线。 上图是一个 4 x 4 的网格，共有5根水平网格线和5根垂直网格线。 容器属性Grid布局的属性分为两类。一类定义在容器上面，称为容器属性；另一类定义在项目上面，称为项目属性。这部分先介绍容器属性。 display属性 display：grid指定一个容器采用网格布局 123div &#123; display: grid;&#125; 上图就是display：grid 的效果。 默认情况下，容器元素都是块级元素，但也可以设为行内元素。 123div &#123; display: inline-grid;&#125; 上面代码指定div是一个行内元素，该元素内部采用网格布局。 上图是display：inline-grid 的效果。 注意，设为网格布局以后，容器子元素（项目）的float、display：inline-block、display：table-cell、vertical-align和column-*等设置都会失效。 grid-template-columns属性与grid-template-rows属性 容器指定了网格布局以后，接着就要划分行和列。grid-template-columns属性定义每一列的列宽，grid-template-rows属性定义了每一行的行高。 12345.container &#123; display: grid; grid-template-columns: 100px 100px 100px; grid-template-rows: 100px 100px 100px;&#125; 上面代码指定了一个三行三列的网格，列宽和行高都是100px。 除了使用绝对单位，也可以使用百分比。 12345.container &#123; display: grid; grid-template-columns: 33.33% 33.33% 33.33%; grid-template-rows: 33.33% 33.33% 33.33%;&#125; (1) repeat() 有时候，重复写同样的值非常麻烦，尤其网格很多时，这时，就可以使用repeat()函数，简化重复的值。上面的代码用repeat()改写如下。 12345.container &#123; display: grid; grid-template-columns: repeat(3, 33.33%); grid-template-rows: repeat(3, 33.33%);&#125; repeat()接受两个参数，第一个参数是重复的次数（上例是3），第二个参数是所要重复的值。 repeat()重复某种模式也是可以的。 1grid-template-columns: repeat(2, 100px 20px 80px) 上面代码定义了6列，第一列和第四列的宽度为100px，第二列和第五列为20px，第三列和第六列为80px。 (2) auto-fill关键字 有时，单元格的大小固定的，但是容器的大小不确定，如果希望每一行（或每一列）容纳尽可能多的单元格，这是可以使用auto-fill关键字表示自动填充， 1234.container &#123; display: grid; grid-template-columns: repeat(auto-fill, 100px);&#125; 上面代码表示每列宽度100px，然后自动填充，直到容器不能放置更多的列。 (3) fr关键字 为了方便表示比例关系，网格布局提高了fr关键字(fraction的缩写，意为“片段”)。如果两列的宽度分别为1fr和2fr，就表示后者是前者的两边。 1234.container &#123; display: grid; grid-template-colum: 1fr 1fr;&#125; 上面代码表示两个相同宽度的列。 fr可以与绝对长度的单位结合使用，这时会非常方便。 1234.container &#123; display: grid; gird-template-columns: 150px 1fr 2fr;&#125; 上面代码表示，第一列的宽度为150px，第二列的宽度是第三列的一半。 (4) minmax() minmax()函数产生一个长度范围，表示长度就在这个范围执政，它接受两个参数，分别为最小值和最大值。 1grid-template-columns: 1fr 1fr minmax(100px, 1fr) 上面代码表示中，minmax(100px, 1fr)表示列宽不小于100px，不大于1fr。 (5) auto关键字 auto关键字表示有浏览器自己决定长度。 1grid-template-columns: 100px auto 100px; 上面代码中，第二列的宽度，基本上等于该列单元格的最大宽度，除非单元格内容设置了min-width，且这个值大于最大宽度。 （6） 网格线的名称 grid-template-columns属性和grid-template-rows属性里面，还可以使用方括号，指定每一根网格线的名字方便以后的引用。 12345.container &#123; display: grid; grid-template-columns: [c1] 100px [c2] 100px [c3] auto [c4]; grid-template-rows: [r1] 100px [r2] 100px [r3] auto [r4];&#125; 上面代码指定网格布局为3行 x 3列，因此有4根垂直网格线和4根水平网格线。方括号里面依次是这八根线的名字。 网格布局允许同一根线有多个名字，比如[fifth-line row-5] (7) 布局实例 grid-template-columns属性对于网页布局非常有用。两栏式布局只需要一行代码。 1234.wrapper &#123; display: grid; grid-template-columns: 70% 30%:&#125; 上面代码将左边栏设为70%，右边栏设为30%。 传统的十二网格布局，写起来也很容易。 1grid-template-columns: repeat(12, 1fr) grid-row-gap属性、grid-column-gap属性、grid-gap属性 grid-row-gap属性设置行与行的间隔（行间距），grid-column-gap属性设置列于列的间隔（列间距）。 1234.container &#123; grid-row-gap: 20px; gird-column-gap: 20px;&#125; 上面代码中，grid-row-gap用于设置行间距，grid-column-gap用于设置列间距。 grid-gap属性式grid-column-gap和gird-row-gap的合并简写形式，语法如下。 1grid-gap: &lt;grid-row-gap&gt; &lt;grid-column-gap&gt;; 因此，上面一段CSS代码等同于下面的代码。 123.container &#123; grid-gap: 20px 20px;&#125; 如果grid-gap省略了第二个值，浏览器认为第二个值等于第一个值。 注意：根据最新标志，上面三个属性名的grid-前缀已经删除，grid-column-gap和grid-row-gap写成column-gap和row-gap，grid-gap写成gap。 grid-template-areas属性 网格布局允许指定“区域”（area），一个区域由单个或多个单元格组成。grid-template-areas属性用于定义区域。 12345678.container &#123; display: grid; grid-template-columns: 100px 100px 100px; gird-template-rows: 100px 100px 100px; grid-template-areas: 'a b c' 'd e f' 'g h i'&#125; 上面代码先划分出9个单元格，然后将其命名为a到i的九个区域，分别对应这九个单元格。 多个单元格合并成一个区域的写法如下。 123grid-template-areas: 'a a a' 'b b b' 'c c c' 上面代码将9个单元格分成a、b、c三个区域。 下面是一个布局实例。 123grid-template-areas: "header header header" "main main sidebar" "footer footer footer"; 上面代码中，顶部是页面区域header，底部是页脚区域footer，中间部分则为main和sidebar。 如果某些区域不需要利用，则使用“点（.）”来表示。 123grid-template-areas: 'a . c' 'd . f' 'g . i'; 上面代码中，中间一列为点，便是没有用到该单元格，或者该单元格不属于任何区域。 注意，区域的命名会影响到网格线，每个区域的起始网格线会自动命名为区域名-start，终止网格线自动命名为区域名-end。比如区域名为header，则起始位置的水平网格线和垂直网格线叫做header-start，终止位置的水平网格线和垂直网格线叫做header-end。 grid-auto-flow属性 划分网格以后，容器的子元素会按照顺序，自动放置在每一个网格。默认的放置顺序是“先行后列”，即先填满第一行，再开始放入第二行，即下图数字的顺序。 这个顺序由grid-auto-flow属性决定，默认值是row，即“先行后列”。也可以将它设为column，变成“先列后行”。 1grid-auto-flow: column; 上面代码设置列column以后，放置顺序就变成了下图。 grid-auto-flow属性除了设置为row和column，还可以设为row dense和column dense。这两个值主要用于，某些项目指定位置以后，剩余的项目怎么自动放置。 下面的例子将1号项目和2号项目各占据两个单元格，然后在默认的grid-auto-flow：row情况下，会产生下面这样的布局。 上图中，1号项目后面的位置是空的，这是因为3号项目默认跟2号项目，所以会排在2号项目后面。 现在修改设置，设为row dense，表示”先行后列“，并且尽可能紧密填满，尽量不出现空格。 1grid-auto-flow: row dense; 上面代码的效果如下： 上图会先填满第一行，再填满第二行，所以3号项目就会紧跟在1号项目的后面。8号项目和9号项目就会排到第四行。 如果将设置改为column dense，表示”先列后行”，并且尽量填满空格。 1grid-auto-fill: column dense; 上面代码的效果如下。 上图会先填满第一列，再填满第二列，所以3号项目在第一列，4号项目在第二列。8 号项目和9号项目被挤到了第四列。 justify-items属性、align-items属性、place-items属性 justify-items属性设置单元格内容的水平位置（左中右），align-items属性设置单元格内容的垂直位置（上中下）。 1234.container &#123; justify-items: start | end | center | stretch; align-items: start | end | center | stretch;&#125; 这两个属性的写法完全相同，都可以取下面这些值。 start：对齐单元格的起始边缘。 end：对齐单元格的结束边缘。 center：单元格内部居中。 stretch：拉伸，占满单元格的整个宽度（默认值）。 123.container &#123; justify-items: start;&#125; 上面代码表示，单元格内内容左对齐，效果如下图。 123.container &#123; align-items: start;&#125; 上面代码表示，单元格的内容头部对齐，效果如下图。 place-items属性是align-items属性和justify-items属性的合并简写形式。 1place-items: &lt;align-items&gt; &lt;justify-items&gt;; 下面是一个例子。 1place-items: start end; 如果省略第二个值，则浏览器认为与第一个值相等。 justify-content属性、align-content属性、place-content属性 justify-content属性是整个内容区域在容器里面的水平位置（左中右），align-content属性是整个内容区域的垂直位置（上中下）。 1234.container &#123; justify-content: start | end | center | stretch | space-around | space-between | space-evenly; align-content: start | end | center | stretch | space-around | space-between | space-evenly;&#125; 这两个属性的写法完全相同，都可以取下面这些值。（下面的图都以justify-content属性为例，align-content属性的图完全一样，只是将水平方向改成垂直方向。） start - 对齐容器的起始边框。 end - 对齐容器的结束边框 center - 容器内部居中 stretch - 项目大小没有指定时， 拉伸占据整个网格容器。 space-around - 每个项目两侧的间隔相等。所以，项目之间的间隔比项目与容器边框的间隔大一倍。 space-between - 项目与项目的间隔相等，项目与容器边框之间没有间隔。 space-evenly - 项目与项目的间隔相等，项目与容器边框之间也是同样长度的间隔。 place-content属性时align-content属性和justify-content属性的合并简写形式。 1place-content: &lt;align-content&gt; &lt;justify-content&gt; 下面是一个例子。 1place-content: space-around space-evenly; 如果省略第二个值，浏览器就会假定第二个值等于第一个值。 grid-auto-columns属性、grid-auto-rows属性 有时候，一些项目的指定位置，在现有网格的外部。比如网格只有3列，但是某一个项目指定在第5行。这时，浏览器会自动生成多余的网格，以便放置项目。 grid-auto-column属性和grid-auto-rows属性用来设置，浏览器自动创建的多余网格的列宽和行高。它们的写法于grid-template-columns和grid-template-rows完全相同。如果不指定这两个属性，浏览器完全根据单元格内容的大小，决定新增网格的列宽和行高。 下面的例子里面，划分好的网格是3行x3列，但是，8号项目指定在第5行，9号项目指定在第5行。 123456.container &#123; display: grid; grid-template-columns:100px 100px 100px; grid-template-rows:100px 100px 100px; grid-auto-rows: 50px;&#125; 上面代码指定新增的行高统一为50px（原始的行高为100px）。 grid-template属性、grid属性 grid-template属性是grid-template-columns、grid-template-rows、和grid-template-areas这三个属性的合并简写形式。 grid属性是 grid-template-rows、grid-template-columns、grid-template-areas、 grid-auto-rows、grid-auto-columns、grid-auto-flow这六个属性的合并简写形式。 从易读易写的角度考虑，还是建议不要合并属性，所以这里就不详细介绍这两个属性了。 项目属性下面这些属性定义在项目上面。 grid-column-start属性、grid-column-end属性、grid-row-start属性、grid-row-end属性。 项目的位置是可以指定的，具体方法就是指定项目的四个边框，分别定位在哪根网格线。 grid-colum-start属性：左边框所在的垂直网格线。 grid-colum-end属性：右边框所在的垂直网格线。 grid-row-start属性：上边框所在的垂直网格线。 grid-row-end属性：下边框所在的垂直网格线。 1234.item-1 &#123; grid-column-start: 2; grid-column-end: 4;&#125; 上面代码指定，1号项目的左边框是第二根垂直网格线，有边框是第四个垂直网格线。 上面中，只指定1号项目的左右边框，没有指定上下边框，所以会采用默认位置，即上边框是第一个水平网格线，下边框是第二个水平网格线。 除了1号项目以外，其他项目都没有指定位置，由浏览器自动布局，这时它们的位置由容器的grid-auto-flow属性决定。这个属性的默认值是row，因此会“先行后列”进行排列。 下面的例子是指定四个边框位置的效果。 123456.item-1 &#123; grid-column-start: 1; grid-column-end: 3; grid-row-start: 2; grid-row-end: 4;&#125; 这四个属性的值，除了指定为第几个网格线，还可以指定为网格线的名字。 1234.item-1 &#123; grid-column-start: header-start; grid-column-end: header-end;&#125; 上面代码中，左边框和右边框的位置，都指定为网格线的名字。 这四个属性的值还可以使用span关键字，表示”跨越”，即左右边框（上下边框）之间跨越多少个网格。 123.item-1 &#123; grid-column-start: span 2;&#125; 上面代码表示，1号项目的左边框距离右边框跨越2个网格。 这与下面的代码效果完全一样。 123.item-1 &#123; grid-column-end: span 2;&#125; 使用这4个属性，如果产生了项目的重叠，则使用z-index属性指定项目的重叠顺序。 grid-column属性、grid-row属性 grid-column属性是grid-column-start和grid-column-end的合并简写形式，grid-row属性是grid-row-start属性和grid-row-end的合并简写形式。 1234.item &#123; grid-column: / ; grid-row: / ;&#125; 下面是一个例子。 123456789101112.item-1 &#123; grid-column: 1 / 3; grid-row: 1 / 2;&#125;// 等同于.item-1 &#123; grid-column-start: 1; grid-column-end: 3; grid-row-start: 1; grid-row-end: 2;&#125; 上面代码中，项目item-1占据第一行，从第一根列线到第三根列线。 这两个属性之中，也可以使用span关键字，表示跨越多少个网格。 123456789101112.item-1 &#123; background: #bc03532; grid-column: 1 / 3; grid-row: 1 / 3;&#125;// 等同于.item-1 &#123; background: #bc03532; grid-column: 1 / span 2; grid-row: 1 / span 2;&#125; 上面代码中，项目item-1占据的区域，包括第一行 + 第二行、第一列 + 第二列。 斜杠以及后面的部分可以省略，默认跨越一个网格。 1234.item-1 &#123; grid-column: 1; grid-row: 1;&#125; 上面代码中，项目item-1占据左上角第一个网络。 grid-area属性 grid-area属性指定项目放在哪一个区域。 123.item-1 &#123; grid-area: e;&#125; 上面代码中，1号项目位于e区域，效果如下图。 grid-area属性还可用作grid-row-start、grid-column-start、grid-row-end、grid-row-end的合并简写形式，直接指定项目的位置。 123.item &#123; grid-area: &lt;row-start&gt; / &lt;column-start&gt; / &lt;row-end&gt; / &lt;column-end&gt;;&#125; 下面是一个例子。 123.item-1 &#123; grid-are: 1 / 1 / 3 / 3;&#125; justify-self属性、align-self属性、place-self属性 justify-self属性设置单元格内容的水平位置（左中右），跟justify-items属性的用法完全一致，但只作用于单个项目。 align-self属性设置单元格内容的垂直位置（上中下），跟align-items属性的用法完全一致，也是只作用于单个项目。 1234.item &#123; justify-self: start | end | center | stretch; align-slef: start | end | center | stretch;&#125; 这两个属性都可以取下面四个值。 start：对齐单元格的起始边缘。 end：对齐单元格的结束边缘。 center：单元格内部居中。 stretch：拉伸，占满单元格的整个宽度（默认值）。 123.item-1 &#123; justify-self: start;&#125; place-self属性是align-slef属性和justify-self属性的合并简写形式。 1place-self: &lt;align-self&gt; &lt;justify-self&gt;; 下面是一个例子。 1place-self: center center; 如果省略第二个值，place-self属性会认为这两个值相等。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Flex布局]]></title>
    <url>%2F2019%2F11%2F02%2FFlex%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[网页布局（layout）是CSS的一个重点应用。 传统的布局解决方案，基于盒状模式，依赖display属性+position属性+float属性。它对于那些特殊布局非常不方便，比如垂直居中就很不容易实现。 Flex布局是什么Flex是Flexible Box的缩写，意为“弹性布局”，用来为盒状模型提供最大的灵活性。 任何一个容器都可以指定为Flex布局。 123.box &#123; display: flex;&#125; 行内元素也可以使用Flex布局。 123.box &#123; display: inline-flex;&#125; Webkit内核的浏览器，必须加上-webkit前缀。 1234.box &#123; display: -webkit-flex; // Safari display: flex;&#125; 注意，设为Flex布局以后，子元素的float、clear、和vertical-align 属性将失效。 基本概念采用Flex布局的元素，称为Flex容器（flex container），简称“容器”。它的所有子元素自动称为容器成员，称为Flex项目（flex item），简称“项目”。 容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做“cross start”，结束位置叫做cross end。 项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。 容器的属性以下6个属性设置在容器上。 flex-direction flex-wrap flex-flow justify-content align-items align-content flex-direction属性 flex-direction属性决定主轴的方向（即项目的排列方向）。 123.box &#123; flex-direction: row | row-reverse | column | column-reverse;&#125; 它可能有4个值： row（默认）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿。 flex-wrap属性 默认情况下，项目都排在一条线（又称“轴线”）上。flex-wrap属性定义了，如果一条轴线排不下，该如何换行。 123.box &#123; flex-wrap: nowrap | wrap | wrap-reverse;&#125; 它可能取三个值。 nowrap（默认）：不换行。 wrap：换行，第一行在上方。 wrap-reverse：换行，第一行在下方。 flex-flow属性 flex-flow属性是flex-directin属性和flex-wrap属性的简写形式，默认值为row nowrap。 123.box &#123; flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;&#125; justify-content属性 justify-content属性定义了项目在主轴上的对齐方式。 123.box &#123; justify-content: flex-start | flex-end | center | space-between | space-around;&#125; 它可能取5个值，具体对齐方式与轴的方向相关。下面假设主轴为从左到右。 flex-start（默认值）：左对齐。 felx-end：右对齐。 center：居中。 space-between：两端对齐，项目之间的间隔都相等。 space-around：每个项目两侧的间隔相等。所以项目之间的间隔比项目与边框的间隔大一倍。 align-items属性 align-items属性定义项目在交叉轴上如何对齐。 123.box &#123; align-items: flex-start | flex-end | center | baseline | stretch;&#125; 它可能取5个值。具体的对齐方式与交叉轴的方向有关。下面假设交叉轴从上到下。 flex-start：交叉轴的起点对齐。 felx-end：交叉轴的终点对齐。 center：交叉轴的中点对齐。 baseline：项目的第一行文字的基线对齐。 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 align-content属性 align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 123.box &#123; align-content: flex-start | flex-end | center | space-between | stretch;&#125; 该属性可能取6个值。 flex-start：与交叉轴的起点对齐。 flex-end：与交叉轴的终点对齐。 center：与交叉轴的中点对齐。 space-between：与交叉轴两端对齐 space-around：每个轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认值）：轴线占满整个交叉轴。 项目的属性以下6个属性设置为项目上。 order flex-grow flex-shrink flex-basis flex align-self order属性 order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。 123.item &#123; order: &lt;integer&gt;;&#125; flex-grow属性 flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。‘ 123.item &#123; flex-grow: &lt;number&gt;; // default 0&#125; 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 flex-shrink属性 flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 123.item &#123; flex-shrink: &lt;number&gt;; // default 1&#125; 如果所有项目的felx-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。 flex-basis属性 flex-basis属性定义了在分配空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 123.item &#123; flex-basis: &lt;length&gt; | auto; // default auto&#125; 它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。 flex属性 flex属性是flex-grow、flex-shrink和flex-basis的简写，默认值为0 1 auto。后两个属性可选。 123.item &#123; flex: none | [&lt;'flex-grow'&gt; &lt;'flex-shrink'&gt;? || &lt;'flex-basis'&gt;]&#125; 该属性有两个快捷值：auto（1 1 auto）和none（0 0 auto）。 建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 align-self属性 align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 123.item &#123; align-self: auto | flex-start | flex-end | center | baseline | stretch;&#125; 该属性可能取6个值，除了auto，其他都与align-items属性完全一致。]]></content>
  </entry>
  <entry>
    <title><![CDATA[CSS样式规范]]></title>
    <url>%2F2019%2F11%2F02%2FCSS%E6%A0%B7%E5%BC%8F%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[## 代码风格 采用UTF-8编码，在CSS头部引用@charset &quot;utf-8&quot;； 使用4个空格作为一个缩进层级，不允许使用两个空格或者tab字符； 每行不得超过120个字符，除非单行不可分割； 选择器嵌套层级不大于3级，位置靠后的限定条件应尽可能精确； 尽量不要使用@import，与&lt;links&gt;相比，@import速度较慢，增加了额外的页面请求，并可能导致其他无法预料的问题； Media Query不得单独编排，必须与相关的规则一起定义； 样式属性顺序 布局位置（position、top、right、z-index、display、float等）； 尺寸大小（width、height、padding、margin）； 文字系列（font、line-height、letter-spacing、color、text-align等）； 视觉效果（background、border等）； 其他（animation、transition等）； 缩写属性和属性值 CSS有些属性是可以缩写的，比如padding，margin，font，background，border等。 当数值为小数时，小数点前面的 ‘0’ 可以去掉。 ‘0px’ 后面的单位可以去掉。 16进制的颜色代码重叠的字符可以缩写的尽量缩写。 规则声明块样式规范 当规则声明块中有多个样式声明时，每条样式独占一行。 列表属性并排书写时，用逗号分隔，逗号后必须跟一个空格 。 选择器与左大括号{之间必须加一个空格。 属性名与冒号之间不允许包含空格，冒号与属性值之间必须包含空格。 在每条样式后面都以分号；结尾。 规则声明块的右大括号}独占一行。 所有最外层引号使用单引号 ‘ ‘。 当一个属性有多个属性值时，以逗号，分隔属性值，每个逗号后添加一个空格，当单个属性值过长时，每个属性值独占一行。 每个规则声明间用空行分隔。 命名空间规范 一律小写。 尽量用英文。 命名短且语义化要好。 布局：以g为命名空间，例如：.g-wrap、.g-header、g-content。 状态：以s为命名空间，表示动态的、具有交互性质的状态，例如：.s-current、s-selected。 工具：以u为命名空间，表示不耦合业务逻辑的、可复用的工具，例如：u-clearfix、u-ellipsis。 组件：以m为命名空间，表示可复用、移植的组件模块，例如：m-slider、m-dropMenu。 钩子：以j为命名空间，表示特定给JavaScript调用的类名，例如：j-request、j-open。 布局(.g-) 语义 命名 简写 文档 doc doc 头部 head head 主体 body bd 尾部 foot ft 主栏 main mn 主栏子容器 mainc mnc 侧栏 side sd 侧栏子容器 sidec sdc 盒容器 wrap/box wrap/box 模块(.m-)、元件(.u-) 语义 命名 语义 命名 导航 nav 子导航 subnav 面包屑 crumb 菜单 menu 选项卡 tab 标题区 head/title 内容区 body/content 列表 list 表格 table 表单 form 热点 hot 排行 top 登录 login 标志 logo 广告 advertise 搜索 search 幻灯片 slide 提示 tips 帮助 help 新闻 news 下载 download 注册 regist 投票 vote 版权 copyright 结果 result 标题 title 按钮 button 输入 input 功能(.f-) 语义 命名 语义 命名 浮动清除 clearboth 向左浮动 floatleft 向右浮动 floatright 内联块级 inlineblock 文本居中 textaligncenter 文本居左 textalignleft 文本居右 textalignright 垂直居中 verticalalignmiddle 溢出隐藏 overflowhidden 完全消失 displaynone 文体大小 fontsize 字体粗细 fontweight 皮肤(.z-) 语义 命名 语义 命名 字体颜色 fontcolor 背景 background 背景颜色 backgroundcolor 背景图片 backgroundimage 背景定位 backgroundposition 边框颜色 bordercolor 状态(.s-) 语义 命名 语义 命名 选中 selected 当前 current 显示 show 隐藏 hide 打开 open 关闭 close 出错 error 不可用 disabled 样式表命名规范 类型 命名 类型 命名 主要的 master.css 布局、版面 layout.css 基本共用 base.css 文字 font.css 打印 print.css 模块 module.css 表单 forms.css 主题 themes.css 专栏 column.css 补丁 mend.css]]></content>
  </entry>
  <entry>
    <title><![CDATA[JavaScript专题之函数组合]]></title>
    <url>%2F2019%2F09%2F28%2FJavaScript%E4%B8%93%E9%A2%98%E4%B9%8B%E5%87%BD%E6%95%B0%E7%BB%84%E5%90%88%2F</url>
    <content type="text"><![CDATA[我们需要写一个函数，输入’Kevin’，返回’HELLO, KEVIN’。 尝试12345678var toUpperCase = function(X) &#123; return x.toUpperCase() &#125;var hello = function(x) &#123; return 'HELLO' + x &#125;var greet = function(x) &#123; return hello(toUpperCase(x))&#125;greet('kevin') 还哈皮我们只有两个步骤，首先小写转大写，然后凭借拼接字符串。如果有更多的操作，greet函数里就需要更多的的嵌套，类似于fn3(fu2(fn1(fn0()))) 优化试想我们写个compose函数： 12345var compose = function(f, g) &#123; return function(x) &#123; return f(g(x)) &#125;&#125; greet函数就可以被优化为： 12var greet = compose(hello, toUpperCase)greet('kevin') 利用compose将两个函数组合成一个函数，让代码从右向左运行，而不是由内而外运行，可读性大大提升，这便是函数组合。 但是现在的compose函数也只是能支持两个参数，如果有更多的步骤呢？我们岂不是要这样做： 1compose(d, compose(c, compose(b, a))) 为什么我们不写个帅气的compose函数支持传入多个函数呢》这样就变成了： 1compose(d, c, b, a) compose我们直接抄袭underscore的compose函数的实现： 1234567891011function compose() &#123; var args = arguments var start = args.length - 1 return function() &#123; var i = start var result = args[start].apply(this, arguments) while (i--) &#123; result = args[i].call(this, result) &#125; &#125;&#125; 现在的compose函数以及可以支持多个函数了，然而有了这个又有什么用呢？ 在此之前，我们先了解一个概念叫做pointfree。 ## pointfree pointfree指的是函数无须提及将要操作的数组时什么样的，依然时以最初的需求为例： 1234567891011121314// 需求：输入'kevin', 返回'HELLO, KEVIN'// 非pointfree，因为提到了数据： namevar greet = function(name) &#123; return ('hello' + name).toUpperCase()&#125;// pointfree// 先定义基本运算，这些可以封装起来复用var toUpperCase = function(x) &#123; return x.toUpperCase() &#125;var hello = function(x) &#123; return 'HELLO' + x &#125;var greet = compose(hello, toUpperCase)greet('kevin') 我们再举个稍微复杂一点的例子，为了方便书写，我们需要借助在《JavaScript专题之函数柯里化》中写到的 curry 函数： 123456789101112131415161718// 需求：输入 'kevin daisy kelly'，返回 'K.D.K'// 非 pointfree，因为提到了数据：namevar initials = function(name) &#123; return name.split(' ').map(compose(toUpperCase, head()).join('. '))&#125;// pointfree// 先定义基本运算var split = curry(function(separator, str) &#123; return str.split(separator) &#125;)var head = function(str) &#123; return str.slice(0, 1) &#125;var toUpperCase = function(str) &#123; return str.toUpperCase() &#125;var join = curry(function(separator, arr) &#123; return arr.join(separator) &#125;)var map = curry(function(fn, arr) &#123; return arr.map(fn) &#125;)var initials = compose(join('.'), map(compose(toUpperCase, head)), split(' '))initals('Kevin daisy kelly') 从这个例子中我们可以看到，利用柯里化（curry）和函数组合 (compose) 非常有助于实现 pointfree。 也许你会想，这种写法好麻烦呐，我们还需要定义那么多的基础函数……可是如果有工具库已经帮你写好了呢？比如 ramda.js： 12// 使用 ramda.jsvar initials = R.compose(R.join('.'), R.map(R.compose(R.toUpper, R.head)), R.split(' ')); 而且你也会发现： Pointfree 的本质就是使用一些通用的函数，组合出各种复杂运算。上层运算不要直接操作数据，而是通过底层函数去处理。即不使用所要处理的值，只合成运算过程。 那么使用 pointfree 模式究竟有什么好处呢？ pointfree 模式能够帮助我们减少不必要的命名，让代码保持简洁和通用，更符合语义，更容易复用，测试也变得轻而易举。 实战这个例子来自于 Favoring Curry： 假设我们从服务器获取这样的数据： 1234567891011121314151617181920212223var data = &#123; result: "SUCCESS", tasks: [ &#123;id: 104, complete: false, priority: "high", dueDate: "2013-11-29", username: "Scott", title: "Do something", created: "9/22/2013"&#125;, &#123;id: 105, complete: false, priority: "medium", dueDate: "2013-11-22", username: "Lena", title: "Do something else", created: "9/22/2013"&#125;, &#123;id: 107, complete: true, priority: "high", dueDate: "2013-11-22", username: "Mike", title: "Fix the foo", created: "9/22/2013"&#125;, &#123;id: 108, complete: false, priority: "low", dueDate: "2013-11-15", username: "Punam", title: "Adjust the bar", created: "9/25/2013"&#125;, &#123;id: 110, complete: false, priority: "medium", dueDate: "2013-11-15", username: "Scott", title: "Rename everything", created: "10/2/2013"&#125;, &#123;id: 112, complete: true, priority: "high", dueDate: "2013-11-27", username: "Lena", title: "Alter all quuxes", created: "10/5/2013"&#125; ]&#125;; 我们需要写一个名为 getIncompleteTaskSummaries 的函数，接收一个 username 作为参数，从服务器获取数据，然后筛选出这个用户的未完成的任务的 ids、priorities、titles、和 dueDate 数据，并且按照日期升序排序。 以 Scott 为例，最终筛选出的数据为： 123456[ &#123;id: 110, title: "Rename everything", dueDate: "2013-11-15", priority: "medium"&#125;, &#123;id: 104, title: "Do something", dueDate: "2013-11-29", priority: "high"&#125;] 普通的方式为： 123456789101112131415161718192021222324252627282930313233343536373839404142// 过程式编程var fetchData = function() &#123; // 模拟 return Promise.resolve(data)&#125;var getIncompleteTaskSummaries = function(membername) &#123; return fetchData() .then(function(data) &#123; return data.tasks &#125;) .then(function(tasks) &#123; return tasks.filter(function(task) &#123; return task.username == membername &#125;) &#125;) .then(function(tasks) &#123; return tasks.filter(function(task) &#123; return !task.complete &#125;) &#125;) .then(function(tasks) &#123; return tasks.map(function(task) &#123; return &#123; id: task.id, dueDate: task.dueDate, titile: task.title, priority: task.priority &#125; &#125;) &#125;) .then(function(tasks) &#123; return tasks.sort(function(first, second) &#123; var a = first.dueDate, b = second.dueDate return a &lt; b ? -1 : a &gt; b ? 1 : 0 &#125;) &#125;) .then(function(task) &#123; console.log(task) &#125;)&#125; 如果使用pointfree模式： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// version twovar fetchData = function() &#123; return Promise.resolve(data)&#125;// 编写基本函数var prop = curry(function(name, obj) &#123; return obj[name]&#125;)var propEq = curry(function(name, val, obj) &#123; return obj[name] === val&#125;)var filter = curry(function(fn, arr) &#123; return arr.filter(fn)&#125;)var map = curry(function(fn, arr) &#123; return arr.map(fn)&#125;)var pick = curry(function(args, obj) &#123; var result = &#123;&#125; for (var i = 0; i &lt; args.length; i++) &#123; result[args[i] = obj[args[i]]] &#125; return result&#125;)var sortBy = curry(function(fn, arr) &#123; return arr.sort(function(a, b) &#123; var a = fn(a), b = fn(b) return a &lt; b ? -1 : a &gt; b ? 1 : 0 &#125;)&#125;)var getIncompleteTaskSummaries = function(membername) &#123; return fetchData() .then(prop('tasks')) .then(filter(propEq('username', membername))) .then(filter(propEq('complete', flase))) .then(map(pick(['id', 'dueDate', 'title', 'priority']))) .then(sortBy(prop('dueDate'))) .tehn(console.log)&#125;getIncompleteTaskSummaries('Scott') 如果直接使用 ramda.js，你可以省去编写基本函数: 12345678910111213141516// 第三版 使用 ramda.jsvar fetchData = function() &#123; return Promise.resolve(data)&#125;;var getIncompleteTaskSummaries = function(membername) &#123; return fetchData() .then(R.prop('tasks')) .then(R.filter(R.propEq('username', membername))) .then(R.filter(R.propEq('complete', false))) .then(R.map(R.pick(['id', 'dueDate', 'title', 'priority']))) .then(R.sortBy(R.prop('dueDate'))) .then(console.log)&#125;;getIncompleteTaskSummaries('Scott') 当然了，利用 compose，你也可以这样写： 12345678910111213141516171819// 第四版 使用 composevar fetchData = function() &#123; return Promise.resolve(data)&#125;;var getIncompleteTaskSummaries = function(membername) &#123; return fetchData() .then(R.compose( console.log, R.sortBy(R.prop('dueDate')), R.map(R.pick(['id', 'dueDate', 'title', 'priority']) ), R.filter(R.propEq('complete', false)), R.filter(R.propEq('username', membername)), R.prop('tasks'), ))&#125;;getIncompleteTaskSummaries('Scott') compose 是从右到左依此执行，当然你也可以写一个从左到右的版本，但是从右向左执行更加能够反映数学上的含义。 ramda.js 提供了一个 R.pipe 函数，可以做的从左到右，以上可以改写为： 123456789101112// 第五版 使用 R.pipevar getIncompleteTaskSummaries = function(membername) &#123; return fetchData() .then(R.pipe( R.prop('tasks'), R.filter(R.propEq('username', membername)), R.filter(R.propEq('complete', false)), R.map(R.pick(['id', 'dueDate', 'title', 'priority']) R.sortBy(R.prop('dueDate')), console.log, ))&#125;;]]></content>
  </entry>
  <entry>
    <title><![CDATA[JavaScript专题之jQuery通用遍历方式each的实现]]></title>
    <url>%2F2019%2F09%2F28%2FJavaScript%E4%B8%93%E9%A2%98%E4%B9%8BjQuery%E9%80%9A%E7%94%A8%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8Feach%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[jQuery的each方法，作为一个通用遍历方法，可用于遍历对象和数组 语法是： 1jQuery.each(object, [ callback ]) 回调函数拥有两个参数：第一个为对象的成员或数组的索引，第二个为对应变量或内容。 12345678// 遍历数组$.each([0, 1, 2], function(i, n) &#123; console.log("Item #" + i + ": " + n)&#125;)// Item #0: 0// Item #1: 1// Item #2: 2 123456// 遍历对象$.each(&#123; name: "John", lang: "JS" &#125;, function(i, n) &#123; console.log("Name: " + i + ", Value: " + n);&#125;);// Name: name, Value: John// Name: lang, Value: JS 退出循环尽管ES5提供了forEach方法，但是forEach没有办法中止或者跳出forEach循环，除了抛出一个异常。但是对于jQuery的each函数，如果需要退出each循环可使回调函数返回false，其它返回值将被忽略。 12345678$.each([0, 1, 2, 3, 4, 5], function(i , n) &#123; if (i &gt; 2) return false console.log("Item #" + i + ": " + n)&#125;)// Item #0: 0// Item #1: 1// Item #2: 2 第一版那我们该如何实现这个each方法呢？ 首先，我们坑爹要根据参数的类型进行判断，如果是数组，就调用for循环，如果是对象，就使用for-in循环，有个例外是类数组对象，对于类数组对象，我们依然可以使用for循环。 更多关于类数组对象的知识，我们可以查看《JavaScript专题之类数组对象与arguments》 那么又该如何判断类数组对象和数组呢？实际上，我们在《JavaScript专题之类型判断(下)》就讲过jQuery 数组和类数组对象判断函数 isArrayLike 的实现。 所以，我们可以轻松写出第一版： 1234567891011121314151617// version onefunction eah(obj, callback) &#123; var length, i = 0 if (isArrayLike(obj)) &#123; length = obj.length for (; i &lt; length; i++) &#123; callback(i, obj[i]) &#125; &#125; else &#123; for (i in obj) &#123; callback(i, obj[i]) &#125; &#125; return obj&#125; 中止循环现在已经可以遍历对象和数组了，但是依然有一个效果没有实现，就是中止循环，按照jQuery each的实现，当回调函数返回false的时候，我们就中止循环，这个实现也很简单： 我们只用把： 1callback(i, obj[i]) 替换成： 123if (callback(i, obj[i]) === false) &#123; break&#125; this我们在实际的开发中，我们有时会在callback函数中用到this，先举个不怎么恰当的例子： 1234567891011// 我们给每个人添加一个age 属性，age 的值为 18 + indexvar person = [ &#123; name: 'kevin' &#125;, &#123; name: 'daisy' &#125;]$.each(person, function(index, item) &#123; this.age = 18 + index&#125;)console.log(person) 这个时候，我们就希望 this 能指向当前遍历的元素，然后给每个元素添加 age 属性。 指定 this，我们可以使用 call 或者 apply，其实也很简单： 我们把： 123if (callback(i, obj[i]) === false) &#123; break;&#125; 替换成： 123if (callback.call(obj[i], i, obj[i]) === false) &#123; break;&#125; 关于 this，我们再举个常用的例子： 123$.each($(&quot;p&quot;), function()&#123; $(this).hover(function()&#123; ... &#125;);&#125;) 虽然我们经常会这样写： 123$("p").each(function()&#123; $(this).hover(function()&#123; ... &#125;);&#125;) 但是因为 $(“p”).each() 方法是定义在 jQuery 函数的 prototype 对象上面的，而 $.each()方法是定义 jQuery 函数上面的，调用的时候不从复杂的 jQuery 对象上调用，速度快得多。所以我们推荐使用第一种写法。 回到第一种写法上，就是因为将 this 指向了当前 DOM 元素，我们才能使用 $(this)将当前 DOM 元素包装成 jQuery 对象，优雅的使用 hover 方法。 所以最终的 each 源码为： 1234567891011121314151617181920function each(obj, callback) &#123; var length, i = 0 if (isArrayLike(obj)) &#123; length = obj.length for (; i &lt; length; i++) &#123; if (callback.call(obj[i], i, obj[i]) === false) &#123; break &#125; &#125; &#125; else &#123; for (i in obj) &#123; if (callback.call(obj[i], i, obj[i]) === false) &#123; break &#125; &#125; &#125; return obj&#125; ## 性能比较 我们在性能上比较下 for 循环和 each 函数： 12345678910111213141516var arr = Array.from(&#123;length: 1000000&#125;, (v, i) =&gt; i);console.time('for')var i = 0;for (; i &lt; arr.length; i++) &#123; i += arr[i];&#125;console.timeEnd('for')console.time('each')var j = 0;$.each(arr, function(index, item)&#123; j += item;&#125;)console.timeEnd('each') 这里显示一次运算的结果： 从上图可以看出，for 循环的性能是明显好于 each 函数的，each 函数本质上也是用的 for 循环，到底是慢在了哪里呢？ 我们再看一个例子： 1234567891011121314151617181920212223242526272829303132function each(obj, callback) &#123; var i = 0; var length = obj.length for (; i &lt; length; i++) &#123; value = callback(i, obj[i]); &#125;&#125;function eachWithCall(obj, callback) &#123; var i = 0; var length = obj.length for (; i &lt; length; i++) &#123; value = callback.call(obj[i], i, obj[i]); &#125;&#125;var arr = Array.from(&#123;length: 1000000&#125;, (v, i) =&gt; i);console.time('each')var i = 0;each(arr, function(index, item)&#123; i += item;&#125;)console.timeEnd('each')console.time('eachWithCall')var j = 0;eachWithCall(arr, function(index, item)&#123; j += item;&#125;)console.timeEnd('eachWithCall') 这里显示一次运算的结果： each 函数和 eachWithCall 函数唯一的区别就是 eachWithCall 调用了 call，从结果我们可以推测出，call 会导致性能损失，但也正是 call 的存在，我们才能将 this 指向循环中当前的元素。 有舍有得吧。]]></content>
  </entry>
  <entry>
    <title><![CDATA[JavaScript专题之在数组中查找指定元素]]></title>
    <url>%2F2019%2F09%2F28%2FJavaScript%E4%B8%93%E9%A2%98%E4%B9%8B%E5%9C%A8%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%8C%87%E5%AE%9A%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[在开发中，我们经常会遇到在数组中查找指定元素的需求，可能大家觉得这个需求过于简单，然而如何优雅的去实现一个findIndex和findLastIndex、indexOf和lastIndexOf方法确实很少人思考的。 在实现前，先看看ES6的findIndex方法，让大家了解findIndex的使用方法。 findIndexES6对数组新增了findIndex方法，它会返回数组中满足提供的函数的第一个元素的索引，否则返回-1.举个例子： 12345function isBigEnough(element) &#123; return element &gt;= 15&#125;[12, 5, 8, 130, 44].findIndex(isBigEnough) // 3 findIndex会找出 第一个大于15的元素的下标，所以最后返回3。 是不是很简单，其实我们自己实现一个findIndex也很简单。 实现findIndex思路自然明了，遍历一遍，返回符合要求的值的下标。 12345678910function findIndex(array, predicate, context) &#123; for (var i = 0; i &lt; array.length; i++) &#123; if (predicate.call(context, array[i], i, array)) return i &#125; return -1&#125;console.log(findIndex([1, 2, 3, 4], function(item, i, array) &#123; if (item == 3) return true&#125;)) // 2 findLastIndexfindIndex是正序查找，但如indexOf还有一个对应的lastIndexOf方法，我们夜宵写一个倒序查找的findLastIndex函数，实现自然也很简单，只要修改下循环即可。 1234567891011function findLastIndex(array, predicate, context) &#123; var length = array.length for (var i = length - 1; i &gt;= 0; i++) &#123; if (predicate.call(context, array[i], i, array)) return i &#125; return -1&#125;console.log(findLastIndex([1, 2, 3, 4], function(item, index, array)&#123; if (item == 1) return true;&#125;)) // 0 createIndexFindert然而为你在于，findIndex和findLasIndex其实有很多重复的部分，如何精简冗余的内容呢？这便是我们要学习的地方。 underscope的思路就是利用传参的不同，返回不同的函数，这个自然简单，但是如何根据参数的不同。在同一个循环中，实现正序和倒序遍历呢？ 让我们直接模仿underscore的实现： 123456789101112131415function createIndexFinder(dir) &#123; return function(array, predicate, context) &#123; var length = array.length var index = dir &gt; 0 ? 0 : length - 1 for (; index &gt;= 0 &amp;&amp; index &lt; length; index += dir) &#123; if (perdicate.call(context, array[index], index, array)) return index &#125; return -1 &#125;&#125;var findIndex = createIndexFinder(1)var findLastIndex = createIndexFinder(-1) sortedIndexfindIndex 和findLastIndex的需求算是结束了，但是又来了个一个新需求：在一个排好序的数组中找到value对应的位置，保证插入数组后，依然保持有序的状态。 假设该函数名为sortedIndex，效果为： 1sortedIndex([10, 20, 30], 25) // 2 也就是说如果，注意是如果，25 按照此下标插入数组后，数组变成 [10, 20, 25, 30]，数组依然是有序的状态。 那么这个又该如何实现呢？ 既然是有序的数组，那我们就不需要遍历，大可以使用二分查找法，确定值的位置。让我们尝试着去写一版： 1234567891011121314// version onefunction sortedIndex(array, obj) &#123; var low = 0, high = array.length while (low &lt; high) &#123; var mid = Math.floor((low + high) / 2) if (array[mid] &lt; obj) low = mid + 1 else high = mid &#125; return high&#125;console.log(sortedIndex([10, 20, 30, 40, 50], 35)) // 3 现在的方法虽然能用，但通用性不够，比如我们希望能处理这样的情况： 12345678// stooges 配角var stooges = [&#123;name: 'stooge1', age: 10&#125;, &#123;name: 'stooge2', age: 30&#125;]var result = sortedIndex(stooges, &#123; name: 'stooge3', age: 20 &#125;, function(stooge) &#123; return stooge.age&#125;)console.log(result) // 1 所以我们还需要再加上一个参数iteratee函数对数组的每个元素进行处理，一般这个时候，还会涉及this指向的问题，所以我们再传一个context来让我们可以指定this，那么这样一个函数又该如何写呢？ 12345678910111213141516171819// version twofunction cb(func, context) &#123; if (context === void 0) return func return function() &#123; return func.apply(context, arguments) &#125;&#125;function sortedIndex(array, obj, iteratee, context) &#123; iteratee = cb(iteratee, context) var low = 0, high = array.length while (low &lt; high) &#123; var mid = Math.floor((low + high) / 2); if (iteratee(array[mid]) &lt; iteratee(obj)) low = mid + 1; else high = mid; &#125; return high&#125; indexOfsortedIndex也完成了，现在我们尝试着去写一个indexOf和lastIndexOf函数，学习findIndex和findLastIndex的方式，我们写一版： 12345678910111213141516171819// version onefunction createIndexOfFinder(dir) &#123; return function(array, item) &#123; var length = array.length var index = dir &gt; 0 ? 0 : length -2 for (; index &gt;= 0 &amp;&amp; index &lt; length; index += dir) &#123; if (array[index] === item) return index &#125; return -1 &#125;&#125;var indexOf = createIndexOfFinder(1);var lastIndexOf = createIndexOfFinder(-1);var result = indexOf([1, 2, 3, 4, 5], 2);console.log(result) // 1 fromIndex但是即使是数组的 indexOf 方法也可以多传递一个参数 fromIndex，从 MDN 中看到 fromIndex 的讲究可有点多： 设定开始查找的位置。如果该索引值大于或等于数组长度，意味着不会在数组里查找，返回 -1。如果参数中提供的索引值是一个负值，则将其作为数组末尾的一个抵消，即 -1 表示从最后一个元素开始查找，-2 表示从倒数第二个元素开始查找 ，以此类推。 注意：如果参数中提供的索引值是一个负值，仍然从前向后查询数组。如果抵消后的索引值仍小于 0，则整个数组都将会被查询。其默认值为 0。 再看看 lastIndexOf 的 fromIndex： 从此位置开始逆向查找。默认为数组的长度减 1，即整个数组都被查找。如果该值大于或等于数组的长度，则整个数组会被查找。如果为负值，将其视为从数组末尾向前的偏移。即使该值为负，数组仍然会被从后向前查找。如果该值为负时，其绝对值大于数组长度，则方法返回 -1，即数组不会被查找。 按照这么多的规则，我们尝试着去写第二版： 12345678910111213141516171819202122function createIndexOfFinder(dir) &#123; return function(array, item, idx) &#123; var length = array.length var i = 0 if (typeof idx == 'number') &#123; if (dir &gt; 0) &#123; i = idx &gt;= 0 ? idx : Math.max(length + idx, 0) &#125; else &#123; length = idx &gt;= 0 : Math.min(idx + 1, length) : idx +length + 1 &#125; &#125; for (idx = dir &gt; 0 ? i : length - 1; idx &gt;= 0 &amp;&amp; idx &lt; length; idx += dir) &#123; if (array[idx] === item) return idx &#125; return -1 &#125;&#125;var indexOf = createIndexOfFinder(1)var lastIndexOf = createIndexOfFinder(-1) 优化到处为此，已经很接近原生的 indexOf 函数了，但是 underscore 在此基础上还做了两点优化。 第一个优化是支持查找 NaN。 因为 NaN 不全等于 NaN，所以原生的 indexOf 并不能找出 NaN 的下标。 1[1, NaN].indexOf(NaN) // -1 那么我们该如何实现这个功能呢？ 就是从数组中找到符合条件的值的下标嘛，不就是我们最一开始写的 findIndex 吗？ 我们来写一下： 123456789101112131415161718// version threefunction createIndexOfFinder(dir, predicate) &#123; return function(array, item, idx) &#123; if () &#123; ..... &#125; // 判断元素是否是NaN if (item !== item) &#123; // 在截取好的数组中查找第一个满足isNaN函数的元素的下标 idx = predicate(array.slice(i, length), isNaN) return idx &gt;= 0 ? idx + i : -1 &#125; for () &#123; ..... &#125; &#125;&#125;var indexOf = createIndexOfFinder(1, findIndex);var lastIndexOf = createIndexOfFinder(-1, findLastIndex); 第二个优化是支持对有序的数组进行更快的二分查找。 如果 indexOf 第三个参数不传开始搜索的下标值，而是一个布尔值 true，就认为数组是一个排好序的数组，这时候，就会采用更快的二分法进行查找，这个时候，可以利用我们写的 sortedIndex 函数。 在这里直接给最终的源码： 123456789101112131415161718192021222324252627282930313233343536// 第四版function createIndexOfFinder(dir, predicate, sortedIndex) &#123; return function(array, item, idx)&#123; var length = array.length; var i = 0; if (typeof idx == "number") &#123; if (dir &gt; 0) &#123; i = idx &gt;= 0 ? idx : Math.max(length + idx, 0); &#125; else &#123; length = idx &gt;= 0 ? Math.min(idx + 1, length) : idx + length + 1; &#125; &#125; else if (sortedIndex &amp;&amp; idx &amp;&amp; length) &#123; idx = sortedIndex(array, item); // 如果该插入的位置的值正好等于元素的值，说明是第一个符合要求的值 return array[idx] === item ? idx : -1; &#125; // 判断是否是 NaN if (item !== item) &#123; idx = predicate(array.slice(i, length), isNaN) return idx &gt;= 0 ? idx + i: -1; &#125; for (idx = dir &gt; 0 ? i : length - 1; idx &gt;= 0 &amp;&amp; idx &lt; length; idx += dir) &#123; if (array[idx] === item) return idx; &#125; return -1; &#125;&#125;var indexOf = createIndexOfFinder(1, findIndex, sortedIndex);var lastIndexOf = createIndexOfFinder(-1, findLastIndex); 值得注意的是：在 underscore 的实现中，只有 indexOf 是支持有序数组使用二分查找，lastIndexOf 并不支持。]]></content>
  </entry>
  <entry>
    <title><![CDATA[JavaScript专题之如何求数组的最大值和最小值]]></title>
    <url>%2F2019%2F09%2F28%2FJavaScript%E4%B8%93%E9%A2%98%E4%B9%8B%E5%A6%82%E4%BD%95%E6%B1%82%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%E5%92%8C%E6%9C%80%E5%B0%8F%E5%80%BC%2F</url>
    <content type="text"><![CDATA[取出数组中的最大值或者最小值是开发中常见的需求，但你能想出几种方法来实现这个需求呢？ Math.maxJavaScript提供了Math.max函数返回一组数中最大值，用法是： 1Math.max([value1[, value2, ...]]) 值得注意的是： 如果有任一参数不能被转换为数值，则结果为NaN。 max是Math的静态方法，所以应该像这样使用：Math.max()，而不是作为Math实例的方法。 如果没有参数，则结果为-Infinity(注意是负无穷大) 而我们需要分析的是： 如果任一参数不能被转换为数值，这就意味着如果参数可以被转换成数值，就是可以进行比较的，比如： 1234567Math.max(true, 0) // 1Math.max(true, '2', null) // 2Math.max(1, undefined) //NaNMath.max(1, &#123;&#125;) //Nan 如果没有参数，则结果为-Infinity,对应的，Math.min函数，如果没有参数，则结果为Infinity,所以： 123var min = Math.min()var max = Math.max()console.log(min &gt; max) 了解了Math.max方法，我们以求数值最大值的为例，思考有哪些方法可以实现这个需求。 原始方法最最最原始的方法，莫过于循环遍历一遍。 12345678var arr = [6, 4, 1, 8, 2, 11, 23]var result = arr[0]for (var i = 1; 1 &lt; arr.length; i++) &#123; result = Math.max(result, arr[i])&#125;console.log(result) reduce既然是通过遍历数组求出一个最终值，那么我们就可以使用reduce方法： 1234567var arr = [6, 4, 1, 8, 2, 11, 23]function max(prev, next) &#123; return Math.max(prev, next)&#125;console.log(arr.reduce(max) 排序如果我们先对数组进行一次排序，那么最大值就是最后一个值： 1234var arr = [6, 4, 1, 8, 2, 11, 23]arr.sort(function(a, b) &#123; return a - b &#125;)console.log(arr[arr.length -1]) evalMath.max支持多个参数来进行比较，那么我们如何将一个数组转换成参数传入Math.max函数呢？eval便是一种： 1234var arr = [6, 4, 1, 8, 2, 11, 23]var max = eval('Math.max('+ arr +')')console.log(max) apply使用apply是另一种： 123var arr = [6, 4, 1, 8, 2, 11, 23]console.log(Math.max.apply(null, arr)) ES6 扩展运算符使用ES6的…扩展运算符 12var arr = [6, 4, 1, 8, 2, 11, 23]console.log(Math.max(...arr))]]></content>
  </entry>
  <entry>
    <title><![CDATA[JavaScript专题之类型判断]]></title>
    <url>%2F2019%2F09%2F27%2FJavaScript%E4%B8%93%E9%A2%98%E4%B9%8B%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD%2F</url>
    <content type="text"><![CDATA[类型判断在web开发中有非常广泛的应用，简单的有判断数字还是字符串，进阶一点的有判断数组还是对象，再进阶一点的有判断日期、正则、错误类型，再再进阶一点还有比如判断plainObject、空对象、Window对象等等。 typeof我们最最常用的莫过于typeof。注意，尽管我们会看到诸如的写法： 1console.log(typeof('yayu')) // string 但是typeof可是一个正宗的运算符，所以下面这种写法也是可行的： 1console.log(typeof 'yayu') // string 引用《JavaScript权威指南》中对typeof的介绍： typeof 是一元操作符，放在其单个操作数的前面，操作数可以是任意类型。返回值为表示操作数类型的一个字符串 那我们都知道，在ES6前，JavaScript共六种数据类型，分别是： undefined、null、boolean、number、string、object 然而当我们使用typeof对这些数据类型的值进行操作的时候，返回的结果去不是一一对应，分别是： undefined、object、boolean、number、string、object 注意以上都是小写的字符串，null和object类型都返回了object字符串。 尽管不能一一对应，但是typeof去能检测出函数类型： 123function a() &#123;&#125;console.log(typeof a) // function 所以typeof能检测出六种类型的值，但是，除此之外Object下还有很多细分的类型，入Array、Function、Date、RegExp、Error等。 如果用typeof去检测这些类型，举个例子： 1234var date = new Date()var error = new Error()console.log(typeof date) // objectconsole.log(typeof error) // object 返回的都是object，那我们有什么更好的方法？ Object.prototype.toString是的，当然有！这就是 Object.prototype.toString！ 那 Object.protototype.toString 究竟是一个什么样的方法呢？ 为了更加细致的讲解这个函数，让我先献上 ES5 规范地址：https://es5.github.io/#x15.2.4.2。 在第 15.2.4.2 节讲的就是 Object.prototype.toString()，为了不误导大家，我先奉上英文版： When the toString method is called, the following steps are taken: If the this value is undefined, return “[object Undefined]“. If the this value is null, return “[object Null]“. Let O be the result of calling ToObject passing the this value as the argument. Let class be the value of the [[Class]] internal property of O. Return the String value that is the result of concatenating the three Strings “[object “, class, and “]“. 凡是规范上加粗或者斜体的，在这里我也加粗或者斜体了，就是要让大家感受原汁原味的规范！ 如果没有看懂，就不妨看看我理解的： 当 toString 方法被调用的时候，下面的步骤会被执行： 如果 this 值是 undefined，就返回 [object Undefined] 如果 this 的值是 null，就返回 [object Null] 让 O 成为 ToObject(this) 的结果 让 class 成为 O 的内部属性 [[Class]] 的值 最后返回由 “[object “ 和 class 和 “]” 三个部分组成的字符串 通过规范，我们至少知道了调用Object.prototype.toString会返回一个由 “[object “ 和 class 和 “]” 组成的字符串，而 class 是要判断的对象的内部属性。 让我们写个demo： 12345console.log(Object.prototype.toString.call(undefined)) // [object Undefined]console.log(Object.prototype.toString.call(null)) // [object Null]var date = new Date()console.log(Object.prototype.toString.call(date)) // [object Date] 由此我们可以知道这个class值是识别对象类型的关键！ 正是因为这种特性，我们可以用Object.prototype.toString方法识别出更多类型！ 我们总共能识别至少12种类型： 1234567891011121314151617181920// 以下是11种：var number = 1; // [object Number]var string = '123'; // [object String]var boolean = true; // [object Boolean]var und = undefined; // [object Undefined]var nul = null; // [object Null]var obj = &#123;a: 1&#125; // [object Object]var array = [1, 2, 3]; // [object Array]var date = new Date(); // [object Date]var error = new Error(); // [object Error]var reg = /a/g; // [object RegExp]var func = function a()&#123;&#125;; // [object Function]function checkType() &#123; for (var i = 0; i &lt; arguments.length; i++) &#123; console.log(Object.prototype.toString.call(arguments[i])) &#125;&#125;checkType(number, string, boolean, und, nul, obj, array, date, error, reg, func) 除了以上 11 种之外，还有： 12console.log(Object.prototype.toString.call(Math)); // [object Math]console.log(Object.prototype.toString.call(JSON)); // [object JSON] 除了以上 13 种之外，还有： 1234function a() &#123; console.log(Object.prototype.toString.call(arguments)); // [object Arguments]&#125;a(); 所以我们可以识别至少 14 种类型，当然我们也可以算出来，[[class]] 属性至少有 12 个。 type API既然有了Object.prototype.toString这个神器。那我们来写个type函数帮助我们以后识别各种类型的值吧！ 我的设想： 写一个type函数能检测各种类型的值，如果是基本类型，就是要typeof，引用类型就使用toString。此外鉴于tyoeif的返回值是小写，所以我希望所有的结果都是小写。 考虑实际情况并不会检测Math和JSON，所以去掉这两个类型的检测。 我们来写第一版代码： 12345678910111213// version onevar class2type = &#123;&#125;// 生成class2type映射'Boolean Number String Function Array Date RegExp Object Error Null Undefined'.split(' ').map(function(item, index) &#123; class2type['[object' + item + ']'] = item.toLowerCase()&#125;)function type(obj) &#123; return typeof obj === 'obj' || typeof obj === 'function' ? class2tye[Object.prototype.toString.call(obj)] || 'object' : typeof obj&#125; 嗯，看起来很完美的样子~~ 但是注意，在 IE6 中，null 和 undefined 会被 Object.prototype.toString 识别成 [object Object]！ 我去，竟然还有这个兼容性！有什么简单的方法可以解决吗？那我们再改写一版，绝对让你惊艳！ 12345678910111213141516// version twovar class2type = &#123;&#125;// 生成class2type映射"Boolean Number String Function Array Date RegExp Object Error".split(' ').map(function(item, index) &#123; class2type['[object' + item + ']'] = item.toLowerCase()&#125;)function type(obj) &#123; if (obj == null) &#123; return obj + '' &#125; return typeof obj === 'object' || typeof obj === 'function' ? class2type[Object.prototype.toString.call(obj)] || 'object' : typeof obj&#125; isFunction有了type函数后，我们可以对常用的判断直接封装，比如isFunction： 123function isFunction(obj) &#123; return type(obj) === 'function'&#125; 数组jQuery判断数组类型，旧版本是通过判断Array.isArray方法是存在，如果存在就使用该方法，不存在就是要type函数。 123var isArray = Array.isArray || function(obj) &#123; return type(obj) === 'array'&#125; 但是在jQuery v3.0 中已经完全采用了 Array.isArray。 plainObjectplainObject来自于jQuery，可以翻译成纯粹的对象，所谓’纯粹的对象’，就是指该对象是通过’{}’或’new Object’创建的，该对象含有零个或者多个键值对。 之所以要判断是不是plainObject，是为了跟其他的JavaScript对象如null，数组，宿主对象等作区分，因为这些用typeof都会返回object。 jQuery提供了isPlainObject方法进行判断，先让我们看看使用的效果： 123456789101112131415function Person(name) &#123; this.name = name&#125;console.log($.isPlainObject(&#123;&#125;)) // trueconsole.log($.isPlainObject(new Object)) // trueconsole.log($.isPlainObject(Object.create(null))) // trueconsole.log($.isPlainObject(Object.assign(&#123; a: 1&#125;, &#123; b: 2&#125;))) // trueconsole.log($.isPlainObject(new Person('yayu'))) // falseconsole.log($.isPlainObject(Object.create(&#123;&#125;))) // false 由此我们可以看到，除了{} 和new Object创建的之外，jQuery认为一个没有原型的对象也是一个纯粹的对象。 实际上随着jQuery版本的提升，isPlainObject的实现也在变化，我们今天讲的是3.0版本下的isPlainObject，我们直接看源码： 123456789101112131415161718192021222324252627282930313233// 存放toString映射结果的对象var class2type = &#123;&#125; // 相当于 Object.prototype.toStringvar toString = class2type.toString// 相当于Object.prototype.hasOwnPropertyvar hasOwn = class2type.hasOwnPropertyfunction isPlainObject(obj) &#123; var proto, Ctor // 排除掉明显不是obj的以及一些宿主对象如window if (!obj || toString.call(obj) !== '[object Object]') &#123; return false &#125; /** * getPrototypeOf es5 方法，获取 obj 的原型 * 以 new Object 创建的对象为例的话 * obj.__proto__ === Object.prototype */ proto = Object.getPrototypeOf(obj) if (!proto) &#123; return true &#125; /** * 以下判断通过 new Object 方式创建的对象 * 判断 proto 是否有 constructor 属性，如果有就让 Ctor 的值为 proto.constructor * 如果是 Object 函数创建的对象，Ctor 在这里就等于 Object 构造函数 */ Ctor = hasOwn.call(proto, 'constructor') &amp;&amp; proto.constructor // 在这里判断Ctor构造函数是不是Object构造函数，用于区分自定义构造函数和Object构造函数 return typeof Ctor === 'function' &amp;&amp; hasOwn.toString.call(Ctor) === hasOwn.toString.call(Objectt)&#125; 注意，我们判断Ctor构造函数是不是Object构造函数，用的是hasOwn.toString.call(Ctor)，这个方法可不是Objec.prototype.toString,不信我们在函数里加上下面这两句话： 12console.log(hasOwn.toString.call(Ctor)); // function Object() &#123; [native code] &#125;console.log(Object.prototype.toString.call(Ctor)); // [object Function] 发现返回的值并不一样，这是因为hasOwn.toString调用的其实是Function.prototype.toString，毕竟hasOwnProperty可是一个函数。 而且Function对象覆盖从Object继承来的Object.prototype.toString方法。函数的toString方法会返回一个表示函数源代码的字符串。具体来说，包括function关键字，形参列表，大括号，以及函数体中的内容。 EmptyObjectjQuery提供了isEmptyObject方法来判断是否是空对象，代码简单，我们直接看源码： 12345678function isEmptyObject(obj) &#123; var name for ( name in obj ) &#123; return false &#125; return true&#125; 其实所谓的isEmptyObject就是判断是否有属性，for循环一旦执行，就说明又属性，又熟悉就会返回false。 但是根据这个源码我们可以看出isEmptyObject实际上判断的不仅仅是空对象。 举个例子： 12345678910111213console.log(isEmptyObject(&#123;&#125;)) // trueconsole.log(isEmptyObject([])) // trueconsole.log(isEmptyObject(null)) // trueconsole.log(isEmptyObject(undefined)) // trueconsole.log(isEmptyObject(1)) // trueconsole.log(isEmptyObject('')) // tureconsole.log(isEmotyObject(true)) // rue 但是既然 jQuery 是这样写，可能是因为考虑到实际开发中 isEmptyObject 用来判断 {} 和 {a: 1} 是足够的吧。如果真的是只判断 {}，完全可以结合上面写的 type 函数筛选掉不适合的情况。 Window对象Window 对象作为客户端 JavaScript 的全局对象，它有一个 window 属性指向自身，这点在《JavaScript深入之变量对象》中讲到过。我们可以利用这个特性判断是否是 Window 对象。 123function isWindow(obj) &#123; return obj != null &amp;&amp; obj === obj.window&#125; isArrayLikeisArrayLike，看名字可能会让我们觉得这是判断类数组对象的，其实不仅仅是这样，jQuery实现的isArrayLike，数组和类数组都会返回true。 因为源码比较简单，我们直接看源码： 12345678910111213function isArrayLike(obj) &#123; // obj必须有length属性 var length = !!obj &amp;&amp; 'length' in obj &amp;&amp; obj.length var typeRes = type(obj) // 排除函数和window对象 if (typeRes === 'function' || isWindow(obj)) &#123; return false &#125; return typeRes === 'array' || length === 0 || typeof length === 'number' &amp;&amp; length &gt; 0 &amp;&amp; (length = 1) in obj&#125; 重点分析return这一行，使用了或语句，只要一个为true，结果就返回true。 所以如果 isArrayLike 返回true，至少要满足三个条件之一： 是数组 长度为 0 lengths 属性是大于 0 的数字类型，并且obj[length - 1]必须存在 第一个就不说了，看第二个，为什么长度为 0 就可以直接判断为 true 呢？ 那我们写个对象： 1var obj = &#123; a: 1, b: 2, length: 0&#125; isArrayLike函数就会返回true，那这个合理吗？ 回答合不合理之前，我们先看一个例子： 1234function a()&#123; console.log(isArrayLike(arguments))&#125;a() 如果我们去掉length === 0这个判断，就会打印false，然而我们都知道arguments是一个类数组对象，这里是应该返回true的。 所以是不是为了放过空的arguments时也放过了一些存在争议的对象呢？ 第三个条件： length是数字，并且length &gt; 0 且最后一个元素存在。 为什么仅仅要求最后一个元素存在呢？ 让我们先想下数组是不是可以这样写： 1var arr = [, , 3] 当我们写一个对应的类数组对象就是： 1234var arrLike = &#123; 2: 3 length: 3&#125; 也就是说当我们在数组中用逗号直接跳过的时候，我们认为该元素是不存在的，类数组对象中也就不用写这个元素，但是最后一个元素是一定要写的，要不然length的长度就不会是最后一个元素的key值加1，比如数组可以这样写 12var arr = [1, , ]console.log(arr.length) / 2 但是类数组对象就只能写成： 1234var arrLike = &#123; 0: 1, length: 1&#125; 所以符号条件的类数组对象是一定存在最后一个元素的！ 这就是满足 isArrayLike 的三个条件，其实除了 jQuery 之外，很多库都有对 isArrayLike 的实现，比如 underscore: 123456var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1var isArrayLike = function(collection) &#123; var length = getLength(collection) return typeof length == 'number' &amp;&amp; length &gt;= 0 &amp;&amp; length &lt;= MAX_ARRAY_INDEX&#125; isElementisElement判断是不是DOM元素 123isElement = function(obj) &#123; return !!(obj &amp;&amp; obj.nodeType === 1)&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[JavaScript专题之从零实现jQuery的extend]]></title>
    <url>%2F2019%2F09%2F27%2FJavaScript%E4%B8%93%E9%A2%98%E4%B9%8B%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0jQuery%E7%9A%84extend%2F</url>
    <content type="text"><![CDATA[jQuery的extend是jQuery中应用非常多的一个函数，今天我们一起看jQuery的extend特性，一边实现一个extend。 extend基本语法先来看看extend的功能，引用jQuery官网： Merge the contetns of two or more objects together into the first object 翻译过来是，合并两个或者更多的对象的内容到第一个对象中。 让我们看看extend的用法： 1jQuery.extend(target[, object1 ], [, objectN ]) 第一个参数target，表示要拓展的目标，我们就称它为目标对象。 后面的参数，都传入对象，内容都会复制到目标对象中，我们就称它们为待复制对象。 举个例子： 1234567891011121314151617181920212223242526272829var obj = &#123; a: 1, b: &#123; b1: 1, b2: 2 &#125;&#125;var obj2 = &#123; b: &#123; b1: 3, b3: 4 &#125;, c: 3&#125;var obj3 = &#123; d: 4&#125;console.log($.extend(obj1, obj2, obj3))// &#123;// a: 1,// b: &#123; b1: 3, b3: 4 &#125;,// c: 3,// d: 4// &#125; 当两个对象出现相同字段的时候，后者会覆盖前者，而不会进行深层次的覆盖。 extend 第一版结合《JavaScript专题之深浅拷贝》，我们尝试着自己写一个extend函数： 1234567891011121314151617181920// version onefunction extend() &#123; var name, options, copy var length = arguments.length var i = 1 var target = arguments[0] for (; i &lt; length； i++) &#123; options = arguments[i] if (options != null) &#123; for (name in options) &#123; copy = options[name] if (copy !== undefined) &#123; target[name] = copy &#125; &#125; &#125; &#125; return target&#125; extend 深拷贝那如何进行深层次的复制呢？jQuery v1.1.4 加入了一个新的用法： 1jQuery.extend( [deep], target, object1 [, objectN ] ) 也就是说，函数的第一个参数可以传一个布尔值，如果为true，我们就会进行深拷贝，false的话依然当做浅拷贝，这个时候，target就会往后移动到第二个参数。 还是举这个例子： 123456789101112131415161718192021222324252627var obj1 = &#123; a: 1, b: &#123; b1: 1, b2: 2 &#125;&#125;var obj2 = &#123; b2: &#123; b1: 3, b4: 4 &#125;, c: 3&#125;var obj3 = &#123; d: 4&#125;console.log($.extend(true, obj1, obj3, obj3))// &#123;// a: 1,// b: &#123; b1: 3, b2: 2, b3: 4 &#125;,// c: 3,// d: 4// &#125; 因为采用了深拷贝，会遍历到更深的层次进行添加和覆盖。 extend第二版我们来实现深拷贝的功能，值得注意的是： 需要根据第一个参数的类型，确定target和要合并的对象的下标起始值。 如果是深拷贝，根据copy的类型递归extend。 123456789101112131415161718192021222324252627282930313233343536373839404142434445// version twofunction extend() &#123; // 默认不进行深拷贝 var deep = false var name, options, src, copy var length = arguments.length // 记录要复制的对象的下标 var i = 1 // 第一个参数不传布尔值的情况下，target默认是第一个参数 var target = arguments[0] || &#123;&#125; // 如果第一个参数是布尔值，第二个参数才是taget if (typeof target == 'boolean') &#123; deep = target target = arguments[i] || &#123;&#125; i++ &#125; // 如果target不是对象，我们是无法进行复制的，所有设为&#123;&#125; if (typeof target !== 'object') &#123; target = &#123;&#125; &#125; // 循环遍历要复制的对象们 for(; i &lt; length; i++) &#123; // 获取当前对象 options = arguments[i] // 要求不能为空，避免extend(a, , b)这种情况 if (options != null) &#123; for (name in options) &#123; // 目标属性值 src = target[name] // 要复制的对象的属性值 copy = options[name] if (deep &amp;&amp; copy &amp;&amp; typeof copy == 'object') &#123; // 递归调用 target[name] = extend(deep, src, copy) &#125; else if (copy !== undefined) &#123; target[name] = copy &#125; &#125; &#125; &#125; return target&#125; 在实现上，核心的部分还是跟上篇实现的深浅拷贝函数一致，如果要复制的对象的属性值是一个对象，就递归调用extend。不过extend的实现中，多了黑洞细节上的判断，比如第一个函数是否是布尔值，target是否是一个对象，不传参数时的默认值等。 接下来，我们看几个jQuery的extend使用效果： target是函数在我们的实现中，typeof target必须等于object，我们才会在这个target继承上进行拓展，然而我们用typeof判断一个函数时，会返回function，也就是说，我们无法在一个函数上进行拓展！ 什么，我们还能在一个函数上进行拓展！！ 当然啦，毕竟函数也是一种对象嘛，让我们看个例子： 12345function a() &#123;&#125;a.target = 'b';console.log(a.target); // b 实际上，在 underscore 的实现中，underscore 的各种方法便是挂在了函数上！ 所以在这里我们还要判断是不是函数，这时候我们便可以使用《JavaScript专题之类型判断》中写得 isFunction 函数 我们这样修改： 123if (typeof target !== 'object' &amp;&amp; !isFunction(target)) &#123; target = &#123;&#125;&#125; 类型不一致其实我们实现的方法有个小bug，不信我们写个demo： 12345678910111213141516var obj1 = &#123; a: 1, b: &#123; c: 2 &#125;&#125;var obj2 = &#123; b: &#123; c: [5], &#125;&#125;var d = extend(true, obj1, obj2)console.log(d); 我们预期会返回这样一个对象： 123456&#123; a: 1, b: &#123; c: [5] &#125;&#125; 然而返回了这样一个对象: 12345678&#123; a: 1, b: &#123; c: &#123; 0: 5 &#125; &#125;&#125; 让我们细细分析为什么会导致这种问题： 首先我们在函数的开始写一个console函数比如：console.log(1)，然后以上面的demo为例，执行一次，我们会发现1打印了3此，这就是说extend函数执行了三遍，让我们捋一捋这三遍传入的参数： 第一遍执行到递归调用时： 1234var src = &#123; c: 2 &#125;var copy = &#123; c: [5] &#125;target[name] = extend(true, src, cpy) 第二遍执行递归调用时： 1234var srv = 2var copy = [5]target[name] = extend(true, src, copy) 第三遍进行最终的赋值，因为src是一个基本类型，我们默认使用一个空对象作为目标值，所有最终的结果就变成了对象的属性！ 为了解决这个问题，我们需要对目标属性值和待复制对象的属性值进行判断： 如果待复制对象属性值类型为数组，目标属性值类型不为数组的话，目标属性值就设为[]。 如果待复制对象属性值类型为对象，目标属性值类型不为对象的话，目标属性值就设为{} 结合着《JavaScript专题之类型判断(下)》中的 isPlainObject 函数，我们可以对类型进行更细致的划分： 1234567891011121314var clone, copyIsArrayif (deep &amp;&amp; copy &amp;&amp; (isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) &#123; if (copyIsArray) &#123; copyIsArray = false clone = src &amp;&amp; Array.isArray(src) ? src : [] &#125; else &#123; clone = src &amp;&amp; isPlainObject(src) ? src : &#123;&#125; &#125; target[name] = extend(deep, clone, copy)&#125; else if (copy !== undefined) &#123; target[name] = copy&#125; 循环引用实际上，我们还可能遇到一个循环引用的问题，举个例子： 12345var a = &#123; name: b &#125;var b = &#123; name: a &#125;var c = extend(a, b)console.log(c) 我们会得到一个可以无限展开的对象，类似于这样： 为了避免这个问题，我们需要判断要复制的对象属性是否等于target，如果等于，我们就跳过： 12345678...src = target[name]copy = options[name]if (target === copy) &#123; continue&#125;... 如果假设这句，结果就会是： 1&#123; name: undefined &#125; 最终代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273// isPlainObject 函数来自于 [JavaScript专题之类型判断(下) ]()var class2type = &#123;&#125;var toString = class2type.toString()var hasOwn = class2type.hasOwnPropertyfunction isPlainObject(obj) &#123; var proto, Ctor if (!obj || toString.call(obj) !== '[object Object]') &#123; return false &#125; proto = Object.getPrototypeOf(obj) if (!proto) &#123; return true &#125; Ctor = hasOwn.call(proto, 'constructor') &amp;&amp; proto.constructor return typeof Ctor === 'function' &amp;&amp; hasOwn.toString.call(Ctor) === hasOwn.toString.call(Object)&#125;function extend() &#123; // 默认不进行深拷贝 var deep = false var name, options, src, copy, clone, copyIsArray var length = arguments.length // 记录要复制的对象的下标 var i = 1 // 第一个参数不传布尔值的情况下，target默认是第一个参数 var target = arguments[0] || &#123;&#125; // 如果第一个参数是布尔值，第二个参数是target if (typeof target == 'boolean') &#123; deep = target target = argument[i] || &#123;&#125; i++; &#125; // 如果target不是对象，我们是无法进行复制的，所以设为&#123;&#125; if (typeof target !== 'object' &amp;&amp; !isFunction(target)) &#123; target = &#123;&#125; &#125; // 循环遍历要复制的对象们 for(; i &lt; length; i++) &#123; // 获取当前对象 options = arguments[i] // 要求不能为空，避免extend(a, , b)这种情况 if (options != null) &#123; for (name in options) &#123; // 目标属性值 src = target[name] // 要复制对象的数值型 copy = options[name] // 解决循环引用 if (target === copy) &#123; continue &#125; // 要递归的对象必须是plainObject或者数组 if (deep &amp;&amp; copy &amp;&amp; (isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) &#123; // 要复制的对象属性值类型需要与目标属性值相同 if (copyIsArray) &#123; copyIsArray = false clone = src &amp;&amp; Array.isArray(src) ? src : [] &#125; else &#123; clone = src &amp;&amp; isPlainObject(src) ? src : &#123;&#125; &#125; target[name] = extend(deep, clone, copy) &#125; else if (copy !== undefined) &#123; target[name] = copy &#125; &#125; &#125; &#125; return target&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[JavaScript专题之递归]]></title>
    <url>%2F2019%2F09%2F26%2FJavaScript%E4%B8%93%E9%A2%98%E4%B9%8B%E9%80%92%E5%BD%92%2F</url>
    <content type="text"><![CDATA[程序调用自身的编程技巧称为递归（recursion）。 阶乘以阶乘为例： 123456function factorial(n) &#123; if (n == 1) return n return n * factorial(n -1)&#125;console.log(factorial(5)) // 5 * 4 * 3 * 2 * 1 = 120 示意图(图片来自 wwww.penjee.com)： 斐波那契数列在《JavaScript专题之函数记忆》中讲到过的斐波那契数列也使用了递归： 12345function fibonacci(n) &#123; return n &lt; 2 ? n : fibonacci(n - 1) + fibonacci(n - 2)&#125;console.log(fibonacci(5)) // 1 1 2 3 5 递归条件从这两个例子中，我们可以看出： 构成递归需要具备边界条件，递归前进段和递归返回段，当边界条件不满足时，递归前进，当边界条件满足时，递归返回。阶乘中的n == 1 和 斐波那契数列中的 n &lt; 2 都是边界条件。 总结一下递归的特点： 子问题须与原始问题为同样的事，且更为简单； 不能无限制地调用本身，须有个出口，化简为非递归状况处理。 了解这些特点可以帮助我们更好的编写递归函数。 执行上下文栈在《JavaScript深入之执行上下文栈》中，我们知道： 当执行一个函数的时候，就会创建一个执行上下文，并且压入执行上下文栈，当函数执行完毕的时候，就会将函数的执行上下文从栈中弹出。 试着对阶乘函数分析执行的过程，我们会发现，JavaScript 会不停的创建执行上下文压入执行上下文栈，对于内存而言，维护这么多的执行上下文也是一笔不小的开销呐！那么，我们该如何优化呢？ 答案就是尾调用。 尾调用尾调用，是指函数内部的最后一个动作是函数调用，该调用的返回值，直接返回给函数。 举个例子： 1234// 尾调用function f(x) &#123; return g(x)&#125; 然而 1234// 非尾调用function f(x) &#123; return g(x) + 1&#125; 并不是尾调用，因为g(x)的返回值还需要跟1进行计算后，f(x)才会返回值。 两者又有什么区别呢？但按时执行上下文栈的变化不一样。 为了模拟执行上下文栈的行为，我们定义执行上下文栈是一个数组： 1ECStack = [] 我们模拟下第一个尾调用函数执行时的执行上下文栈变化： 1234567ECStack.push(&lt;f&gt; functionContext);ECStack.pop();ECStack.push(&lt;g&gt; functionContext);ECStack.pop(); 我们再来模拟一下第二个非尾调用函数执行时的执行上下文栈变化： 1234567ECStack.push(&lt;f&gt; functionContext);ECStack.push(&lt;g&gt; functionContext);ECStack.pop();ECStack.pop(); 也就是说尾调用函数执行，虽然也调用了一个函数，但是因为原来的函数执行完毕，执行上下文会被弹出，执行上下文栈中相当于只多压入了一个执行上下文。然而非尾调用函数，就会创建多个执行上下文压入执行上下文栈。 函数调用自身，称为递归。如果尾调用自身，就称为尾调用。 所以我们只用把阶乘函数改造成一个尾递归形式，就可以避免创建那么多的执行上下文。但是我们该怎么做呢？ 阶乘函数优化我们需要做的就是把所以用得到的内部遍历改成函数的参数，以阶乘函数为例： 我们需要做的就是把所有用到的内部变量改写成函数的参数，以阶乘函数为例： 123456function factorial(n, res) &#123; if (n == 1) return res; return factorial(n - 1, n * res)&#125;console.log(factorial(4, 1)) // 24 然而这个很奇怪呐……我们计算 4 的阶乘，结果函数要传入 4 和 1，我就不能只传入一个 4 吗？ 这个时候就要用到我们在《JavaScript专题之偏函数》中编写的 partial 函数了： 123var newFactorial = partial(factorial, _, 1)newFactorial(4) // 24]]></content>
  </entry>
  <entry>
    <title><![CDATA[JavaScript专题之函数记忆]]></title>
    <url>%2F2019%2F09%2F26%2FJavaScript%E4%B8%93%E9%A2%98%E4%B9%8B%E5%87%BD%E6%95%B0%E8%AE%B0%E5%BF%86%2F</url>
    <content type="text"><![CDATA[函数记忆是指将上次的计算结果缓存起来，当下次调用时，如果遇到相同的参数，就直接返回缓存中的数据。 举个例子： 123456789function add(a, b) &#123; return a + b&#125;// 假设memoize可以实现函数记忆var memoizedAdd = memoize(add)memoizedAdd(1, 2) // 3memoizedAdd(1, 2) // 相同的参数，第二次调用时，从缓存中取出数据，而非重新计算一次 ## 原理 实现这样一个memoize函数很简单，原理只要把参数和对应的结果数据存在一个对象中，调用时，判断参数对应的数据是否存在，存在就返回对应的结果数据。 我们来写第一版： 123456789101112// version onefunction memoize(f) &#123; var cache = &#123;&#125; return function() &#123; var key = arguments.length + Array.prototype.join.call(arguments, ',') if (key in cache) &#123; return cache[key] &#125; else &#123; return cache[key] = f.apply(this, arguments) &#125; &#125;&#125; 我们来测试一下： 1234567891011121314151617var add = function(a, b, c) &#123; return a + b + c&#125;var memoizedAdd = memoize(add)console.time('use memoize')for(var i = 0; i &lt; 100000; i++) &#123; memoizedAdd(1, 2, 3)&#125;console.timeEnd('use memoize')console.time('not use memoize')for(var i = 0; i &lt; 100000; i++) &#123; add(1, 2, 3)&#125;console.timeEnd('not use memoize') 在 Chrome 中，使用 memoize 大约耗时 60ms，如果我们不使用函数记忆，大约耗时 1.3 ms 左右。 注意什么，我们使用了看似高大上的函数记忆，结果却更加耗时，这个例子近乎有 60 倍呢！ 所以，函数记忆也并不是万能的，你看这个简单的场景，其实并不适合用函数记忆。 需要注意的是，函数记忆只是一种编程技巧，本质上是牺牲算法的空间复杂度以换取更优的时间复杂度，在客户端 JavaScript 中代码的执行时间复杂度往往成为瓶颈，因此在大多数场景下，这种牺牲空间换取时间的做法以提升程序执行效率的做法是非常可取的。 第二版因为第一版使用了 join 方法，我们很容易想到当参数是对象的时候，就会自动调用 toString 方法转换成 [Object object]，再拼接字符串作为 key 值。我们写个 demo 验证一下这个问题： 12345678var propValue = function(obj)&#123; return obj.value&#125;var memoizedAdd = memoize(propValue)console.log(memoizedAdd(&#123;value: 1&#125;)) // 1console.log(memoizedAdd(&#123;value: 2&#125;)) // 1 两者都返回了 1，显然是有问题的，所以我们看看 underscore 的 memoize 函数是如何实现的： 12345678910111213// version twovar memoize = function(func, hasher) &#123; var memoize = fnction(key) &#123; var cache = memoize.cache var address = '' + (hasher ? hasher.apply(this, arguments) : key) if (!cache[address]) &#123; cache[address] = func.apply(this, arguments) &#125; return cache[address] &#125; memoize.cache = &#123;&#125; return memoize&#125; 从这个实现可以看出，underscore默认使用function的第一个参数作为key，所以如果直接使用 12345678var add = function(a, b, c) &#123; return a + b + c&#125;var memoizedAdd = memoize(add)memoizedAdd(1, 2, 3) // 6memoizedAdd(1, 2, 4) // 6 肯定是有问题的，如果要支持多参数，我们就需要传入 hasher 函数，自定义存储的 key 值。所以我们考虑使用 JSON.stringify： 1234567var memoizedAdd = memoize(add, function() &#123; var args = Array.prototype.slice.call(arguments) return JSON.stringify(args)&#125;)console.log(memoizedAdd(1, 2, 3)) // 6console.log(memoizedAdd(1, 2, 4)) // 7 如果使用 JSON.stringify，参数是对象的问题也可以得到解决，因为存储的是对象序列化后的字符串。 适用场景我们以斐波那契数列为例： 12345678910var count = 0;var fibonacci = function(n)&#123; count++; return n &lt; 2? n : fibonacci(n-1) + fibonacci(n-2);&#125;;for (var i = 0; i &lt;= 10; i++)&#123; fibonacci(i)&#125;console.log(count) // 453 我们会发现最后的 count 数为 453，也就是说 fibonacci 函数被调用了 453 次！也许你会想，我只是循环到了 10，为什么就被调用了这么多次，所以我们来具体分析下： 123456789101112131415161718192021当执行 fib(0) 时，调用 1 次当执行 fib(1) 时，调用 1 次当执行 fib(2) 时，相当于 fib(1) + fib(0) 加上 fib(2) 本身这一次，共 1 + 1 + 1 = 3 次当执行 fib(3) 时，相当于 fib(2) + fib(1) 加上 fib(3) 本身这一次，共 3 + 1 + 1 = 5 次当执行 fib(4) 时，相当于 fib(3) + fib(2) 加上 fib(4) 本身这一次，共 5 + 3 + 1 = 9 次当执行 fib(5) 时，相当于 fib(4) + fib(3) 加上 fib(5) 本身这一次，共 9 + 5 + 1 = 15 次当执行 fib(6) 时，相当于 fib(5) + fib(4) 加上 fib(6) 本身这一次，共 15 + 9 + 1 = 25 次当执行 fib(7) 时，相当于 fib(6) + fib(5) 加上 fib(7) 本身这一次，共 25 + 15 + 1 = 41 次当执行 fib(8) 时，相当于 fib(7) + fib(6) 加上 fib(8) 本身这一次，共 41 + 25 + 1 = 67 次当执行 fib(9) 时，相当于 fib(8) + fib(7) 加上 fib(9) 本身这一次，共 67 + 41 + 1 = 109 次当执行 fib(10) 时，相当于 fib(9) + fib(8) 加上 fib(10) 本身这一次，共 109 + 67 + 1 = 177 次 所以执行的总次数为：177 + 109 + 67 + 41 + 25 + 15 + 9 + 5 + 3 + 1 + 1 = 453 次！ 如果我们使用函数记忆呢？ 12345678910111213var count = 0;var fibonacci = function(n) &#123; count++; return n &lt; 2 ? n : fibonacci(n - 1) + fibonacci(n - 2);&#125;;fibonacci = memoize(fibonacci)for (var i = 0; i &lt;= 10; i++) &#123; fibonacci(i)&#125;console.log(count) // 12 我们会发现最后的总次数为 12 次，因为使用了函数记忆，调用次数从 453 次降低为了 12 次! 兴奋的同时不要忘记思考：为什么会是 12 次呢？ 从 0 到 10 的结果各储存一遍，应该是 11 次呐？咦，那多出来的一次是从哪里来的？ 所以我们还需要认真看下我们的写法，在我们的写法中，其实我们用生成的 fibonacci 函数覆盖了原本了 fibonacci 函数，当我们执行 fibonacci(0) 时，执行一次函数，cache 为 {0: 0}，但是当我们执行 fibonacci(2) 的时候，执行 fibonacci(1) + fibonacci(0)，因为 fibonacci(0) 的值为 0，!cache[address] 的结果为 true，又会执行一次 fibonacci 函数。原来，多出来的那一次是在这里！ 多说一句也许你会觉得在日常开发中又用不到 fibonacci，这个例子感觉实用价值不高呐，其实，这个例子是用来表明一种使用的场景，也就是如果需要大量重复的计算，或者大量计算又依赖于之前的结果，便可以考虑使用函数记忆。而这种场景，当你遇到的时候，你就会知道的。]]></content>
  </entry>
  <entry>
    <title><![CDATA[JavaScript专题之惰性函数]]></title>
    <url>%2F2019%2F09%2F26%2FJavaScript%E4%B8%93%E9%A2%98%E4%B9%8B%E6%83%B0%E6%80%A7%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[我们现在需要写一个foo函数，这个函数返回首次调用时的Data对象，注意是首次。 解决1：普通方法 123456var t function foo() &#123; if (t) return t t = new Date() return t&#125; 问题有两个：1. 污染了全局变量 2. 每次调用foo的时候都需要进行一次判断。 解决二：闭包 我们很容易想到利用闭包避免污染全局变量 12345678var foo = (function() &#123; var t return function() &#123; if (t) return t t = new Date() return t &#125;&#125;)() 然而我们还是没有解决调用时都必须进行一次判断的问题。 解决三：函数对象 函数也是一种对象，利用这个特性，我们也可以解决这个问题 12345function foo() &#123; if (foo.t) return foo.t foo.t = new Date() return foo.t&#125; 依旧没有解决调用时都必须进行一次判断的问题。 解决四： 惰性函数 不错，惰性函数就是解决每次都要判断的这个问题，解决原理很简单，重写函数。 1234567var foo = function() &#123; var t = new Date() foo = function() &#123; return t &#125; return foo()&#125; 更多应用DOM事件添加中，为了兼容现代浏览器和IE浏览器，我们需要对浏览器环境进行一次判断： 12345678// 简化写法function addEvent(type, el, fn) &#123; if (window.addEventListener) &#123; el.addEventListener(type, fn, false) &#125; else if (window.attachEvent) &#123; el.attachEvent('on' + type, fn) &#125;&#125; 问题在于我们每当使用一次addEvent时都会进行一次判断。 利用惰性函数，我们可以这样做： 1234567891011function addEvent(type, el, fn) &#123; if (window.addEventListener) &#123; addEvent = function(type, el, fn) &#123; el.addEventListener(type, fn, false) &#125; &#125; else if(window.attachEvent) &#123; addEvent = function(type, el, fn) &#123; el.attachEvent('on' + type, fn) &#125; &#125;&#125; 当然我们也可以使用闭包的形式： 1234567891011var addEvent = (function() &#123; if (window.addEventListener) &#123; return function(type, el, fn) &#123; el.addEventListener(type, fn, false) &#125; &#125; else if (window.attachEvent) &#123; return function(type, el, fn) &#123; el.attachEvent('on' + type, fn) &#125; &#125;&#125;) 当我们每次都需要进行条件判断，其实只需要判断一次，接下来的使用方式都不会发生改变的时候，想想是否可以考虑使用惰性函数。]]></content>
  </entry>
  <entry>
    <title><![CDATA[JavaScript专题之偏函数]]></title>
    <url>%2F2019%2F09%2F26%2FJavaScript%E4%B8%93%E9%A2%98%E4%B9%8B%E5%81%8F%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[维基百科中对偏函数 (Partial application) 的定义为： In computer science, partial application (or partial function application) refers to the process of fixing a number of arguments to a function, producing another function of smaller arity. 翻译成中文： 在计算机科学中，局部应用是指固定一个函数的一些参数，然后产生另一个更小元的函数。 什么是元？元是指函数参数的个数，比如一个带有两个参数的函数被称为二元函数。 举个简单的例子： 12345678910function add(a, b) &#123; return a + b&#125;// 执行add函数，一次传入两个参数即可add(1, 2) // 3// 假设有一个partial函数可以做到局部应用var addOne = partial(add, 1)addOne(2) // 3 个人觉得翻译成“局部应用”或许更贴切些，以下全部使用“局部应用”。 柯里化与局部应用如果看过上一篇文章《JavaScript专题之柯里化》，实际上你会发现这个例子和柯里化太像了，所以两者到底是有什么区别呢？ 其实也很明显： 柯里化是将一个多参数函数转换成多个单参数函数，也就是将一个 n 元函数转换成 n 个一元函数。 局部应用则是固定一个函数的一个或者多个参数，也就是将一个 n 元函数转换成一个 n - x 元函数。 如果说两者有什么关系的话，引用 functional-programming-jargon 中的描述就是： Curried functions are automatically partially applied. partial我们今天的目的时模仿underscore写一个partial函数，比起curry，这个显然简单很多。 也许你在想我们可以直接使用bind呐，举个例子： 1234567function add(a ,b) &#123; return a + b&#125;var addOne = add.bind(null, 1)addOne(2) // 3 然而使用bind我们还是改变了this指向，我们要写一个不改变this指向的方法。 ## 第一版 根据之前的表述，我们可以尝试写出第一版 12345678// version onefunction partial(fn) &#123; var args = [].slice.call(arguments, 1) return function() &#123; var newArgs = args.concat([].slice.call(arguments)) return fn.apply(this, newArgs) &#125;&#125; 我们来写个demo验证下this的指向： 123456789101112131415function add(a, b) &#123; return a + b + this.value&#125;// var addOne = add.bind(null, 1)var addOne = partial(add, 1)var value = 1var obj = &#123; value: 2, addOne: addOne&#125;obj.addOne(2); // ???// 使用 bind 时，结果为 4// 使用 partial 时，结果为 5 第二版然而正如curry函数可以使用占位符一样，我们希望partial函数也可以实现这个功能，我们再来写第二版： 1234567891011121314// version twovar _ = &#123;&#125;function partial(fn) &#123; var args = [].slice.call(arguments, 1) return function() &#123; var position = 0, len = args.length for (var i = 0, i &lt; len; i++) &#123; args[i] = args[i] === _ ? arguments[position++] : args[i] &#125; while (position &lt; arguments.length) args.push(arguments[position++]) return fn.apply(this, args) &#125;&#125; 我们验证下： 123var subtract = function(a, b) &#123; return b - a; &#125;;subFrom20 = partial(subtract, _, 20);subFrom20(5); 写在最后值得注意的是：underscore 和 lodash 都提供了 partial 函数，但只有 lodash 提供了 curry 函数。]]></content>
  </entry>
  <entry>
    <title><![CDATA[JavaScript专题之函数柯里化]]></title>
    <url>%2F2019%2F09%2F26%2FJavaScript%E4%B8%93%E9%A2%98%E4%B9%8B%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96%2F</url>
    <content type="text"><![CDATA[维基百科中对柯里化 (Currying) 的定义为： In mathematics and computer science, currying is the technique of translating the evaluation of a function that takes multiple arguments (or a tuple of arguments) into evaluating a sequence of functions, each with a single argument. 翻译成中文： 在数学和计算机科学中，柯里化是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。 举个例子： 12345678910function add(a, b) &#123; return a + b&#125;// 执行add函数，一次传入两个参数即可add(1, 2)// 假设有一个curry函数可以做到柯里化var addCurry = curry(add)addCurry(1)(2) // 3 用途我们会讲到如何写这个curry函数，并且会将这个curry函数写的很强大，但是在编写之前，我们需要知道柯里化到底有什么用？ 举个例子： 123456789101112131415161718192021function ajax(type, url, data) &#123; var xhr = new XMLHttpRequest xhr.open(type, url, true) xhr.send(data)&#125;// 虽然ajax这个函数非常通用，但在重复调用的时候参数冗余ajax('POST', 'www.test.com', 'name=kevin')ajax('POST', 'www.test2.com', 'name=kevin')ajax('POST', 'www.test3.com', 'name=kevin')// 利用curryvar ajaxCurry = curry(ajax)// 以POST类型请求数据var post = ajaxCurry('POST')post('www.test.com', 'name=kevin')// 以POST类型请求来自于www.test.com的数据var postFromTest = post('www.text.com')postFromTest('name=kevin') 想想jQuery虽然有$.ajax这样通用的方法，但是也有$.get和$.post的语法糖。（当然jQuery底层是否这样做） curry的这种用途可以理解为：参数复用。本质上是降低通用性，提高适用性。 可是即便如此，是不是依然感觉没什么用呢？ 如果我们仅仅是把参数一个个传进去，意义可能不大，但是如果哦我们是把柯里化后的函数传给其他函数比如map呢？ 举个例子： 比如我们有这样一段数据 1var person = [&#123; name: 'kevin' &#125;, &#123; name: 'daisy' &#125;] 如果我们要获取所有的name值，我们可以这样做： 123var name = person.map(function(item) &#123; return item.name&#125;) 不过如果我们有了curry函数： 12345var prop = curry(function(key, obj) &#123; return obj[key]&#125;)var name = person.map(prop('name')) 我们为了获取name属性还有再编写一个prop函数，是不是又麻烦了些？ 但是要注意，prop函数编写一次，以后可以多次使用，实际上代码从原来的三行精简成一行，而且你看代码是不是更加易懂了？ person.map(prop(&#39;name&#39;)) 就好像直白的告诉你：person 对象遍历(map)获取(prop) name 属性。 是不是感觉有点意思了呢？ 第一版未来我们会接触到更多有关柯里化的应用，不过那是未来的事情了，现在我们该编写这个 curry 函数了。 一个经常会看到的 curry 函数的实现为： 12345678// version onevar curry = function(fu) &#123; var args = [].slice.call(arguments, 1) return function() &#123; var newArys = args.concat([].slice.call(arguments)) return fn.apply(this, newArgs) &#125;&#125; 我们可以这样使用： 1234567891011function add(a, b) &#123; return a + b&#125;var addCurry = curry(add, 1, 2)addCurry() // 3// 或者addCurry(2) // 3// 或者var addCurry = curry(add)addCurry(1, 2) // 3 已经有柯里化的感觉了，但是还没有 达到要求，不过我们可以把这个函数用作辅助函数，帮助我们写真正的curry函数。 第二版1234567891011121314151617181920// version twofunction sub_curry(fn) &#123; var args = [].slice.call(arguments, 1) return function() &#123; return fn.apply(this, args.concat([].slice.call(arguments))) &#125;&#125;function curry(fn, length) &#123; length = length || fn.length var slice = Array.prototype.slice return function() &#123; if (arguments.length &lt; length) &#123; var combined = [fn].concat(slice.call(arguments)) return curry(sub_curry.apply(this. combined), length - arguments.length) &#125; else &#123; return fn.apply(this, arguments) &#125; &#125;&#125; 我们验证下这个函数： 12345678var fn = curry(function(a, b, c) &#123; return [a, b, c];&#125;);fn(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]fn(&quot;a&quot;, &quot;b&quot;)(&quot;c&quot;) // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]fn(&quot;a&quot;)(&quot;b&quot;)(&quot;c&quot;) // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]fn(&quot;a&quot;)(&quot;b&quot;, &quot;c&quot;) // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;] 效果已经达到我们的预期，然而这个curry函数的实现好难理解呐 为了让大家更好的理解这个curry函数，我给大家写个极简版的代码： 1234567891011121314151617181920212223function sub_curry(fn) &#123; return function() &#123; return fn &#125;&#125;function curry(fn, length) &#123; length = length || 4 return function() &#123; if (length &gt; 1) &#123; return curry(sub_curry(fn), --length) &#125; else &#123; return fn() &#125; &#125;&#125;var fn0 = function() &#123; console.log(1)&#125;var fn1 = curry(fun)fn1()()() // 1 大家先从理解这个curry函数开始。 当执行fn1()时，函数返回： 12345curry(sub_curry(fn0))// 相当于curry(function() &#123; return fn0()&#125;) 当执行 fn1()() 时，函数返回： 12345678910111213curry(sub_curry(function()&#123; return fn0()&#125;))// 相当于curry(function()&#123; return (function()&#123; return fn0() &#125;)()&#125;)// 相当于curry(function()&#123; return fn0()&#125;) 当执行 fn1()()() 时，函数返回： 1234// 跟 fn1()() 的分析过程一样curry(function()&#123; return fn0()&#125;) 当执行 fn1()()()() 时，因为此时 length &lt; 1为 false，所以执行 fn()： 12345678fn()// 相当于(function()&#123; return fn0()&#125;)()// 相当于fn0()// 执行 fn0 函数，打印 1 再回到真正的 curry 函数，我们以下面的例子为例： 1234567var fn0 = function(a, b, c, d) &#123; return [a, b, c, d];&#125;var fn1 = curry(fn0);fn1("a", "b")("c")("d") 当执行 fn1(“a”, “b”) 时： 12345678910fn1("a", "b")// 相当于curry(fn0)("a", "b")// 相当于curry(sub_curry(fn0, "a", "b"))// 相当于// 注意 ... 只是一个示意，表示该函数执行时传入的参数会作为 fn0 后面的参数传入curry(function(...)&#123; return fn0("a", "b", ...)&#125;) 当执行 fn1(“a”, “b”)(“c”) 时，函数返回： 1234567891011curry(sub_curry(function(...)&#123; return fn0("a", "b", ...)&#125;), "c")// 相当于curry(function(...)&#123; return (function(...) &#123;return fn0("a", "b", ...)&#125;)("c")&#125;)// 相当于curry(function(...)&#123; return fn0("a", "b", "c", ...)&#125;) 当执行 fn1(“a”, “b”)(“c”)(“d”) 时，此时 arguments.length &lt; length 为 false ，执行 fn(arguments)，相当于： 12345(function(...)&#123; return fn0("a", "b", "c", ...)&#125;)("d")// 相当于fn0("a", "b", "c", "d") 函数执行结束。 所以，其实整段代码有很好理解： sub_curry的作用就是用函数包裹原函数，然后给原函数传入之前的参数，当执行fn0()()的时候，执行包裹函数，返回原函数，然后再调用sub_curry再包裹原函数，然而将新的参数混合旧的参数再传入原函数，知道函数参数的数目达到要求。 如果要明白 curry 函数的运行原理，大家还是要动手写一遍，尝试着分析执行步骤。 更易懂的实现当然了，如果你觉得还是无法理解，你可以选择下面这种实现方式，可以实现同样的效果： 12345678910111213141516171819202122232425function curry(fn, args) &#123; var length = fn.length args = args || [] return function() &#123; var _args = args.slice(0), arg, i for (i = 0; i &lt; arguments.length; i++) &#123; arg = arguments[i] _args.psuh(arg) &#125; if (_args.length &lt; length) &#123; return curry.call(this, fn, _args) &#125; else &#123; return fn.apply(this, _args) &#125; &#125;&#125;var fn = curry(function(a, b, c) &#123; console.log([a, b, c]);&#125;);fn("a", "b", "c") // ["a", "b", "c"]fn("a", "b")("c") // ["a", "b", "c"]fn("a")("b")("c") // ["a", "b", "c"]fn("a")("b", "c") // ["a", "b", "c"] 或许大家觉得这种方式更好理解，又能实现一样的效果，为什么不直接就讲这种呢？ 因为想给大家介绍各种实现的方法嘛，不能因为难以理解就不给大家介绍呐~ 第三版curry 函数写到这里其实已经很完善了，但是注意这个函数的传参顺序必须是从左到右，根据形参的顺序依次传入，如果我不想根据这个顺序传呢？ 我们可以创建一个占位符，比如这样： 12345var fn = curry(function(a, b, c) &#123; console.log([a, b, c]);&#125;);fn("a", _, "c")("b") // ["a", "b", "c"] 我们直接看第三版的代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970// version threefunction curry(fn, args, holes) &#123; length = fn.length; args = args || []; holes = holes || []; return function() &#123; var _args = args.slice(0), _holes = holes.slice(0), argsLen = args.length, holesLen = holes.length, arg, i, index = 0; for (i = 0; i &lt; arguments.length; i++) &#123; arg = arguments[i]; // 处理类似 fn(1, _, _, 4)(_, 3) 这种情况，index 需要指向 holes 正确的下标 if (arg === _ &amp;&amp; holesLen) &#123; index++ if (index &gt; holesLen) &#123; _args.push(arg); _holes.push(argsLen - 1 + index - holesLen) &#125; &#125; // 处理类似 fn(1)(_) 这种情况 else if (arg === _) &#123; _args.push(arg); _holes.push(argsLen + i); &#125; // 处理类似 fn(_, 2)(1) 这种情况 else if (holesLen) &#123; // fn(_, 2)(_, 3) if (index &gt;= holesLen) &#123; _args.push(arg); &#125; // fn(_, 2)(1) 用参数 1 替换占位符 else &#123; _args.splice(_holes[index], 1, arg); _holes.splice(index, 1) &#125; &#125; else &#123; _args.push(arg); &#125; &#125; if (_holes.length || _args.length &lt; length) &#123; return curry.call(this, fn, _args, _holes); &#125; else &#123; return fn.apply(this, _args); &#125; &#125;&#125;var _ = &#123;&#125;;var fn = curry(function(a, b, c, d, e) &#123; console.log([a, b, c, d, e]);&#125;);// 验证 输出全部都是 [1, 2, 3, 4, 5]fn(1, 2, 3, 4, 5);fn(_, 2, 3, 4, 5)(1);fn(1, _, 3, 4, 5)(2);fn(1, _, 3)(_, 4)(2)(5);fn(1, _, _, 4)(_, 3)(2)(5);fn(_, 2)(_, _, 4)(1)(3)(5) 至此，我们已经实现了一个强大的 curry 函数，可是这个 curry 函数符合柯里化的定义吗？柯里化可是将一个多参数的函数转换成多个单参数的函数，但是现在我们不仅可以传入一个参数，还可以一次传入两个参数，甚至更多参数……这看起来更像一个柯里化 (curry) 和偏函数 (partial application) 的综合应用，可是什么又是偏函数呢？下篇文章会讲到。]]></content>
  </entry>
  <entry>
    <title><![CDATA[JavaScript专题之数组扁平化]]></title>
    <url>%2F2019%2F09%2F26%2FJavaScript%E4%B8%93%E9%A2%98%E4%B9%8B%E6%95%B0%E7%BB%84%E6%89%81%E5%B9%B3%E5%8C%96%2F</url>
    <content type="text"><![CDATA[扁平化数组的扁平化，就是将一个嵌套多层的数组array（嵌套可以是任何层数）转化为只有一层的数组。 举个例子，假如有个名为flatten的函数可以做到数组扁平化，效果就会如下： 12var arr = [1, [2, [3, 4]]]console.log(flatten(arr)) // [1, 2, 3, 4] 知道了效果是什么样的了，我们可以去尝试写这个flatten函数了。 递归我们最一开始能想到的莫过于循环数组元素，如果还是一个数组，就递归调用该方法： 12345678910111213141516// 方法 1var arr = [1, [2, [3, 4]]]function flatten(arr) &#123; var result = [] for (var i = 0, len= arr.length; i &lt; len: i++) &#123; if (Array.isArray(arr[i])) &#123; result = result.concat(flatten(arr[i])) &#125; else &#123; result.push(arr[i]) &#125; &#125; return result&#125;console.log(flatten(arr)) toString如果数组的元素都是数字，那么我们可以考虑使用toStirng方法，因为： 1[1, [2, [3, 4]]].toString() // '1, 2, 3, 4' 调用toString方法，返回一个逗号分隔的扁平的字符串，这时候我们再split，软后转成数字不就实现扁平化了吗？ 12345678910// 方法 2var arr = [1, [2, [3, 4]]]function flatten(arr) &#123; return arr.toString().split(',').map(function(item) &#123; return +item &#125;)&#125;console.log(flatten(arr)) 然而这种方法使用的场景却非常有限，如果数组是[1, ‘1’, 2, ‘2’]的话，这种方法就会产生错误的结果。 reduce既然是对数组进行处理，最终返回一个值，我们就可以考虑使用reduce来简化代码： 12345678910// 方法 3var arr = [1, [2, [3, 4]]]function flatten(arr) &#123; return arr.reduce(function(perv, next) &#123; return perv.concat(Array.isArray(next) ? flatten(next) : next) &#125;, [])&#125;console.log(flatten(arr)) ES6增加了扩展运算符，用于取出参数的所有可遍历属性，拷贝在当前对象之中： 12var arr = [1, [2, [3, 4]]]console.log([].concata(...arr)) // [1, 2, [3, 4] 我们用这种方法只可以扁平一层，但是顺着这个方法一直思考，我们可以写成这样的方法： 12345678910// 方法 4var arr = [1, [2, [3, 4]]]function flatten(arr) &#123; while (arr.some(item =&gt; Array.isArray(item))) &#123; arr = [].concat(...arr) &#125;&#125;console.log(flatten(arr))]]></content>
  </entry>
  <entry>
    <title><![CDATA[JavaScript专题之深浅拷贝]]></title>
    <url>%2F2019%2F09%2F26%2FJavaScript%E4%B8%93%E9%A2%98%E4%B9%8B%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D%2F</url>
    <content type="text"><![CDATA[## 数组的浅拷贝 如果是数组，我们可以利用数组的一些方法比如：slice、concat返回一个新数组的特性来实现拷贝。 1234567var arr = ['old', 1, true, null, undefined]var new _arr = arr.concat(arr)new_arrr[0] = 'new'console.log(arr) // ['old', 1, true, null, undefiend]console.log(new_arr) // ['new', 1, true, null, undefiend] 用slice可以这样做： 1var new_arr = arr.slice() 但是如果数组嵌套了对象或者数组的话，比如： 12345678var arr = [&#123;old: 'old'&#125;, ['old']]var new_arr = arr.concat()arr[0].old = 'new'arr[1][0] = 'new'console.log(arr) // [&#123;old: 'new'&#125;, ['new']]console.log(new_arr) // [&#123;old: 'new'&#125;, ['new']] 我们会发现，无论是新数组还是旧数组都发生了变化，也就是说使用concat方法，克隆的并不彻底。 如果数组元素是基本类型，就会拷贝一份，互不影响，而如果是对象或者数组，就会只拷贝对象和数组引用，这样我们无论在新旧数组进行了修改，两者都会发生变化。 我们把这种复制引用的拷贝方法称之为浅拷贝，与之对应的就是深拷贝，深拷贝就是指完全的拷贝一个对象，即使嵌套了对象，两者也互相分离，修改一个对象的属性，也不会影响另一个。 所以我们可以看出使用concat和slice是一种浅拷贝。 数组的深拷贝那如何深拷贝一个数组呢？这里介绍个技巧，不仅适用于数组还适用于对象！那就是： 12345var arr = ['old', 1, true, ['old1', 'old2'], &#123; old: 1 &#125;]var new_arr = JSON.parse(JSON.stringify(arr))console.log(new_arr) 是一个简单粗暴的好方法，就是有一个问题，不能拷贝函数，我们做个实验： 1234567891011var arr = [function() &#123; console.log(a)&#125;, &#123; b: function() &#123; console.log(b) &#125;&#125;]var new_arr = JSON.parse(JSON.stringify(arr))console.log(new_arr) 我们会发现new_arr变成了： 浅拷贝的实现以上三个方法concat、slice、JSON.stringify都算是技巧类，可以根据实际项目情况选择使用，接下来我们思考下如何实现一个对象或者数组的浅拷贝。 想一想，好像很简单，遍历对象，然后把属性和属性值放在一个新的对象不就好了。 12345678910111213var shallowCopy = function(obj) &#123; // 只拷贝对象 if (typeof obj !== 'objcet') return // 根据obj的类型判断是新建一个数组还是对象 var newObj = obj instanceof Array ? [] : &#123;&#125; //遍历obj，并且判断是obj的属性才拷贝 for (var key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; newObj[key] = obj[key] &#125; &#125; return newObj&#125; 深拷贝的实现那如何实现一个深拷贝呢？说起来也好简单，我们在拷贝的时候判断一下属性值的类型，如果是对象，我们递归调用深拷贝函数不就好了. 12345678910var deepCopy = function(obj) &#123; if (typeof obj !== 'object') return var newObj = obj instanceof Array ? [] : &#123;&#125; for (var key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; newObj[key] = typeof obj[key] === 'object' ? deepCopy(obj[key]) : obj[key] &#125; &#125; return newObj&#125; 性能问题尽管使用深拷贝会完全的克隆一个新对象，不会产生副作用，但是深拷贝因为使用递归，性能会不如浅拷贝，在开发中，还是要根据实际情况进行选择。]]></content>
  </entry>
  <entry>
    <title><![CDATA[JavaScript深入之继承的多种方式及其优缺点]]></title>
    <url>%2F2019%2F09%2F24%2FJavaScript%E6%B7%B1%E5%85%A5%E4%B9%8B%E7%BB%A7%E6%89%BF%E7%9A%84%E5%A4%9A%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%8F%8A%E5%85%B6%E4%BC%98%E7%BC%BA%E7%82%B9%2F</url>
    <content type="text"><![CDATA[本文讲解JavaScript各种继承方式和优缺点. 原型链继承 1234567891011121314151617function Parent() &#123; this.name = 'kevin'&#125;Parent.prototype.getName = function() &#123; console.log(this.name)&#125;function Child() &#123; &#125;Child.prototype = new Parent()var child1 = new Child()console.log(child1.getName()) // kevin 问题： 引用类型的属性被所有实例共享，举个例子 123456789101112131415161718function Parent() &#123; this.names = ['kevin', 'daisy']&#125;function Child() &#123; &#125;Child.prototype = new Parent()var child1 = new Child()child1.names.push('yayu')console.log(child1.names) // ["kevin", "daisy", "yayu"]var child2 = new Child()console.log(child2.names) //["kevin", "daisy", "yayu"] 创建Child的实例时，不能向Parent传参 借用构造函数（经典继承） 12345678910111213141516function Parent() &#123; this.names = ['kevin', 'daisy']&#125;function Child() &#123; Parent.call(this)&#125;var child1 = new Child()child1.names.push('yayu')console.log(child1.names) // ['kevin', 'daisy', 'yayu']var child2 = new Child()console.log(child2.names) // ['kevin', 'daisy'] 优点： 避免了引用类型的属性被所有实例共享 可以在Child中向Parent传参 举个例子： 123456789101112131415function Parent(name) &#123; this.name = name&#125;function Child(name) &#123; Parent.call(this, name)&#125;var child1 = new Child('kevin')console.log(child1.name) // kevinvar child2 = new Child('daisy')console.log(child2.name) // daisy 缺点： 方法都在构造函数中定义，每次创建实例都会创建一遍方法。 组合继承 原型链继承与经典继承双剑合璧 123456789101112131415161718192021222324252627282930function Parent(name) &#123; this.name = name this.colors = ['red', 'blue', 'green']&#125;Parent.prototype.getName = function() &#123; console.log(this.name)&#125;function Child(name, age) &#123; Parent.call(this, name) this.age = age&#125;Child.prototype = new Parent()Child.prototype.constructor = Childvar child1 = new Child('kevin', '18');child1.colors.push('black');console.log(child1.name); // kevinconsole.log(child1.age); // 18console.log(child1.colors); // ["red", "blue", "green", "black"]var child2 = new Child('daisy', '20');console.log(child2.name); // daisyconsole.log(child2.age); // 20console.log(child2.colors); // ["red", "blue", "green"] 优点：融合原型链继承和构造函数继承的优点，是JavaScript中最常用的继承模式 原型式继承 12345function createObject(o) &#123; function F() &#123;&#125; F.prototype = o return new F()&#125; 这就是ES5 Object.create的模拟实现，将传入的对象作为创建的对象的原型。 缺点： 包含引用类似的属性始终会共享相应的值，这点跟原型链继承一样。 123456789101112var person = &#123; name: 'kevin', friends: ['daisy', 'kelly']&#125;var person1 = createObj(person);var person2 = createObj(person);person1.name = 'person1';console.log(person2.name); // kevinperson1.firends.push('taylor'); 寄生式继承 创建一个仅用于封装继承过程的函数，该函数在内部以某种形式来做增强对象，最后返回对象。 1234567function createObj(o) &#123; var clone = Object.create(o) clone.sayName = function() &#123; console.log('hi') &#125; return clone&#125; 缺点： 跟构造函数模式一样，每次创建对象都会创建一遍方法。 寄生组合式继承 为了方便大家阅读，在这里重复一下组合继承的代码 12345678910111213141516171819function Parent(name) &#123; this.name = name this.color = ['red', 'blue', 'green']&#125;Parent.prototype.getName = fuction() &#123; console.log(this.name)&#125;function Child(name, age) &#123; Parent.call(this, name) this.age = age&#125;Child.prototype = new Parent()var child1 = new Child('kevin', '18')console.log(child1) 组合继承最大的缺点式会调用两次父构造函数。 一次是设置子类型实例的原型的时候 1Child.prototype = new Parent() 一次是在创建子类型实例的时候 1var child1 = new Child('kevin', '18') 回想下new的模拟实现，其实在这句中，我们会执行： 1Parent.call(this, name) 在这里我们又会调用一次Parent函数。 所以，在这个例子中，如果我们打印child1对象，我们会发现Child.prototype和child1都有一个属性colors，属性值为[&#39;red&#39;, &#39;blue&#39;, &#39;green&#39;]。 那么我们该如何精益求精，避免这一次重复调用呢？ 如果我们不使用Child.prototype = new Parent(),而是间接的让Child.prototype访问到Parent.prototype呢？看看如何实现： 1234567891011121314151617181920212223function Parent(name) &#123; this.name = name this.colors = ['red', 'blue', 'green']&#125;Parent.prototype.getName = function() &#123; console.log(this.name)&#125;function Child(name, age) &#123; Parent.call(this, name) this.age = age&#125;// 关键的三步var F = function() &#123;&#125;F.prototype = Parent.prototypeChild.prototype = new F()var child1 = new Child('kevin', '18')console.log(child1) 最后我们封装一下这个继承方法： 1234567891011121314function object(o) &#123; function F() &#123;&#125; F.prototype = o return new F()&#125;function prototype(child, parent) &#123; var prototype = object(parent.prototype) prototype.constructor = child child.prototype = prototype&#125;// 当我们使用的时候：prototype(Child, Parent) 引用《JavaScript高级程序设计》中对寄生组合式继承的夸赞就是： 这种方式的高效率体现它只调用了一次 Parent 构造函数，并且因此避免了在 Parent.prototype 上面创建不必要的、多余的属性。与此同时，原型链还能保持不变；因此，还能够正常使用 instanceof 和 isPrototypeOf。开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。]]></content>
  </entry>
  <entry>
    <title><![CDATA[JavaScript深入之创建对象的多种方式及其优缺点]]></title>
    <url>%2F2019%2F09%2F24%2FJavaScript%E6%B7%B1%E5%85%A5%E4%B9%8B%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%9A%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%8F%8A%E5%85%B6%E4%BC%98%E7%BC%BA%E7%82%B9%2F</url>
    <content type="text"><![CDATA[## 写在前面 这篇文章讲解创建对象的各种方式，以及优缺点。 但是注意：这篇文章更像是笔记，因为《JavaScript高级程序设计》写得真是太好了。 工厂模式 1234567891011function createPerson(name) &#123; var o = new Object() o.name = name o.getName = function() &#123; console.log(this.name) &#125; return o&#125;var person1 = createPerson('kevin') 缺点：对象无法识别，因为所有的实例都指向一个原型 构造函数模式 12345678function Person(name) &#123; this.name = name this.getName = function() &#123; console.log(this.name) &#125;&#125;var person1 = new Person('kevin') 优点： 实例可以识别为一个特定的类型 缺点：每次创建实例，每个方法都要被创建一次 1构造函数模式优化 12345678910function Person(name) &#123; this.name = name this.getName = getName&#125;function getName() &#123; console.log(this.name)&#125;var person1 = new Person('kevin') 优点：解决了每个方法都要被重新创建的问题 缺点： 这叫什么封装。。。 原型模式 12345678910function Person(name) &#123; &#125;Person.prototype.name = 'Kevin'Person.prototype.getName = function() &#123; console.log(this.name)&#125;var person1 = new Person() 优点：方法不会重新创建 缺点：1. 所有的属性和方法都共享 2. 不能初始化参数 1原型模式优化 123456789101112function Person(name) &#123; &#125;Person.prototype = &#123; name: 'Kevin', getName: function() &#123; console.log(this.name) &#125;&#125;var person1 = new Person() 优点：封装性好了一点 缺点：重写了原型，丢失了constructor属性 2原型模式优化 12345678910111213function Person(name) &#123;&#125;Person.prototype = &#123; constructor: Person, name: 'kevin', getName: function() &#123; console.log(this.name) &#125;&#125;var person1 = new Person() 优点：实例可以通过constructor属性找到所属构造函数 缺点：原型模式该有的缺点还是有 组合模式 构造函数模式与原型模式双剑合璧。 123456789101112function Person(name) &#123; this.name = name&#125;Person.prototype = &#123; constructor: Person, getName: function()&#123; console.log(this.name) &#125;&#125;var person1 = new Person() 优点：该共享的共享，该私有的私有，使用最广泛的方式。 缺点：有的人就是希望全部都写在一起，即更好的封装性。 2动态原型模式 12345678910function Person(name) &#123; this.name = name if (typeof this.getName != 'function') &#123; Person.prototype.getName = function() &#123; console.log(this.name) &#125; &#125;&#125;var person1 = new Person() 注意，使用动态原型模式时，不能用对象字面量重写原型。 解释下为什么： 1234567891011121314151617181920function Person(name) &#123; this.name = name if (typeof this.getName != 'function') &#123; person.prottotype = &#123; constructor: Person, getName: function() &#123; console.log(this.name) &#125; &#125; &#125;&#125;var person1 = new Person('kevin')var person2 = new Person('daisy')// 报错 并没有方法person1.getName()// 注释上面的代码，这句是可以执行的person2.getName() 为了解释这个问题，假设开始执行var person1 = new Person(&#39;kevin&#39;)。 如果对 new 和 apply 的底层执行过程不是很熟悉，可以阅读底部相关链接中的文章。 我们回顾下 new 的实现步骤： 首先新建一个对象 然后将对象的原型指向 Person.prototype 然后 Person.apply(obj) 返回这个对象 注意这个时候，回顾apply的实现，会执行obj.Person方法，这个时候就会执行if语句里的内容，注意构造函数的prototype属性指向了实例的原型，使用字面量方式直接覆盖Person.prototype，并不会更改实例的原型的值，person1依然是指向了以前的原型，而不是Person.prototype。而之前的原型是没有getName方法的，所有就报错了。 如果你就是想要字面量写代码，可以尝试这种： 123456789101112131415161718function Person(name) &#123; this.name = name if (typeof this.getName != 'function') &#123; Person.prototype = &#123; constructor: Person, getName: function() &#123; console.log(this.name) &#125; &#125; return new Person(name) &#125;&#125;var person1 = new Person('kevin');var person2 = new Person('daisy');person1.getName(); // kevinperson2.getName(); // daisy 1寄生构造函数模式 123456789101112function Person(name) &#123; var o = new Object() o.name = name o.getName = function() &#123; console.log(this.name) &#125; return o&#125;var person1 = new Person('kevin');console.log(person1 instanceof Person) // falseconsole.log(person1 instanceof Object) // true 寄生构造函数模式，我个人认为应该这样读： 寄生-构造函数-模式，也就是说寄生在构造函数的一种方法。 也就是说打着构造函数的幌子挂羊头卖狗肉，你看创建的实例使用 instanceof 都无法指向构造函数！ 这样方法可以在特殊情况下使用。比如我们想创建一个具有额外方法的特殊数组，但是又不想直接修改Array构造函数，我们可以这样写： 12345678910111213141516171819202122function SpecialArray() &#123; var values = new Array() for (var i = 0, len = arguments.length; i &lt; len; i++) &#123; values.push(arguments[i]) &#125; values.toPipedString = function() &#123; return this.join('|') &#125; return values&#125;var colors = new SpecialArray('red', 'blue', 'green');var colors2 = SpecialArray('red2', 'blue2', 'green2');console.log(colors);console.log(colors.toPipedString()); // red|blue|greenconsole.log(colors2);console.log(colors2.toPipedString()); // red2|blue2|green2 你会发现，其实所谓的寄生构造函数模式就是比工厂模式在创建对象的时候，多使用了一个new，实际上两者的结果是一样的。 但是作者可能是希望能像使用普通 Array 一样使用 SpecialArray，虽然把 SpecialArray 当成函数也一样能用，但是这并不是作者的本意，也变得不优雅。 在可以使用其他模式的情况下，不要使用这种模式。 但是值得一提的是，上面例子中的循环： 123for (var i = 0, len = arguments.length; i &lt; len; i++) &#123; values.push(arguments[i]);&#125; 可以替换成： 1values.push.apply(values, arguments); 2 稳妥构造函数模式 1234567891011121314151617function person(name) &#123; var o = new Object() o.sayName = function() &#123; console.log(name) &#125; return o&#125;var person1 = person('kevin')person1.sayName(); // kevinperson1.name = "daisy";person1.sayName(); // kevinconsole.log(person1.name); // daisy 所谓稳妥对象，指的是没有公共属性，而且其方法也不引用 this 的对象。 与寄生构造函数模式有两点不同： 新创建的实例方法不引用 this 不使用 new 操作符调用构造函数 稳妥对象最适合在一些安全的环境中。 稳妥构造函数模式也跟工厂模式一样，无法识别对象所属类型。]]></content>
  </entry>
  <entry>
    <title><![CDATA[JavaScript深入之类数组对象与arguments]]></title>
    <url>%2F2019%2F09%2F24%2FJavaScript%E6%B7%B1%E5%85%A5%E4%B9%8B%E7%B1%BB%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%E4%B8%8Earguments%2F</url>
    <content type="text"><![CDATA[## 类数组对象 所谓类数组对象： 拥有一个length属性和若干索引属性的对象。 举个例子： 12345678var array = ['name', 'age', 'sex']var arrayLike = &#123; 0: 'name', 1: 'age', 2: 'sex', length: 3&#125; 即便如此，为什么叫做类数组对象呢？ 那让我们从读写、获取长度、遍历三个方面看看这两个对象。 读写 12345console.log(array[0]) // nameconsole.log(arrayLike[0]) // namearray[0] = 'new name'arrayLike[0] = 'new name' 长度 12console.log(array.length); // 3console.log(arrayLike.length); // 3 遍历 123456for(var i = 0, len = array.length; i &lt; len; i++) &#123; ……&#125;for(var i = 0, len = arrayLike.length; i &lt; len; i++) &#123; ……&#125; 是不是很像？ 那类数组对象可以使用数组的方法吗？比如： 1arrayLike.push('4'); 然而上述代码会报错: arrayLike.push is not a function 所以终归还是类数组呐…… 调用数组方法如果类数组就是任性的想用数组的方法怎么办呢？ 既然无法直接调用，我们可以用Function.call间接调用： 123456789101112131415var arrayLike = &#123; 0: 'name', 1: 'age', 2: 'sex', length: 3&#125; Array.prototype.join.call(arrayLike, '&amp;') // name&amp;age&amp;sexArray.prototype.slice.call(arrayLike, 0) // ['name', 'age', 'sex']// slice可以做到类数组转数组Array.prototype.map.call(arrayLike, function(item) &#123; return item.toUpperCase()&#125;) // ['NAME', 'AGE', 'SEX'] 类数组转数组在上面的例子中已经提到了一种类数组转数组的方法，再补充三个： 1234567891011121314var arrayLike = &#123; 0: 'name', 1: 'age', 2: 'sex', length: 3&#125;// 1. sliceArray.prootype.slice.call(arrayLike) // ['name', 'age', 'sex']// 2. spliceArray.prootype.splice.call(arrayLike, 0) // ['name', 'age', 'sex']// 3. ES6 Array.fromArray.from(arrayLike) // ['name', 'age', 'sex']// 4. applyArray.prototype.concat.apply([], arrayLike) 那么为什么会讲到类数组对象呢？以及类数组有什么应用吗？ 要说到类数组对象，Arguments 对象就是一个类数组对象。在客户端 JavaScript 中，一些 DOM 方法(document.getElementsByTagName()等)也返回类数组对象。 Arguments对象接下来重点讲讲Arguments对象。 Arguments对象只定义在函数体中，包括了函数的参数和其他属性。在函数体中，arguments指代该函数的Arguments对象。 举个例子： 12345function foo(name, age, sex) &#123; console.log(arguments)&#125;foo('name', 'age', 'sex') 打印结果如下： 我们可以看到除了类数组的索引属性和length属性之外，海域一个callee属性，接下来我们一个一个介绍。 length属性 Arguments对象的length属性，表示实参的长度，举个例子： 123456789function foo(b, c, d) &#123; console.log("实参的长度为：" + arguments.length)&#125;console.log('形参的长度为：' + foo.length)foo(1)// 形参的长度为：3// 实参的长度为：1 callee属性 Arguments对象的callee属性，通过它可以调用函数自身。 讲个闭包经典面试题使用callee的解决方法： 123456789101112131415var data = []for (var i = 0; i &lt; 3; i++) &#123; (data[i] = function() &#123; console.log(arguments.callee.i) &#125;).i = i&#125;data[0]();data[1]();data[2]();// 0// 1// 2 接下来讲讲arguments对象的几个注意要点： argumens和对应参数的绑定123456789101112131415161718192021222324252627function foo(name, age, sex, hobbit) &#123; console.log(name, arguments[0]) // name name // 改变形参 name = 'new name' console.log(name, arguments[0]) // new name new name // 改变arguments arguments[i] = 'new age' console.log(age, arguments[i]) // new age new age // 测试未传入的是否会绑定 console.log(sex) // undefined sex = 'new sex' console.log(sex, arguments[2]) // new sex undefined arguments[3] = 'new hobbit' console.log(hobbit, arguments[3]) // undefined new hobbit &#125;foo('name', 'age') 传入的参数、实参和arguments的值会共享，当没有传入时，实参与arguments值不会共享。 除此之外，以上是在非严格模式下，如果是在严格模式下，实参和 arguments 是不会共享的。 传递参数将参数从一个函数传递到另一个函数 12345678910// 使用apply传foo的参数传递给barfunction foo() &#123; bar.apply(this, arguments)&#125;function bar() &#123; console.log(a, b, c)&#125;foo(1, 2, 3) 强大的ES6使用ES6的…运算符，我们可以轻松转成数组。 1234function func(...arguments) &#123; console.log(arguments) // [1, 2,3]&#125;func(1, 2, 3) 应用arguments的应用其实很多，在下个系列，也就是 JavaScript 专题系列中，我们会在 jQuery 的 extend 实现、函数柯里化、递归等场景看见 arguments 的身影。这篇文章就不具体展开了。 如果要总结这些场景的话，暂时能想到的包括： 参数不定长 函数柯里化 递归调用 函数重载…]]></content>
  </entry>
  <entry>
    <title><![CDATA[JavaScript深入之new的模拟实现]]></title>
    <url>%2F2019%2F09%2F24%2FJavaScript%E6%B7%B1%E5%85%A5%E4%B9%8Bnew%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[new一句话介绍new： new运算符创建一个用户定义的对象类型的实例或具有构建函数的内置对象类型之一。 也许有点难懂，我们在模拟new之前，先看看new实现了哪些功能。 举个例子： 1234567891011121314151617181920// Otaku 御宅族，简称宅function Otaku(name, age) &#123; this.name = name this.age = age this.habit = 'Games'&#125;// 因为缺乏锻炼的缘故，身体强度让人担忧Otaku.prototype.strength = 60Otaku.prototype.sayYourName = function() &#123; console.log('I am ' + this.name)&#125;var person = new Otaku('Kevin', '18')console.log(perosn.name) // Kevinconsole.log(person.habit) // Gamesconsole.log(person.strength) // 60person.sayYourName(); // I am Kevin 从这个例子中，我们可以看到，实例 person 可以： 访问到 Otaku 构造函数里的属性 访问到 Otaku.prototype 中的属性 接下来，我们可以尝试着模拟一下了。 因为 new 是关键字，所以无法像 bind 函数一样直接覆盖，所以我们写一个函数，命名为 objectFactory，来模拟 new 的效果。用的时候是这样的： 12345678function Otaku() &#123; ....&#125;// 使用newvar person = new Otaku(....)// 使用objectFactoryvar person = objectFactory(Otaku, ....) 初步实现分析： 因为new的结果是一个新对象，所以在模拟实现的时候，我们也要建立一个新对象，假设这个对象为obj，因为obj会具有Otaku构造函数里的属性，想想经典继承的例子，我们可以使用Otaku.apply(obj, arguments)来给obj添加新的属性。 在 JavaScript 深入系列第一篇中，我们便讲了原型与原型链，我们知道实例的 __proto__ 属性会指向构造函数的 prototype，也正是因为建立起这样的关系，实例可以访问原型上的属性。 现在，我们尝试写第一版： 123456789// version onefunction objectFactory() &#123; var obj = new Object(), Constructor = [].shift.call(arguments) obj.__proto__ = Constructor.prototype Constructor.apply(obj, arguments) return obj&#125; 复制以下的代码，到浏览器中，我们可以做一下测试： 12345678910111213141516171819202122232425262728function Otaku (name, age) &#123; this.name = name; this.age = age; this.habit = 'Games';&#125;Otaku.prototype.strength = 60;Otaku.prototype.sayYourName = function () &#123; console.log('I am ' + this.name);&#125;function objectFactory() &#123; var obj = new Object(), Constructor = [].shift.call(arguments); obj.__proto__ = Constructor.prototype; Constructor.apply(obj, arguments); return obj;&#125;;var person = objectFactory(Otaku, 'Kevin', '18')console.log(person.name) // Kevinconsole.log(person.habit) // Gamesconsole.log(person.strength) // 60person.sayYourName(); // I am Kevin 返回值效果实现接下来我们再看另一种情况，假如构造函数有返回值，举个例子: 123456789101112131415function Otaku() &#123; this.strength = 60 this.age = age return &#123; name: name, habit: 'Games' &#125;&#125;var person = new Otaku('Kevin', '18')console.log(person.name) // Kevinconsole.log(person.habit) // Gamesconsole.log(person.strength) // undefinedconsole.log(person.age) // undefined 在这个例子中，构造函数返回了一个对象，在实例person中只能访问返回的对象中的属性。 而且还有注意一点，在这里我们是返回了一个对象，假如我们只是返回了一个基本类型的值呢？ 再举个例子： 12345678910111213function Otaku (name, age) &#123; this.strength = 60; this.age = age; return 'handsome boy';&#125;var person = new Otaku('Kevin', '18');console.log(person.name) // undefinedconsole.log(person.habit) // undefinedconsole.log(person.strength) // 60console.log(person.age) // 18 结果完全颠倒过来，这次尽管有返回值，但是相当于没有返回值进行处理。 所以我们还需要判断返回的值是不是一个对象，如果是一个对象，我们就返回这个对象，如果没有，我们该返回什么就返回什么。 再看看第二版的代码，也是最后一版的代码： 12345678// version twofunction objectFactory() &#123; var obj = new Object(), Constructor = [].slice.call(arguments) obj.__proto__ = Constructor.prototype var ret = Constructor.apply(obj, arguments) return typeof ret === 'object' ? ret : obj&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[JavaScript深入之bind的模拟实现]]></title>
    <url>%2F2019%2F09%2F24%2FJavaScript%E6%B7%B1%E5%85%A5%E4%B9%8Bbind%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[## bind 一句话介绍bind： bind()方法会创建一个新函数。当这个新函数被调用，bind()的第一个参数将作为它运行时的this，之后的一系列参数将会在传递的实参前传入作为它的参数。 由此我们可以先得到bind函数的两个特点： 返回一个函数 可以传参数 返回函数的模拟实现从第一个特点开始，我们举个例子： 123456789101112var foo = &#123; value: 1&#125;function bar() &#123; console.log(this.value)&#125;// return a functionvar bindFoo = bar.bind(foo)bindFoo() // 1 关于指定 this 的指向，我们可以使用 call 或者 apply 实现，关于 call 和 apply 的模拟实现，可以查看《JavaScript深入之call和apply的模拟实现》。我们来写第一版的代码： 1234567// version oneFunction.prototype.bind2 = function(context) &#123; var self = this return function() &#123; return self.apply(context) &#125;&#125; 此外，之所以 return self.apply(context)，是考虑到绑定函数可能是有返回值的，依然是这个例子： 1234567891011var foo = &#123; value: 1&#125;;function bar() &#123; return this.value;&#125;var bindFoo = bar.bind(foo);console.log(bindFoo()); // 1 传参的模拟实现接下来看第二点，可以传入参数。这个就有点让人费解了，我在 bind 的时候，是否可以传参呢？我在执行 bind 返回的函数的时候，可不可以传参呢？让我们看个例子： 123456789101112131415var foo = &#123; value: 1&#125;function bar(name, age) &#123; console.log(this.value) console.log(name) console.log(age)&#125;var bindFoo = bar.bind(foo, 'disay')bindFoo('18')// 1// daisy// 18 函数需要传入name和age两个参数，竟然还可以在bind的时候，只传入一个name，在执行返回的函数的时候，再传另一个参数age。 对此，我们可以用arguments进行处理： 123456789101112// version twoFunction.prototype.bind2 = function(context) &#123; var self = this // 获取bind2函数从第二个参数到最后一个参数 var args = Array.prototype.slice.call(arguments, 1) return function() &#123; // 这个时候arguments时指bind返回的函数传入的参数 var bindArgs = Array.prototype.slice.call(arguments) return self.apply(context, args.concat(bindArgs)) &#125;&#125; 构造函数效果的模拟实现完成这两点，最难的部分到了，因为bind还有一个特点，就是： 一个绑定函数也能使用new操作符创建对象：这种行为就像把原函数当成构造器。提供的this值被忽略，同时调用时的参数被提供给模拟函数。 也就是说当bind返回的函数作为构造函数的时候，bind时指定的this值会失效，但传入的参数依然生效，举个例子： 123456789101112131415161718192021222324var value = 2var foo = &#123; value: 1&#125;function bar(name, age) &#123; this.habit = 'shopping' console.log(this.value) console.log(name) console.log(age)&#125;bar.prototype.friend = 'kevin'var bindFoo = bar.bind(foo, 'daisy')var obj = new bindFoo('18')// undefined// daisy// 18console.log(obj.habit)console.log(obj.firend)// shopping// kevin 注意，尽管再全局和foo中都声明了value值，最后依然返回了undefined，说明绑定的this失效了，如果大家了解new的模拟实现，就会知道这个时候的this已经指向了obj。 所以我们可以通过修改返回的函数的原型来实现，让我们写一下： 12345678910111213141516// version threeFUnction.prototype.bind2 = function(context) &#123; var self = this var args = Array.prototype.slice.call(arguments, 1) var fBound = function() &#123; var bindArgs = Array.prototype.slice.call(arguments) // 当作为构造函数时，this指向实例，此时结果为true，将绑定函数的this指向该实例，可以让实例获得来自绑定函数的值 // 以上面的demo为例，如果改成 `this instanceof fBound ? null : context`，实例只是一个空对象，将null改成this，实例会具有habit属性 // 当作为普通函数时，this指向window，此时结果为false，将绑定函数的this指向context return self.apply(this instanceof fBound ? this : context, args.concat(bindArgs)) &#125; // 修改返回函数的prototype为绑定函数的prototype，实例就可以继承绑定函数的原型中的值 fBound.prototype = this.prototype return fBound&#125; 构造函数效果的优化实现但是在这个写法中，我们直接将fBound.prototype = this.prototype，我们直接修改fBound.prototype的时候，也会直接修改绑定函数的prototype。这个时候，我们可以通过一个空函数来进行中转： 12345678910111213141516// version fourFunction.prototype.bind2 = function(context) &#123; var self = this var args = Array.prototype.slice.call(arguments, 1) var fNOP = function() &#123;&#125; var fBound = function() &#123; var bindArgs = Array.prototype.slice.call(arguments) return slef.apply(this.instanceof fNOP ? this : context, args.concat(bindArgs)) &#125; fNOP.prototype = this.prototype fBound.prototype = new fNOP() return fBound&#125; 到此为止，大的问题都已经解决，给自己一个赞！o(￣▽￣)ｄ 三个小问题接下来处理些小问题 apply这段代码与MDN上的稍有不同 在MDN中文版讲bind的模拟实现时，apply这里的代码是： 1self.apply(this instanceof self ? this : context || this, args.concat(bindArgs)) 多了一个关于context是否存在的判断，然而这个是错误的！ 举个例子： 1234567891011var value = 2;var foo = &#123; value: 1, bar: bar.bind(null)&#125;;function bar() &#123; console.log(this.value);&#125;foo.bar() // 2 以上代码正常情况下会打印 2，如果换成了 context || this，这段代码就会打印 1！ 所以这里不应该进行 context 的判断，大家查看 MDN 同样内容的英文版，就不存在这个判断！ (2018年3月27日更新，中文版已经改了) 调用bind的不是函数咋办 不行，我们要报错。 123if (typeof this !== 'function') &#123; throw new Error('Function.prototype.bind - what is trying to be bound is not callable')&#125; 3.我要在线上用 那别忘了做个兼容： 123Function.prototype.bind = Function.prototype.bind || function () &#123; ……&#125;; 当然最好是用 es5-shim 啦。 最终代码12345678910111213141516171819Function.prototype.bind2 = function(context) &#123; if (typeof this !== 'function') &#123; throw new Error('Function.prototype.bind - what is trying to be bound is not callable') &#125; var slef = this var args = Array.prototype.slice.call(arguments, 1) var fNOP = function() &#123;&#125; var fBound = function() &#123; var bindArgs = Array.prototype.slice.call(arguments) return self.apply(this instanceof fNOP ? this : context, args.concat(bindArgs)) &#125; fNOP.prototype = this.prototype fBound.prototype = new fNOP() return fBound&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[JavaScript深入之call和apply的模拟实现]]></title>
    <url>%2F2019%2F09%2F24%2FJavaScript%E6%B7%B1%E5%85%A5%E4%B9%8Bcall%E5%92%8Capply%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[## call 一句话介绍call： call()方法在使用一个指定的this值和若干个指定的参数值的前提下调用某个函数或方法。 举个例子： 123456789var foo = &#123; value: 1&#125;function bar() &#123; console.log(this.value)&#125;bar.call(foo) 注意两点： call改变了this的指向，指向到foo bar函数执行了 模拟实现第一步那我们该如何模拟实现这两个效果呢？ 试想当调用call的时候，把foo对象改造如下： 12345678var foo = &#123; value: 1, bar: function() &#123; console.log(this.value) &#125;&#125;foo.bar() // 1 这个时候this就指向了foo，是不是很简单？ 但是这样却给foo对象本身添加了一个属性，这可不行。 不过也不用担心，我们用delete再删除它不就好了。 所以我们模拟的步骤可以分为： 将函数设为对象的属性 执行该函数 删除该函数 以上面例子为例。就是： 123456// step onefoo.fn = fn// step two foo.fn()// step three delete foo.fn fn时对象的属性名，反转最后也要删除它，所以起成什么都无所谓。 根据这个思路，我们可以尝试去写第一版的call2函数： 123456789101112131415161718// version oneFunction.prototype.call2 = function(context) &#123; // 首先要获取调用call的函数，用this可以获得 context.fn = this context.fn() delete context.fn&#125;// 测试一下var foo = &#123; value: 1&#125;function bar() &#123; console.log(this.value)&#125;bar.call2(foo) // 1 正好可以打印 1 哎！是不是很开心！(～￣▽￣)～ 模拟实现第二步最开始也讲了，call函数还可以给定参数执行函数，举个例子： 1234567891011121314var foo = &#123; value: 1&#125;function bar(name, age) &#123; console.log(name) console.log(age) console.log(this.value)&#125;bar.call(foo, 'kevin', 18)// kevin// 18 // 1 注意：传入的参数不确定，这可咋办？ 我们可以从arguments对象中取值，取到第二个到最后也给参数，然后放在一个数组里。 比如这样： 12345678910111213// 以上个例子为例，此时的arguments为：// arguments = &#123;// 0 : foo,// 1: 'kevin',// 2: 18,// length: 3//&#125;// 因为arguments是类数组对象，所以可以用for循环var args = []for (var i = i, len = arguments.length; i &lt; len; i++) &#123; args.push('arguments[' + i + ']')&#125;// 执行后 args为 ["arguments[1]", "arguments[2]", "arguments[3]"] 不定长的参数问题解决了，我们接着要把这个参数数组放到要执行的函数的参数里面去。 1234// 将数组里的元素作为多个参数放进函数的形参里context.fn(args.join(','))// (O_o)??// 这个方法肯定是不行的啦！！！ 也许有人想到用 ES6 的方法，不过 call 是 ES3 的方法，我们为了模拟实现一个 ES3 的方法，要用到ES6的方法，好像……，嗯，也可以啦。但是我们这次用 eval 方法拼成一个函数，类似于这样： 1eval('context.fn(' + args +')') 这里 args 会自动调用 Array.toString() 这个方法。 所以我们的第二版克服了两个大问题，代码如下： 123456789101112131415161718192021222324// version twoFunction.prototype.call2 = function(context) &#123; context.fn = this for(var i = 1, len = arguments.length; i &lt; len; i++) &#123; args.push('arguments[' + i + ']'); &#125; eval('context.fn(' + args +')'); delete context.fn;&#125;// 测试一下var foo = &#123; value: 1&#125;;function bar(name, age) &#123; console.log(name) console.log(age) console.log(this.value);&#125;bar.call2(foo, 'kevin', 18); // kevin// 18// 1 模拟实现第三步模拟代码已经完成80%，还有两个小点要注意： this参数可以传null，当为null的时候，视为指向window 举个例子： 1234567var value = 1function bar() &#123; console.log(this.value)&#125;bar.call(null) // 1 虽然这个例子本身不使用call， 结果依然一样/ 函数是可以有返回值的 举个例子： 123456789101112131415161718var obj = &#123; value: 1&#125;function bar(name, age) &#123; return &#123; value: this.value, name: name, age: age &#125;&#125;console.log(bar.call(obj, 'kevin', 18));// Object &#123;// value: 1,// name: 'kevin',// age: 18// &#125; 不过都很好解决，让我们直接看第三版也就是最后一版的代码： 12345678910111213141516171819202122232425262728293031323334353637383940// version threeFunction.prototype.call2 = function(context) &#123; var context = context || window context.fn = this var args = [] for (var i = 1, len = arguments.length; i &lt; len; i++) &#123; args.push('arguments[' + i + ']') &#125; var result = eval('context.fn(' + args +')') delete context.fn return result&#125;var value = 2;var obj = &#123; value: 1&#125;function bar(name, age) &#123; console.log(this.value); return &#123; value: this.value, name: name, age: age &#125;&#125;bar.call2(null); // 2console.log(bar.call2(obj, 'kevin', 18));// 1// Object &#123;// value: 1,// name: 'kevin',// age: 18// &#125; 到此，我们完成了 call 的模拟实现，给自己一个赞 ｂ（￣▽￣）ｄ apply的模拟实现apply 的实现跟 call 类似，在这里直接给代码，代码来自于知乎 @郑航的实现： 123456789101112131415161718Function.prototype.apply2 = function(context, arr) &#123; var context = context || window context.fn = this var result if (!arr) &#123; result = context.fun() &#125; else &#123; var args = [] for (var i = 0, len = arr.length; i&lt; len; i++) &#123; args.push('arr[' + i + ']'); &#125; result = eval('context.fn(' + args + ')') &#125; delete context.fn return result&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[JavaScript深入之参数按值传递]]></title>
    <url>%2F2019%2F09%2F24%2FJavaScript%E6%B7%B1%E5%85%A5%E4%B9%8B%E5%8F%82%E6%95%B0%E6%8C%89%E5%80%BC%E4%BC%A0%E9%80%92%2F</url>
    <content type="text"><![CDATA[在《JavaScript高级程序设计》第三版 4.1.3，讲到传递参数： ECMAScript中所有函数的参数都是按值传递的。 什么是按值传递呢？ 也就是说，把函数外部的值复制给函数内部的参数，就和把值从一个变量复制到另一个变量一样。 按值传递举个简单的例子： 12345678var value = 1function foo(v) &#123; v = 2 console.log(v)&#125;foo(value)console.log(value) 很好理解，当传递value到函数foo中，相当于拷贝了一份value，假设拷贝的这份叫_value，函数中修改的都是_value的值，而不会影响原来的value值。 引用传递拷贝虽然很好理解，但是当值时一个复杂的数据结构的时候，拷贝就会产生性能上的问题。 所有还有另一种传递方式叫做按引用传递。 所谓按引用传递，就是传递对象的引用，函数内部对参数的任何改变都会影响该对象的值，因为两者引用的是同一个对象。 举个例子： 12345678910var obj = &#123; value: 1&#125;function foo(o) &#123; o.value = 2 console.log(o.value) // 2&#125;foo(obj)console.log(obj.value) // 2 哎，不对啊，连我们的红宝书都说了 ECMAScript 中所有函数的参数都是按值传递的，这怎么能按”引用传递”成功呢？ 而这究竟是不是引用传递呢？ 第三种传递方式不急，让我们再看个例子： 12345678910var obj =&#123; value: 1&#125;function foo(o) &#123; o = 2 console.log(0) //2&#125;foo(obj)console.log(obj.value) // 1 如果JavaScript采用的是引用传递，外层的值也会被修改呐，这怎么又没被改呢？所有真的不是引用传递吗？ 这就要讲到其实还有第三种传递方式，叫按共享传递。 而共享传递的是指：再传递对象的时候，传递对象的引用的副本。 注意，按引用传递时传递对象的引用，而按共享传递时传递对象的引用的副本。 所有修改o.value, 可以通过引用找到原值，但是直接修改o，并不会修改原值。所有第二个和第三个例子其实都是按共享传递。 最后，你可以这样理解： 参数如果是基本类型是按值传递，如果是引用类型按共享传递。 但是因为拷贝副本也是一种值的拷贝，所以在高程中也直接认为是按值传递了。]]></content>
  </entry>
  <entry>
    <title><![CDATA[JavaScript深入之闭包]]></title>
    <url>%2F2019%2F09%2F24%2FJavaScript%E6%B7%B1%E5%85%A5%E4%B9%8B%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[MDN对闭包的定义为： 闭包是指那些能够访问自由变量的函数 那什么是自由变量呢？ 自由变量是指在函数中使用的，但既不是函数参数也不是函数的局部变量的变量 由此，我们可以看出闭包由两部分组成： 函数 + 函数能访问到的自由变量 举个例子： 1234var a = 1function foo() &#123; console.log(a)&#125; foo 函数可以访问访问变量a， 但是a既不是foo的局部变量，也不是foo函数的参数，所有a就是自由变量。 那么，函数foo与foo函数访问的自由变量a不就是构成了一个闭包？ 真是这样的！在《JavaScript权威指南》中讲到：从技术的角度讲，所有的JavaScript函数都是闭包。 咦，这怎么跟我们平时看到的讲到的闭包不一样呢！？ 别着急，这是理论上的闭包，其实还有一个实践角度上的闭包，让我们看看汤姆大叔翻译的关于闭包的文章中的定义： ECMAScript中，闭包指的是： 从理论角度：所有的函数。因为它们都在创建的时候就将上层上下文的数据保存起来了。哪怕是简单的全局变量也是如此，因为函数中访问全局变量就相当于是在访问自由变量，这个时候使用最外层的作用域。 从实践角度：以下函数才算是闭包： 即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回） 在代码中引用了自由变量 接下来就来讲讲实践上的闭包。 分析让我们先写个例子，例子依然是来自《JavaScript权威指南》，稍微做点改动： 1234567891011var scope = 'global scope'function checkscope() &#123; var scope = 'local scope' function f() &#123; return scope &#125; return f&#125;var foo = checkscope()foo() 首先我们来分析一下这段代码中执行上下文栈和执行上下文的变化情况。 这里直接给出简要的执行过程： 进入全局代码，创建全局执行上下文，全局执行上下文压入执行上下文栈 全局执行上下文初始化 执行checkscope函数，创建checkscope函数执行上下文，checkscope执行上下文被压入执行上下文栈 checkscope执行上下文初始化，创建变量对象、作用域链、this等 checkscope函数执行完毕，checkscope执行上下文从执行上下文栈中弹出。 执行f函数，创建f函数执行上下文，f执行上下文被压入执行上下文栈 f执行上下文初始化，创建变量对象、作用域链、this等 f函数执行完毕，f函数上下文从执行上下文栈中弹出 了解到这个过程，我们应该思考一个问题，那就是： 当f函数执行时，checkscope函数上下文已经被销毁了，那怎么还能读取到checkscope作用域下的scope指呢？ 当我们了解了具体的执行过程后，我们知道f执行上下文维护了一个作用域链： 123fContext = &#123; Scope: [AO, checkscopeContext.AO, globalContext.VO]&#125; 对的，就是因为这个作用域链，f函数依然可以读取到checkscopeContext.AO的值，说明当f函数引用了checkscopeContext.AO中的值的时候，即使checkscopeContext被销毁了，但是JavaScript依然会让checkscopeContext.AO活在内存中，f函数依然可以通过f函数的作用域链找到它，正是因为JavaScript做到了这一点，从而实现闭包这个概念。 所有，让我们再看一遍实践角度上闭包的定义： 即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回） 在代码中引用了自由变量 在这里再补充一个《JavaScript权威指南》英文原版对闭包的定义: This combination of a function object and a scope (a set of variable bindings) in which the function’s variables are resolved is called a closure in the computer science literature. 闭包在计算机科学中也只是一个普通的概念，大家不要去想得太复杂。 必刷题接下来，看这道刷题必刷，面试必考的闭包题： 1234567891011var data = []for (var i = 0; i &lt; 3; i++) &#123; data[i] = function() &#123; console.log(i) &#125;&#125;data[0]()data[1]()data[2]() 答案都是3，让我们分析一下原因： 当执行到data[0]函数之前，此时全局上下文的VO为： 123456globalContext = &#123; VO: &#123; data: [...], i: 3 &#125;&#125; 当执行data[0]函数的时候，data[0]函数的作用域链为： 123data[0]Context = &#123; Scope: [AO, globalContext.VO]&#125; data[0]Context的AO并没有i值，所有会从globalContext.VO中查找，i为3，蓑衣打印的结果就是3。 data[1]和data[2]是一样的道理。 所有让我们改成闭包看看： 12345678910111213var data = []for (var i = 1; i &lt; 3; i++) &#123; data[i] = (function(i) &#123; return function() &#123; console.log(i) &#125; &#125;)&#125;data[0]();data[1]();data[2](); 当执行到data[0]函数之前，此时全局上下文的VO为： 123456globalContext = &#123; VO: &#123; data: [...], i: 3 &#125;&#125; 跟没改之前一模一样。 当执行data[0]函数的时候，data[0]函数的作用域链发送了改变： 123data[0]Context = &#123; Scope: [AO, 匿名函数Context.AO, globalContext.VO]&#125; 匿名函数执行上下文的AO为： 123456789匿名函数COntext = &#123; AO: &#123; arguments: &#123; 0: 0, length:1 &#125;, i: 0 &#125;&#125; data[0]Context的AO并没有i值，所有会沿着作用域链从匿名函数Context.AO中查找，这时候就会找i为0，找到了就不会往 globalContext.VO 中查找了，即使 globalContext.VO 也有 i 的值(值为3)，所以打印的结果就是0。 data[1] 和 data[2] 是一样的道理。]]></content>
  </entry>
  <entry>
    <title><![CDATA[JavaScript深入之执行上下文]]></title>
    <url>%2F2019%2F09%2F24%2FJavaScript%E6%B7%B1%E5%85%A5%E4%B9%8B%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87-1%2F</url>
    <content type="text"><![CDATA[在《JavaScript深入之执行上下文栈》中讲到，当 JavaScript 代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)。 对于每个执行上下文，都有三个重要属性： 变量对象(Variable object，VO) 作用域链(Scope chain) this 然后分别在《JavaScript深入之变量对象》、《JavaScript深入之作用域链》、《JavaScript深入之从ECMAScript规范解读this》中讲解了这三个属性。 阅读本文前，如果对以上的概念不是很清楚，希望先阅读这些文章。 因为，这一篇，我们会结合着所有内容，讲讲执行上下文的具体处理过程。 思考题在《JavaScript深入之词法作用域和动态作用域》中，提出这样一道思考题： 12345678910var scope = 'global scope'function checkscope() &#123; var scope = 'local scope' function f() &#123; return scope &#125; return f()&#125;checkscope() 12345678910var scope = 'global scope'function checkscope() &#123; var scope = 'local scope' function f() &#123; return scope &#125; return f&#125;checkscope()() 两段代码都会打印‘local scope’，虽然两端代码执行的结果一样，但是两段代码究竟有哪些不同呢？ 紧接着就在下一篇《JavaScript深入之执行上下文栈》中，讲到了两者的区别在于执行上下文栈的变化不一样，然而，如果是这样笼统的回答，依然显得不够详细，本篇就会详细的解析执行上下文栈和执行上下文的具体变化过程 具体执行分析我们分析第一段代码： 12345678910var scope = 'global scope'function checkscope() &#123; var scope = 'local scope' function f() &#123; return scope &#125; return f()&#125;checkscope() 执行过程如下： 执行全局代码，创建全局执行上下文，全局上下文被压入执行上下文栈。 123ECStack = [ globalContext] 全局上下文初始化 12345globalContext = &#123; VO: [global], Scope: [globalContext.VO], this: globalContext.VO&#125; 初始化的同时，checkscope函数被创建，保存作用域链到函数的内部属性[[scope]] 123checkscope.[[scope]] = [ globalContext.VO] 执行checkscope函数，创建checkscope函数执行上下文，checkscope函数执行上下文被压入执行上文栈 1234ECStack = &#123; checkscopeContext, globalContext&#125; checkscope函数执行上下文初始化： 复制函数[[scope]]属性创建作用域链 用arguments创建活动对象 初始化活动对象，即加入形参、函数声明、变量对象 将活动对象压入checkscope作用域链顶端 1234567891011checkscopeContext = &#123; AO: &#123; arguments: &#123; length: 0 &#125;, scope: undefined, f: reference to function f()&#123;&#125; &#125;, Scope: [AO, globalContext.VO], this: undefined&#125; 执行f函数，创建函数执行上下文，f函数执行上下文被压入执行上下文栈 12345ECStack = [ fContext, checkscopeContext, globalContext] f函数执行上下文初始化，以下跟第4步相同： 复制函数[[scope]]属性创建作用域链 用arguments创建活动对象 初始化活动对象，即加入形参、函数声明、变量对象 将活动对象压入f作用域链顶端 123456789fContext = &#123; AO: &#123; arguments: &#123; length: 0 &#125; &#125;, Scope: [AO, checkscopeContext.AO, globalContext.AO], this: undefined&#125; f函数执行，沿着作用域链查找scope值，返回scope值 f函数执行完毕，f函数上下文从执行上下文栈中弹出 1234ECStack = [ checkscopeContext, globalContext] checkscope函数执行完毕，checkscope执行上下文从执行上下文栈中弹出 123ECStack = [ globalContext] 第二段代码就留给大家去尝试模拟它的执行过程。 123456789var scope = &quot;global scope&quot;;function checkscope()&#123; var scope = &quot;local scope&quot;; function f()&#123; return scope; &#125; return f;&#125;checkscope()(); 不过，在下一篇《JavaScript深入之闭包》中也会提及这段代码的执行过程。]]></content>
  </entry>
  <entry>
    <title><![CDATA[JavaScript深入之从ECMAScript规范解读this]]></title>
    <url>%2F2019%2F09%2F22%2FJavaScript%E6%B7%B1%E5%85%A5%E4%B9%8B%E4%BB%8EECMAScript%E8%A7%84%E8%8C%83%E8%A7%A3%E8%AF%BBthis%2F</url>
    <content type="text"><![CDATA[在《JavaScript深入之执行上下文栈》中讲到，当JavaScript代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)。 对于每个执行上下文，都有三个重要属性 变量对象(Variable object，VO) 作用域链(Scope chain) this 今天重点讲讲 this，然而不好讲。 因为我们要从 ECMASciript5 规范开始讲起。 Types Types are further subclassified into ECMAScript language types and specification types. An ECMAScript language type corresponds to values that are directly manipulated by an ECMAScript programmer using the ECMAScript language. The ECMAScript language types are Undefined, Null, Boolean, String, Number, and Object. A specification type corresponds to meta-values that are used within algorithms to describe the semantics of ECMAScript language constructs and ECMAScript language types. The specification types are Reference, List, Completion, Property Descriptor, Property Identifier, Lexical Environment, and Environment Record. 我们简单的翻译一下： ECMAScript的类型分为语言类型和规范类型。 ECMAScript语言类型时开发者直接使用，ECMAScript可以操作的。其实就是我们常说的undefined、null、boolean、String、Number和Object。 而规范类型相当于meta-value，是用算法来描述ECMAScript语言结构和ECMAScript语言类型的。规范类型包括：Reference、List、Completion、Property Descriptor、Property Identifier、Lexical Environment和Enviroment Record。 没懂？没关系，我们只要知道在ECMAScript规范中还有一种只存在于规范中的类型，它们的作用是用来描述语言底层行为逻辑。 今天我们要讲的重点便是其中的Reference类型。它与this的指向有着密切的关联。 Reference那什么又是Reference？ The Reference type is used to explain the behaviour of such operators as delete, typeof, and the assignment operators. 所以 Reference 类型就是用来解释诸如 delete、typeof 以及赋值等操作行为的。 抄袭尤雨溪大大的话，就是： 这里的 Reference 是一个 Specification Type，也就是 “只存在于规范里的抽象类型”。它们是为了更好地描述语言的底层行为逻辑才存在的，但并不存在于实际的 js 代码中。 再看接下来的这段具体介绍 Reference 的内容： A Reference is a resolved name binding. A Reference consists of three components, the base value, the referenced name and the Boolean valued strict reference flag. The base value is either undefined, an Object, a Boolean, a String, a Number, or an environment record (10.2.1). A base value of undefined indicates that the reference could not be resolved to a binding. The referenced name is a String. 这段讲述了 Reference 的构成，由三个组成部分，分别是： base value referenced name strict reference 可是这些到底是什么呢？ 我们简单的理解的话： base value就是属性所在的对象或者就是EnvironmentRecord，它的值只可能undefined, an Object, a Boolean, a String, a Number, or an environment record 其中的一种。 referenced name 就是属性的名称。 举个例子： 12345678var foo = 1// 对应的Reference是：var fooReference = &#123; base: EnviromentRecord, name: 'foo', strict: false&#125; 再举个例子： 1234567891011121314var foo = &#123; bar: function () &#123; return this &#125;&#125;foo.bar() // foo// bar 对应的Reference是：var barReference = &#123; base: foo, propertyName: 'bar', strict: false&#125; 而且规范中还提供获取Reference组成部分的方法，比如GetBase和isPropertyReference。 这两个方法很简单，我们来看一看： 1.GetBase GetBase(V). Returns the base value component of the reference V. 返回 reference 的 base value。 2.IsPropertyReference IsPropertyReference(V). Returns true if either the base value is an object or HasPrimitiveBase(V) is true; otherwise returns false. 简单的理解：如果 base value 是一个对象，就返回true。 GetValue除此之外，紧接着在 8.7.1 章规范中就讲了一个用于从 Reference 类型获取对应值的方法： GetValue。 简单模拟 GetValue 的使用： 123456789var foo = 1var fooReference = &#123; base: EnviromentRecord, name: 'foo', stirct: false&#125;GetValue(fooReference) 1 GetValue 返回对象属性真正的值，但是要注意： 调用 GetValue，返回的将是具体的值，而不再是一个 Reference 这个很重要，这个很重要，这个很重要。 如何确定this的值。关于Reference讲了那么多，那为什么要讲Reference呢？到底Reference跟本文的主题this有哪些关联呢？ 这里讲了当函数调用的时候，如何确定 this 的取值。 只看第一步、第六步、第七步： 1.Let ref be the result of evaluating MemberExpression. 6.If Type(ref) is Reference, then 12&gt; a.If IsPropertyReference(ref) is true, then&gt; 12&gt; i.Let thisValue be GetBase(ref).&gt; 12&gt; b.Else, the base of ref is an Environment Record&gt; 12&gt; i.Let thisValue be the result of calling the ImplicitThisValue concrete method of GetBase(ref).&gt; 7.Else, Type(ref) is not Reference. 12&gt; a. Let thisValue be undefined.&gt; 让我们描述一下： 1.计算 MemberExpression 的结果赋值给 ref 2.判断 ref 是不是一个 Reference 类型 123452.1 如果 ref 是 Reference，并且 IsPropertyReference(ref) 是 true, 那么 this 的值为 GetBase(ref)2.2 如果 ref 是 Reference，并且 base value 值是 Environment Record, 那么this的值为 ImplicitThisValue(ref)2.3 如果 ref 不是 Reference，那么 this 的值为 undefined 具体分析让我们一步一步看： 计算 MemberExpression 的结果赋值给 ref 什么是 MemberExpression？看规范 11.2 Left-Hand-Side Expressions： MemberExpression : PrimaryExpression // 原始表达式 可以参见《JavaScript权威指南第四章》 FunctionExpression // 函数定义表达式 MemberExpression [ Expression ] // 属性访问表达式 MemberExpression . IdentifierName // 属性访问表达式 new MemberExpression Arguments // 对象创建表达式 举个例子： 123456789101112131415161718192021function foo() &#123; console.log(this)&#125;foo(); // MemberExpression 是 foofunction foo() &#123; return function() &#123; console.log(this) &#125;&#125;foo()(); // MemberExpression 是 foo()var foo = &#123; bar: function () &#123; return this; &#125;&#125;foo.bar(); // MemberExpression 是 foo.bar 所以简单理解 MemberExpression 其实就是()左边的部分。 2.判断 ref 是不是一个 Reference 类型。 关键就在于看规范是如何处理各种 MemberExpression，返回的结果是不是一个Reference类型。 举最后一个例子： 12345678910111213141516171819var value = 1;var foo = &#123; value: 2, bar: function () &#123; return this.value; &#125;&#125;//示例1console.log(foo.bar());//示例2console.log((foo.bar)());//示例3console.log((foo.bar = foo.bar)());//示例4console.log((false || foo.bar)());//示例5console.log((foo.bar, foo.bar)()); foo.bar()在示例 1 中，MemberExpression 计算的结果是 foo.bar，那么 foo.bar 是不是一个 Reference 呢？ 查看规范 11.2.1 Property Accessors，这里展示了一个计算的过程，什么都不管了，就看最后一步： Return a value of type Reference whose base value is baseValue and whose referenced name is propertyNameString, and whose strict mode flag is strict. 我们得知该表达式返回了一个 Reference 类型！ 根据之前的内容，我们知道该值为： 12345var Reference = &#123; base: foo, name: 'bar', strict: false&#125;; 接下来按照 2.1 的判断流程走： 2.1 如果 ref 是 Reference，并且 IsPropertyReference(ref) 是 true, 那么 this 的值为 GetBase(ref) 该值是 Reference 类型，那么 IsPropertyReference(ref) 的结果是多少呢？ 前面我们已经铺垫了 IsPropertyReference 方法，如果 base value 是一个对象，结果返回 true。 base value 为 foo，是一个对象，所以 IsPropertyReference(ref) 结果为 true。 这个时候我们就可以确定 this 的值了： 1this = GetBase(ref)， GetBase 也已经铺垫了，获得 base value 值，这个例子中就是foo，所以 this 的值就是 foo ，示例1的结果就是 2！ 唉呀妈呀，为了证明 this 指向foo，真是累死我了！但是知道了原理，剩下的就更快了。 (foo.bar)()看示例2： 1console.log((foo.bar)()); foo.bar 被 () 包住，查看规范 11.1.6 The Grouping Operator 直接看结果部分： Return the result of evaluating Expression. This may be of type Reference. NOTE This algorithm does not apply GetValue to the result of evaluating Expression. 实际上 () 并没有对 MemberExpression 进行计算，所以其实跟示例 1 的结果是一样的。 (foo.bar = foo.bar)()看示例3，有赋值操作符，查看规范 11.13.1 Simple Assignment ( = ): 计算的第三步： 3.Let rval be GetValue(rref). 因为使用了 GetValue，所以返回的值不是 Reference 类型， 按照之前讲的判断逻辑： 2.3 如果 ref 不是Reference，那么 this 的值为 undefined this 为 undefined，非严格模式下，this 的值为 undefined 的时候，其值会被隐式转换为全局对象。 (false || foo.bar)()看示例4，逻辑与算法，查看规范 11.11 Binary Logical Operators： 计算第二步： 2.Let lval be GetValue(lref). 因为使用了 GetValue，所以返回的不是 Reference 类型，this 为 undefined (foo.bar, foo.bar)()看示例5，逗号操作符，查看规范11.14 Comma Operator ( , ) 计算第二步： 2.Call GetValue(lref). 因为使用了 GetValue，所以返回的不是 Reference 类型，this 为 undefined 揭晓结果所以最后一个例子的结果是： 12345678910111213141516171819var value = 1;var foo = &#123; value: 2, bar: function () &#123; return this.value; &#125;&#125;//示例1console.log(foo.bar()); // 2//示例2console.log((foo.bar)()); // 2//示例3console.log((foo.bar = foo.bar)()); // 1//示例4console.log((false || foo.bar)()); // 1//示例5console.log((foo.bar, foo.bar)()); // 1 注意：以上是在非严格模式下的结果，严格模式下因为 this 返回 undefined，所以示例 3 会报错。 补充最最后，忘记了一个最最普通的情况： 12345function foo() &#123; console.log(this)&#125;foo(); MemberExpression 是 foo，解析标识符，查看规范 10.3.1 Identifier Resolution，会返回一个 Reference 类型的值： 12345var fooReference = &#123; base: EnvironmentRecord, name: 'foo', strict: false&#125;; 接下来进行判断： 2.1 如果 ref 是 Reference，并且 IsPropertyReference(ref) 是 true, 那么 this 的值为 GetBase(ref) 因为 base value 是 EnvironmentRecord，并不是一个 Object 类型，还记得前面讲过的 base value 的取值可能吗？ 只可能是 undefined, an Object, a Boolean, a String, a Number, 和 an environment record 中的一种。 IsPropertyReference(ref) 的结果为 false，进入下个判断： 2.2 如果 ref 是 Reference，并且 base value 值是 Environment Record, 那么this的值为 ImplicitThisValue(ref) base value 正是 Environment Record，所以会调用 ImplicitThisValue(ref) 查看规范 10.2.1.1.6，ImplicitThisValue 方法的介绍：该函数始终返回 undefined。 所以最后 this 的值就是 undefined。 多说一句尽管我们可以简单的理解 this 为调用函数的对象，如果是这样的话，如何解释下面这个例子呢？ 123456789var value = 1;var foo = &#123; value: 2, bar: function () &#123; return this.value; &#125;&#125;console.log((false || foo.bar)()); // 1 此外，又如何确定调用函数的对象是谁呢？在写文章之初，我就面临着这些问题，最后还是放弃从多个情形下给大家讲解 this 指向的思路，而是追根溯源的从 ECMASciript 规范讲解 this 的指向，尽管从这个角度写起来和读起来都比较吃力，但是一旦多读几遍，明白原理，绝对会给你一个全新的视角看待 this 。而你也就能明白，尽管 foo() 和 (foo.bar = foo.bar)() 最后结果都指向了 undefined，但是两者从规范的角度上却有着本质的区别。 此篇讲解执行上下文的 this，即便不是很理解此篇的内容，依然不影响大家了解执行上下文这个主题下其他的内容。所以，依然可以安心的看下一篇文章。]]></content>
  </entry>
  <entry>
    <title><![CDATA[JavaScript深入之作用域链]]></title>
    <url>%2F2019%2F09%2F22%2FJavaScript%E6%B7%B1%E5%85%A5%E4%B9%8B%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%2F</url>
    <content type="text"><![CDATA[在[《JavaScript深入之执行上下文栈》]()中讲到，当JavaScript代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)。 对于每个执行上下文，都有三个重要属性： 变量对象(Variable object，VO) 作用域链(Scope chain) this 今天重点讲讲作用域链。 作用域链在《JavaScript深入之变量对象》中讲到，当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有查找，就会从父级（词法层面的父级）执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象，这样由多个执行上下文的变量对象构成的链表就叫做作用域链。 下面，让我们以一个函数的创建和激活两个时期来讲解作用域链是如何创建和变换的。 函数创建在《JavaScript深入之词法作用域和动态作用域》中讲到，函数的作用域在函数定义的时候就决定了。 这是因为函数有一个内部函数[[scope]]，当函数创建的时候，就会报错所有父级变量对象到其中，你可以理解为[[scope]]就是所有父级变量对象的层级链，但是注意：[[scope]]并不表示完整的作用域链。 举个例子： 12345function foo() &#123; function bar() &#123; ... &#125;&#125; 函数创建时，各自的[[scope]]为： 12345678foo.[[scope]] = [ globalContext.VO]bar.[[scope]] = [ fooContext.AO, globalContext.VO] 函数激活当函数激活时，进入函数上下文，创建VO/AO后，就将活动对象添加到作用域链的前端： 这时候执行上下文的作用域，我们命名为Scope： 1Scope = [AO].concat([[Scope]]) 至此，作用域链创建完毕。 以下面的例子为例，结合之前讲的变量对象和执行上下文栈，我们来总结一下函数执行上下文中作用域链和变量对象的创建过程： 123456var scope = 'global scope'function checkscope() &#123; var scope2 = 'local scope' return scope2&#125;checkscope() 在执行过程中： checkscope函数被创建，保存作用域链内部属性[[scope]] 123checkscope.[[scope]] = [ globalContext.VO] 执行checkscope函数，创建函数上下文，checkscope函数执行上下文被压入执行上下文栈： 1234ECStack = [ checkscopeContext, globalContext] checkscope函数并不立即执行，开始做准备工作，第一步：复制函数[[scope]]属性创建作用域链 123checkscopeContext = &#123; Scope: checkscope.[[scope]]&#125; 第二步：用arguments创建活动对象，随后初始化活动对象，加入形参、函数声明、变量声明。 123456789checkscopeContext = &#123; AO: &#123; arguments: &#123; length: 0 &#125;, scope2: undefined &#125;, Scope: checkscope.[[scope]]&#125; 第三步：将活动对象压入checkscope作用域链顶端 123456789checkscopeContext = &#123; AO: &#123; arguments: &#123; length: 0 &#125;, scope2: undefined &#125;, Scope: [AO, [[Scope]]]&#125; 准备工作做完，开始执行函数，随着函数的执行，修改AO的属性值。 123456789checkscopeContext = &#123; AO: &#123; arguments: &#123; length: 0 &#125;, scope2: 'local scope' &#125;, Scope: [AO, [[Scope]]]&#125; 查找到scope2的值，返回后函数执行完毕，函数上下文从执行上下文栈中弹出： 123ECStack = [ globalContext]]]></content>
  </entry>
  <entry>
    <title><![CDATA[JavaScript深入之变量对象]]></title>
    <url>%2F2019%2F09%2F22%2FJavaScript%E6%B7%B1%E5%85%A5%E4%B9%8B%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[在上篇[《JavaScript深入之执行上下文栈》]()中讲到，当 JavaScript 代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)。 对于每个执行上下文，都有三个重要属性： 变量对象（Variable object， VO） 作用域链（Scope Chain） this 今天重点讲讲创建变量对象的过程。 变量对象变量对象是与执行上下文相关的数据作用域，存储了在上下文定义的变量和函数声明。 因为不同执行上下文下的变量对象稍有不同，所以我们来聊聊全局上下文的全局变量与函数上下文的变量对象。 全局上下文我们先了解一个概念，叫全局对象。在 W3School 中也有介绍： 全局对象是预定义的对象，作为 JavaScript 的全局函数和全局属性的占位符。通过使用全局对象，可以访问所有其他所有预定义的对象、函数和属性。 在顶层 JavaScript 代码中，可以用关键字 this 引用全局对象。因为全局对象是作用域链的头，这意味着所有非限定性的变量和函数名都会作为该对象的属性来查询。 例如，当JavaScript 代码引用 parseInt() 函数时，它引用的是全局对象的 parseInt 属性。全局对象是作用域链的头，还意味着在顶层 JavaScript 代码中声明的所有变量都将成为全局对象的属性。 如果看的不是很懂的话，容我再来介绍下全局对象： 可以通过this引用，在客户端JavaScript中，全局对象就是Window对象。 1console.log(this) 全局对象是由Object构造函数实例化的一个对象。 1console.log(this instanceof Object) 预定义了一堆函数与属性 12console.log(Math.random())cosole.log(this.Math.random()) 作为全局变量的宿主 12var a = 1console.log(this.a) 客户端JavaScript中，全局对象由window属性指向自身。 12345var a = 1console.log(window.a)this.window.b =2console.log(this.b) 函数上下文在函数上下文中，我们用活动对象(activation object, AO)来表示变量对象。 活动对象和变量对象其实是一个东西，只是变量对象是规范上或者说是引擎实现上的，不可以在JavaScript环境中访问，只要到当进入一个执行上下文中，这个执行上下文的变量对象才会被激活，所以才叫activation object，而只要被激活的变量对象，也就是活动对象上的各种属性才能被访问。 活动对象是在进入函数上下文时被创建的，它通过函数的arguments属性初始化。arguments属性值时Arguments对象。 执行过程执行上下文的代码会分成两个阶段进行处理，分析和执行，我们也可以叫做： 进入执行上下文 代码执行 进入执行上下文 当进入执行上下文时，这时候还没有执行代码， 变量对象包括： 函数的所有形参（如果是函数作用域） 由名称和对应值组成的一个变量对象的属性被创建 没有实参，属性值设为undefined 函数声明 由名称和对应值（函数对象(function-object)）组成一个变量对象的属性被创建 如果变量对象已经存在相同名称的属性，则完全替换这个属性。 变量声明 由名称和对应值（undefined）组成一个变量对象的属性被创建； 如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性 举个例子： 12345678910function foo(a) &#123; var b = 2 function c() &#123;&#125; var d = function() &#123;&#125; b = 3&#125;foo(1) 进入执行上下文后，这个时候的AO是： 12345678910AO = &#123; arguments: &#123; 0 : 1, length: 1 &#125;, a: 1, b: undefined, c: reference to function c() &#123;&#125;, d: undefined&#125; 代码执行： 在代码执行阶段，会顺序执行代码，根据代码，修改变量对象的值。 还是上面的例子，当代码执行完后，这时候的AO是： 12345678910AO = &#123; arguments: &#123; 0: 1, length: 1 &#125;, a: 1, b: 3, c: reference to function c() &#123;&#125;, d: referenct to FunctionExpression 'd'&#125; 到这里变量对象的创建过程就介绍完了，让我们简洁的总结我们上述所说： 全局上下文的变量对象初始化是全局对象。 函数上下文的变量对象初始化只包括Arguments对象。 在进入执行上下文时会给变量添加形参、函数声明、变量声明等初始的属性值。 在代码执行阶段，会再次修改变量对象的属性。 思考题最后让我们看几个例子： 第一题 12345678910111213function foo() &#123; console.log(a) a = 1&#125;foo() // ???function bar() &#123; a = 1 console.log(a)&#125;bar() // ??? 第一段会报错，Uncaught ReferenceError: a is not defined。 第二段会打印：1。 这是因为函数中的’a‘并没有通过var关键字声明，所以不会被存放在AO中。 第一段执行console的时候，AO的值是： 12345AO = &#123; arguments: &#123; length: 0 &#125;&#125; 没有a的值，然后就会到全局去找，全局也没有，所有会报错。 当第二段执行console的时候，全局对象已经被赋予了a属性，这时候就可以从全局找到a的值，所有会打印1. 第二题 1234567console.log(foo)function foo() &#123; console.log(foo)&#125;var foo = 1 会打印函数，而不是undefined。 这是因为在进入执行上下文时，首先会处理函数声明，其次会处理变量声明，如果变量名称跟已经声明的形参或者函数相同，则变量声明不会干扰已经存在的这类属性。]]></content>
  </entry>
  <entry>
    <title><![CDATA[JavaScript深入之执行上下文]]></title>
    <url>%2F2019%2F09%2F22%2FJavaScript%E6%B7%B1%E5%85%A5%E4%B9%8B%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%2F</url>
    <content type="text"><![CDATA[## 顺序执行？ 如果要问到JavaScript代码执行顺序的话，想必写过JavaScript的开发者都会有个直观的印象，那就是顺序执行.毕竟： 123456789101112131415var foo = function () &#123; console.log('foo1');&#125;foo(); // foo1var foo = function () &#123; console.log('foo2');&#125;foo(); // foo2 然而去看这段代码： 123456789101112131415function foo() &#123; console.log('foo1');&#125;foo(); // foo2function foo() &#123; console.log('foo2');&#125;foo(); // foo2 打印的结果是两个foo2 刷过面试题的都知道这是因为JavaScript引擎并发一行一行的分析和执行程序，而是一段一段地分析执行。当执行一段代码的时候，会进行一个‘准备工作’，比如第一个例子中的变量提升，和第二个例子中的函数提升。 但是本文真正想让大家思考的是：这个‘一段一段’中的‘段’究竟是怎么划分的呢？ 到底JavaScript引擎遇到一段怎样的代码时才会做‘准备工作’呢？ 可执行代码这就要说到JavaScript的可执行代码(executable code)的类型有哪些了？ 其实很简单，就三种，全局代码、函数代码、eval代码。 举个例子，当执行到一个函数的时候，就会准备工作，这里的‘准备工作’，让我们用一个更专业的说法，就是执行上下文(execution context)。 执行上下文栈接下来问题来了，我们写的函数多了去了，如何管理创建的那么多执行上下文呢？ 所以JavaScript引擎创建了执行上下文栈(Execution context stack, ECS)来管理执行上下文。 为了模拟执行上下文栈的行为，让我们定义执行上下文栈是一个数组： 1ECStack = [] 试想当JavaScript开始要解释执行代码的时候，最先遇到的就是全局代码，所以初始化的时候首先就会向执行上下文栈压入一个全局执行上下文，我们用globalContext表示它，并且只有当整个应用程序结束的时候，ECStack才会被清空，所以程序结束之前，ECStack最底部永远有个globalContext： 123ECStack = [ globalContext] 现在JavaScript遇到下面的这段代码： 12345678910111213function fun3() &#123; console.log('fun3')&#125;function fun2() &#123; fun3()&#125;function fun1() &#123; fun2()&#125;fun1() 当执行一个函数的时候，就会创建一个执行上下文，并且压入执行上下文栈，当函数执行完毕的时候，就会将函数的执行上下文从栈中弹出，知道了这样的工作原理，让我们来看看如何处理上面的这段代码： 123456789101112131415161718// 伪代码// fun1()ECStack.push(&lt;fun1&gt; functionContext)// fun1中竟然调用了fun2，还要创建fun2的执行上下文ECStack.push(&lt;fun2&gt; functionContext)// fun2还调用了fun3ECStack.push(&lt;fun3&gt; functionContext)// fun3执行完毕ECStack.pop();// fun2执行完毕ECStack.pop();// fun1执行完毕ECStack.pop();// javascript接着执行下面的代码，但是ECStack底层永远有个globalContext 解答思考题好啦，现在我们已经了解了执行上下文栈是如何处理执行上下文的，所以让我们看看上篇文章《JavaScript深入之词法作用域和动态作用域》最后的问题： 123456789var scope = "global scope";function checkscope()&#123; var scope = "local scope"; function f()&#123; return scope; &#125; return f();&#125;checkscope(); 123456789var scope = "global scope";function checkscope()&#123; var scope = "local scope"; function f()&#123; return scope; &#125; return f;&#125;checkscope()(); 两段代码执行的结果一样，但是两段代码究竟有哪些不同呢？ 答案就是执行上下文栈的变化不一样。 让我们模拟第一段代码： 1234ECStack.push(&lt;checkscope&gt; functionContext)ECStack.push(&lt;f&gt; functionContext)ECStack.pop()ECStack.pop() 让我们模拟第二段代码： 1234ECStack.push(&lt;checkscope&gt; functionContext);ECStack.pop();ECStack.push(&lt;f&gt; functionContext);ECStack.pop(); 是不是有些不同呢？ 当然了，这样概括的回答执行上下文栈的变化不同，是不是依然有一种意犹未尽的感觉呢，为了更详细讲解两个函数执行上的区别，我们需要探究一下执行上下文到底包含了哪些内容，所以欢迎阅读下一篇《JavaScript深入之变量对象》。]]></content>
  </entry>
  <entry>
    <title><![CDATA[JavaScript深入之词法作用域与动态作用域]]></title>
    <url>%2F2019%2F09%2F22%2FJavaScript%E6%B7%B1%E5%85%A5%E4%B9%8B%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E5%8A%A8%E6%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[作用域作用域是指程序源代码中定义变量的区域。 作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。 JavaScript采用词法作用域（lexical scoping），也就是静态作用域。 静态作用域与动态作用域因为JavaScript采用的是词法作用域，函数的作用域在函数定义的时候就决定了。 而与词法作用域相对的是动态作用域，函数的作用域是在函数调用的时候才决定的。 让我们认真看个例子就能明白之间的区别： 123456789101112var value = 1function foo() &#123; console.log(value)&#125;function bar() &#123; var value = 2 foo()&#125;bar() // 结果是？ 假设JavaScript采用静态作用域，让我们分析执行过程： 执行foo函数，先从foo函数内部查找是否有局部变量value，如果没有，就根据书写的位置，查找上面一层的代码，也就是value等于1，所以结果会打印1。 假设JavaScript采用动态作用域，让我们分析执行过程： 执行foo函数，依然是从foo函数内部查找是否有局部变量value。如果没有，就从调用函数的作用域，也就是bar函数内部查找value变量，所以结果会打印2. 动态作用域也许你会好奇什么语言是动态作用域？ bash就是动态作用域，不信的话，把下面的脚本存成例如scope.bash，然后进入相应的目录，用命令行执行bash ./scope.bahs,看看打印的值是多少。 12345678910value=1function foo () &#123; echo $value&#125;function bar () &#123; local value=2 foo&#125;bar 思考题最后，让我们看一下《JavaScript权威指南》中的例子： 123456789var scope = 'global scope'function checkscope() &#123; var scope = 'local scope' function f() &#123; return scope &#125; return f()&#125;checkscope() 123456789var scope = 'global scope'function checkscope() &#123; var scope = 'local scope' function f() &#123; return scope &#125; return f&#125;checkscope()() 猜猜两段代码各自的执行结果是什么？ 这里直接告诉大家结果，两段代码都会打印`local scope。 原因也很简单，因为JavaScript采用的词法作用域，函数的作用域基于函数创建的位置。 而引用《JavaScript权威指南》的回答就是： Javascript函数的执行用到了作用域链，这个作用域链就是在函数定义的时候创建的。嵌套的函数f()定义在这个作用域链里，其中的变量scope一定是局部变量，不管何时何地执行函数f()。这种绑定在执行f()时依然有效。 但是在这里真正想让大家思考的是： 虽然两段代码的执行的结果一样，但是两段代码究竟有哪些不同呢？ 如果要回答这个问题，就要牵涉到很多的内容，词法作用域只是其中的一小部分，让我们期待下一篇文章————《JavaScript深入之执行上下文栈》。]]></content>
  </entry>
  <entry>
    <title><![CDATA[JavaScript深入之从原型到原型链]]></title>
    <url>%2F2019%2F09%2F20%2FJavaScript%E6%B7%B1%E5%85%A5%E4%B9%8B%E4%BB%8E%E5%8E%9F%E5%9E%8B%E5%88%B0%E5%8E%9F%E5%9E%8B%E9%93%BE%2F</url>
    <content type="text"><![CDATA[## 构建函数创建对象 我们先使用构造函数创建一个对象： 1234567function Person() &#123; &#125;var person = new Person()person.name = 'Kevin'console.log(person.name) // Kevin 在这个例子中，Person就是一个构造函数，我们使用new创建了一个实例对象person。 很简单吧，接下来进入正题： prototype每个函数都有一个prototype属性，就是我们经常在各种例子中看到的那个prototype，比如： 12345678910function Person() &#123; &#125;// 注意，prototype是函数才有的属性Person.prototype.name = 'Kevin'var person1 = new Person()var person2 = new Person()console.log(person1.name) // Kevinconsole.log(perosn2.name) // Kevin 那这个函数的prototype属性到底指向的是什么呢？是这个函数的原型吗？ 其实，函数的prototype属性指向了一个对象，这个对象正是调用该构造函数而创建的实例的原型，也就是这个例子中的person1和person2的原型。 那什么是原型呢？你可以这样理解：每一个JavaScript对象（null除外）在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型‘继承’属性。 让我们用一张图来表示构造函数和实例原型之间的关系 : 在这张图中我们用Object.prototype表示实例原型。 那么我们该怎么表示实例与实例原型，也就是person和Person.prototype之间的关系呢，这时候我们就来讲第二个属性： proto这是每一个JavaScript对象（除了null）都具有的一个属性，叫 __proto__，这个属性会指向该对象的原型。 为了证明这一点，我们可以在火狐或者谷歌中输入： 123456function Person() &#123; &#125;var person = new Person()console.log(person.__proto__ === Person.prototype) // true 于是我们更新下关系图： 既然实例对象和构造函数都可以指向原型，那么原型是否有属性指向构造函数或者实例呢？ constructor指向实例的属性是没有的，因为一个构造函数可以生成多个实例。但是原型指向构造函数倒是有的，这就要到第三个属性：constructor。每个原型都有一个constructor属性指向关联的构造函数。 为了验证这一点，我们可以尝试： 1234function Person() &#123; &#125;console.log(Person === Person.prototype.constructor) // true 所以再次更新关系图： 综上我们已经得出： 123456789function Person() &#123; &#125;var person = new Person()console.log(person.__proto__ == Person.prototype) // trueconsole.log(Person.prototype.constructor == Person) // true// 随便学习一个ES5的方法，可以获得对象的原型console.log(Object.getPrototype(person) === Person.prototype) 了解了构造函数、实例原型和实例之间的关系，下面我们来讲讲实例和原型的关系。 实例与原型当读取实例的属性时，如果找不到。就会查找与对象关联的原型中的属性。如果还查不到。就去找原型的原型，一直找到最顶层为止。 举个例子： 12345678910111213function Person() &#123; &#125;Person.prototype.name = 'Kevin'var person = new Person()person.name = 'Daisy'console.log(person.name) // Daisydelete person.nameconsole.log(person.name) // Kevin 在这个例子中，我们给实例对象person添加了name属性。当我们打印person.name的时候，结果自然为Daisy。 但是当我们删除了person的name属性时，读取了person.name。从person对象中找不到name属性就会从person的原型也就是person.__proto__，也p就是Person.prototype中查找，幸运的是我们找到了name属性，结果为Kevin。 但是万一没找到呢？原型的原型又是什么？ 原型的原型在前面，我们已经讲了原型也是一个对象，既然是对象，我们就可以用最原始的方式创建它，那就是： 123var obj = new Object()obj.name = 'Kevin'console.log(obj.name) // Kevin 其实原型对象就是通过Object构造函数生成的，结合之前讲的，实例的__proto__指向构造函数的prototype，所以我们再更新下关系图： 原型链那Object.prototype的原型呢？ null，我们可以打印： 1console.log(Object.prototype.__proto__ === null) // true 然而null究竟代表什么呢？ 引用阮一峰老师的 《undefined与null的区别》 就是： null 表示“没有对象”，即该处不应该有值。 所以Object.prototype.__proto__的值为null跟Object.prototype没有原型。其实表达一个意思。 所以查找属性的时候查到Object.prototype就可以停止查找了。 最后一张关系图也可以更新为： (https://github.com/mqyqingfeng/Blog/raw/master/Images/prototype5.png) 随便还有说一下，图中由互相关联的原型组成的链状结构就是原型链，也就是蓝色的这条线。 补充最后给大家补充三个不容易注意到的地方： constructor 首先是constructor属性，我们看个例子： 12345function Person() &#123; &#125;var person = new Person()console.log(person.constructor === Person) // true 当获取person.constructor时，其实person并没有constructor属性，当不能读取到constructor属性时，会从person的原型也就是Person.prototype中读取，正好原型中有该属性，所以: 1person.constructor === Person.prototype.constructor __proto__ 其次是__proto__，绝大部分浏览器都支持这个非标准的方法访问原型，然而它并不存在于Person.prototype中，实际上，它是来自于Objcet.prototype。与其说是一个属性，不如说是一个getter/setter，当使用obj.__proto__时，可以理解成返回了Object.getPrototypeOf(obj)。 真的是继承吗？ 最后是继承，前面我们讲到‘每个对象都会从原型继承属性’，实际上，继承是一个十分具有迷惑性的说法，引用《你不知道的JavaScript》中的话，就是： 继承意味着复制操作，然而JavaScript默认并不会复制对象的属性，相反，JavaScript只是再两个对象之间创建一个关联，这样，一个对象就可以通过委托访问另一个对象的属性和函数，所以与其叫继承，委托的说法反而更准确些。]]></content>
  </entry>
  <entry>
    <title><![CDATA[ES6系列之模块加载方案]]></title>
    <url>%2F2019%2F09%2F20%2FES6%E7%B3%BB%E5%88%97%E4%B9%8B%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[我们重点介绍以下四种模块加载规范： AMD CMD CommonJS ES6模块 最后延伸讲下Babel的编译和webpack的打包原理 require.js在了解AMD规范之前，我们先来看看require.js的使用方式。 项目目录为： 12345678* project/ * index.html * vender/ * main.js * require.js * add.js * square.js * multiply.js index.html 的内容如下： 12345678910&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;require.js&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Content&lt;/h1&gt; &lt;script data-main="vender/main" src="vender/require.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; data-main=&quot;vender/main&quot; 表示主模块是 vender 下的 main.js。 main.js 的配置如下： 12345// main.jsrequire(['.add', './square'], function(addModule, squareModule) &#123; console.log(addModule.add(1, 2)) console.log(squareModule.square(3))&#125;) require的第一个参数表示依赖的模块的路径，第二个参数表示此模块的内容。 由此可以看，主模块依赖 add 模块和 square 模块。 我们看下 add 模块即 add.js 的内容： 1234567891011// add.jsdefine(function() &#123; console.log('加载了add模块') var add = function(x, y) &#123; return x + y &#125; return &#123; add: add &#125;&#125;) require.js 为全局添加了define函数，你只要按照这种约定的方式书写这个模块即可。 那如果依赖的模块又依赖了其他模块呢？ 我们来看看主模块依赖的 square 模块， square 模块的作用是求出一个数字的平方，比如输入3就返回9，该模块依赖一个乘法模块，该乘法模块即 multiply.js 的代码如下： 1234567891011// multiply.jsdefine(function() &#123; console.log('加载了multiply模块') var mutiply = function(x, y) &#123; return x * y &#125; return &#123; multiply: multiply &#125;&#125;) 而 square 模块就要用到 multiply 模块，其实写法跟 main.js 添加依赖模块一样： 123456789// square.jsdefine(['./multiply'], function(multiplyModule) &#123; console.log('加载square模块') return &#123; square: function(num) &#123; return multiplyModule.multiply(num, num) &#125; &#125;&#125;) require.js会自动分析依赖关系，将需要加载的模块正确加载。 而如果我们在浏览器中打开 index.html，打印的顺序为： 12345加载了 add 模块加载了 multiply 模块加载了 square 模块29 AMD在上节，我们说了这样一句话： requirejs 为全局添加了 define 函数，你只要按照这种约定的方式书写这个模块即可。 那这个约定的书写方式是指什么呢？ 指的便是 The Asynchronous Module Definition (AMD) 规范。 所有其实AMD是RequireJS在推广过程中对模块定义的规范化产出。 你去看 AMD 规范 的内容，其主要内容就是定义define函数该如何书写，只要你按照这个规范书写模块和依赖，require.js就能正确的进行解析。 sea.js在国内，经常与AMD被一起提起的还有CMD，那CMD又是什么呢？我们从sea.js的使用开始说起。 文件目录与 requirejs 项目目录相同: 12345678* project/ * index.html * vender/ * main.js * require.js * add.js * square.js * multiply.js index.html 的内容如下： 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;sea.js&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Content&lt;/h1&gt; &lt;script src="vender/sea.js"&gt;&lt;/script&gt; &lt;script&gt; // 在页面中加载主模块 seajs.use("./vender/main"); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; main.js 的内容如下： 12345678// main.jsdefine(function(require, export, module) &#123; var addModule = require('./add') console.log(addModule.add(1, 1)) var squareModule = require('./square') console.log(squareModule.square(3))&#125;) add.js的内容如下： 1234567891011// add.jsdefine(function(require, exports, module) &#123; console.log('加载了add模块') var add = function(x, y) &#123; return x * y &#125; module.exports= &#123; add: add &#125;&#125;) square.js的内容如下： 12345678910defien(function(require, exports, module) &#123; console.log('加载了square模块') var multiplyModule = require('./multiply') module.exports = &#123; square: function(num) &#123; return multiplyModule.multiply(num, num) &#125; &#125;&#125;) multiply.js 的内容如下： 123456789define(function(require, exports, module) &#123; console.log('加载了 multiply 模块') var multiply = function(x, y) &#123; return x * y; &#125;; module.exports = &#123; multiply: multiply &#125;;&#125;); 跟第一个例子是同样的依赖结果，即main依赖add和square，square又依赖multiply。 而如果我们在浏览器中打开 index.html，打印的顺序为： 12345加载了 add 模块2加载了 square 模块加载了 multiply 模块9 CMD与AMD一样，CMD其实就是SeaJS在推广过程中对模块定义的规范化产出。 你去看 CMD 规范的内容，主要内容就是描述该如何定义模块，如何引入模块，如何导出模块，只要你按照这个规范书写代码，sea.js 就能正确的进行解析。 AMD与CMD的区别从sea.js和require.js的例子可以看出： CMD推崇依赖就近，AMD推崇依赖前置。看两个项目中的main.js： 123456// require.js 例子中的mian.js// 依赖必须一开始就写好require(['./add', './square'], function(addModule, squareModule) &#123; console.log(addModule.add(1, 1)) console.log(squareModule.square(3))&#125;) 123456789// sea.js例子中的main.jsdefine(function(require, exports, module) &#123; var addModule = require('./add') console.log(addModule.add(1, 1)) // 依赖可以就近书写 var squareModule = require('./square') console.log(squareModule.square(3))&#125;) 对于依赖的模块，AMD是提前执行，CMD是延迟执行。看两个项目中的打印顺序： 12345678910111213// require.js加载了 add 模块加载了 multiply 模块加载了 square 模块29// sea.js加载了 add 模块2加载了 square 模块加载了 multiply 模块9 AMD是将需要使用的模块先加载完再执行代码，而CMD是在require的时候才去加载模块文件，加载完再接着执行。 CommonJSAMD和CMD都是用于浏览器的模块规范，而在服务器端比如node，采用的则是CommonJS规范。 导出模块的方式： 12345var add = function(x, y) &#123; return x + y&#125;module.exports.add = add 引入模块的方式： 12var add = require('./add.js')console.log(add.add(1, 1)) 我们将之前的例子改成CommonJS规范： 123456// main.jsvar add = require('./add.js')console.log(add.add(1, 1))var square = require('./square.js')console.log(square.square(3)) 12345678// add.jsconsole.log('加载了add模块')var add = function(x, y) &#123; return x + y&#125;module.exports.add = add 12345678// multiply.jsconsole.log('加载了multiply模块')var multiply = function(x, y) &#123; return x * y&#125;module.exports.multiply = multiply 12345678910// square.js console.log('加载了square模块')var multiply = require('./multiply.js')var square = function(num) &#123; return multiply.multiply(num, num)&#125;module.exports.square = square 如果我们执行 node main.js，打印的顺序为： 12345加载了 add 模块2加载了 square 模块加载了 multiply 模块9 跟 sea.js 的执行结果一致，也是在 require 的时候才去加载模块文件，加载完再接着执行。 CommonJS与AMD ommonJS 规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。 AMD规范则是非同步加载模块，允许指定回调函数。 由于 Node.js 主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以 CommonJS 规范比较适用。 但是，如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器端一般采用 AMD 规范。 ES6ECMAScript2015 规定了新的模块加载方案。 导出模块的方式： 12345var firstName = 'Michael'var lastName = 'Jackson'var year = 1958export &#123; firstName, lastName, year&#125; 引入模块的方式： 1import &#123; firstName, lastName, year &#125; from './profile' 我们再将上面的例子改成ES6规范： 目录结构与 requirejs 和 seajs 目录结构一致。 12345678910&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;ES6&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Content&lt;/h1&gt; &lt;script src="vender/main.js" type="module"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 注意！浏览器加载 ES6 模块，也使用 &lt;script&gt; 标签，但是要加入 type=&quot;module&quot; 属性。 123456// main.jsimport &#123; add &#125; from './add.js'console.log(add(1, 1))import &#123; square &#125; from './square.js'console.log(square(3)) 12345678// add.jsconsole.log('加载了add模块')var add = function(x, y) &#123; return x + y&#125;export &#123; add &#125; 12345678// multiply.jsconsole.log('加载了multiply模块')var multiply = function(x, y) &#123; return x * y&#125;export &#123; multiply &#125; 12345678910// square.jsconsole.log('加载了square模块')import &#123; multiply &#125; from './multiply.js'var square = function(num) &#123; return multiply(num, num)&#125;export &#123; square &#125; 值得注意的，在Chrome中，如果直接打开，会报跨域错误，必须开启服务器，保证文件同源才可以有效果。 为了验证这个效果你可以： 1cnpm install http-server -g 然后进入该目录，执行 1http-server 在浏览器打开 http://localhost:8080/ 即可查看效果。 打印的顺序为： 12345加载了 add 模块加载了 multiply 模块加载了 square 模块29 跟 require.js 的执行结果是一致的，也就是将需要使用的模块先加载完再执行代码。 ES6与Com模拟JS引用阮一峰老师的 《ECMAScript 6 入门》： 它们有两个重大差异。 CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。 CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。 第二个差异可以从两个项目的打印结果看出，导致这种差别的原因是： 因为 CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。 重点解释第一个差异。 CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。 举个例子： 12345678910// 输出模块 counter.jsvar counter = 3function incCounter() &#123; counter++&#125;module.exports = &#123; counter: counter, incCounter: incCounter&#125; 123456// 引入模块main.jsvar mod = require('./counter')console.log(mod.counter) // 3mod.incCounter()console.log(mod.counter) // 3 counter.js模块加载以后，它的内部变化就影响不到输出的mod.counter了，这是因为mod.counter是一个原始类型的值，会被缓存。 但是如果修改counter为一个引用类型的话： 12345678910111213// 输出模块 counter.jsvar counter = &#123; value: 3&#125;function incCounter() &#123; counter.value++&#125;module.exports = &#123; couter: counter, incCounter: incCounter,&#125; 123456// 引入模块main.jsvar mod = require('./counter.js')console.log(mod.counter.value) // 3mod.incCounter()console.log(mod.counter.value); // 4 value是会发生改变的。不过也可以说这是‘值的拷贝’，只是对于引用类型而言，值指的其实是引用。 而如果我们将这个例子改成ES6： 12345// counter.jsexport let counter = 3export function incCounter() &#123; counter++&#125; 12345// main.jsimport &#123; counter, incCounter &#125; from './counter'console.log(counter) // 3incCOunter()console.log(counter) // 4 这是因为 ES6模块的运行机制与CommonJS不一样，JS引擎对脚本静态分析的时候，遇到模块加载命令import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6的import有点像Unix系统的符号链接。原始值变了。import加载的值也会跟着变。因此，ES6模块是动态引用。并且不会缓存值，模块里面的变量绑定其所在的模块。 Babel鉴于浏览器支持度的问题，如果要使用ES6的语法，一般都会借助Babel，可对于import和export而言，只借助Babel就可以吗？ 让我们看看Babel是怎样编译import和export语法的。 123456// ES6var firstName = 'Michael'var lastName = 'Jackson'var year = 1958export &#123; firstName, lastName, year &#125; 12345678910111213// Babel编译后'use strict'Object.defineProperty(exports, '__esModule', &#123; value: true&#125;)var firstName = 'Michael'var lastName = 'Jackson'var year = 1958exports.firstName = firstNameexports.lastName = lastNameexports.year = year 是不是感觉有那么点奇怪？编译后的语法更像CommonJS规范，再看import的编译结果： 12// ES6import &#123; firstName, lastName, year &#125; 1234// Babel编译后'use strict'var _profile = require('./profile') 你会发现Babel只是把ES6模块语法转为CommonJS模块语法，然而浏览器是不支持这种模块语法的，所以直接跑在浏览器会报错，如果想在浏览器中运行，还是需要使用打包工具将代码打包。 webpackBabel将ES6模块转为CommonJS后，webpack又是怎么做的打包呢？它该如何将这些文件打包在一起，从而能保证正确的处理依赖，以及能在浏览器中运行呢？ 首先为什么浏览器中不支持CommonJS语法呢？ 这是因为浏览器环境中并没有module、exports、require等环境变量。 换句话说，webpack打包后的文件之所以在浏览器中能运行，就是靠模拟了这些变量的行为。 那怎么模拟呢？ 我们以CommonJS项目中的square.js为例，它依赖了multiply模块： 1234567console.log('加载了square模块')var multiply = require('./multiplu.js')var square = function(num) &#123; return multiply.multiply(num, num)&#125; 那webpack又会将CommonJS项目的代码打包成什么样子呢？我写了一个精简的例子，你可以直接复制到浏览器中查看效果： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// 自执行函数(function(modules) &#123; // 用于储存已经加载过的模块 var installedModule = &#123;&#125; function require(moduleName) &#123; if (instanlledModules[moduleName]) &#123; return installedModules[moduleName].exports &#125; var module = installedModules[moduleName] = &#123; exports: &#123;&#125; &#125; modules[moduleName](module, module.exports, require) return module.exports &#125; // 加载主模块 return require('main')&#125;)(&#123; 'main': function(module, exports, require) &#123; var addModule = require('./add') console.log(addModule.add(1, 1)) var squareModule = require('./square') console.log(squareModule.square(3)) &#125;, './add': function(module, exports, require) &#123; console.log('加载了add模块') module.exports = &#123; add: function(x, y) &#123; return x + y &#125; &#125; &#125;, './square': function(module, exports, require) &#123; console.log('加载了square模块') var multiply = require('./multiply') module.exports = &#123; square: function(num) &#123; return multiply.multiply(num, num) &#125; &#125; &#125;, './multiply': function(module, exports, require) &#123; console.log('加载了multiply模块') module.exports = &#123; multiply: function(x, y) &#123; return x * y &#125; &#125; &#125;&#125;) 最终的执行结果为： 12345加载了 add 模块2加载了 square 模块加载了 multiply 模块9]]></content>
  </entry>
  <entry>
    <title><![CDATA[ES6系列之私有变量的实现]]></title>
    <url>%2F2019%2F09%2F20%2FES6%E7%B3%BB%E5%88%97%E4%B9%8B%E7%A7%81%E6%9C%89%E5%8F%98%E9%87%8F%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[在阅读《ECMAScript6入门》的时候，零散的看到有私有变量的实现，所有在此总结一篇。 约定实现： 123456789101112131415class Example &#123; constructor() &#123; this._private = 'private' &#125; getName() &#123; return this._private &#125;&#125;var ex = new Example()console.log(ex.getName()) // privateconsole.log(ex._private) // private 优点： 写法简单 调试方便 兼容性好 缺点： 外部可以访问和修改 语言没有配合的机制，如for-in语句会将所有属性枚举出来 命名冲突 闭包实现一： 123456789101112class Example() &#123; constructor() &#123; var _private = '' _private = 'private' this.getName = function() &#123; return _private &#125; &#125;&#125;var ex = new Example()console.log(ex.getName()) // privateconsole.log(ex._private) // undefined 优点： 无命名冲突 外部无法访问和修改 缺点： constructor的逻辑变得复杂。构造函数应该只做对象初始化的事情，现在为了实现私有变量，必须包含部分方法的实现，代码组织上略不清晰。 方法存在于实例，而非原型上，子类也无法使用super调用。 构建增加一点点开销。 实现二： 12345678910111213141516171819const Examole = (function() &#123; var _private = '' class Example &#123; constructor() &#123; _private = 'private' &#125; getName() &#123; return _private &#125; &#125; return Example&#125;)()var ex = new Example()console.log(ex.getName()) // privateconsole.log(ex._private) // undefined 优点： 无命名冲突 外部无法访问和修改 缺点： 写法有一点复杂 构建增加一点点开销 Symbol实现： 123456789101112131415161718const Example = (function() &#123; var _private = Symbol('private') class Example &#123; constructor() &#123; this[_private] = 'privatw' &#125; getName() &#123; return this[_private] &#125; &#125; return Example&#125;)()var ex = new Example()console.log(ex.getName()) // privateconsole.log(ex.name) // undefined 优点： 无命名冲突 外部无法访问和修改 无性能损失 缺点： 写法稍微复杂 兼容性也还好 WeakMap实现： 123456789101112131415const _private = new WeakMap()class Example &#123; constructor() &#123; _private.set(this, 'private') &#125; getName() &#123; return _private.get(this) &#125;&#125;var ex = new Example()console.log(ex.getName()) // privateconsole.log(ex.name) // undefined 如果这样写，你可能觉得封装性不够，你也可以这样写： 12345678910111213141516171819const Example = (function() &#123; var _private = new WeakMap() class Example &#123; constructor() &#123; _private.set(this, 'private') &#125; getName() &#123; return _private.get(this) &#125; &#125; return Example&#125;)()var ex = new Example()console.log(ex.getName()) // privateconsole.log(ex.name) // undefined 优点： 无命名冲突 外部无法访问和修改 缺点： 写法比较麻烦 兼容性有点问题 有一定性能代价 最新提案12345678910111213class Point &#123; #x; #y; constructor(x, y) &#123; this.#x = x; this.#y = y; &#125; equals(point) &#123; return this.#x === point.#x &amp;&amp; this.#y === point.#y; &#125;&#125; 那么为什么不直接使用 private 字段呢？比如说这样： 1234567class Foo &#123; private value; equals(foo) &#123; return this.value === foo.value; &#125;&#125; 简单点来说，就是嫌麻烦，当然也有性能上的考虑…… 举个例子，如果我们不使用 #，而是使用 private 关键字： 123456789101112class Foo &#123; private value = '1'; equals(foo) &#123; return this.value === foo.value; &#125;&#125;var foo1 = new Foo();var foo2 = new Foo();console.log(foo1.equals(foo2)); 在这里我们新建了两个实例，然后将 foo2 作为参数传入了 foo1 的实例方法中。 那么我们可以获取 foo2.value 的值吗？如果我们直接 foo2.value 肯定是获取不到值的，毕竟是私有变量，可是 equals 是 Foo 的一个类方法，那么可以获取到的吗？ 答案是可以的。 其实这点在其他语言，比如说 Java 和 C++ 中也是一样的，类的成员函数中可以访问同类型实例的私有变量，这是因为私有是为了实现“对外”的信息隐藏，在类自己内部，没有必要禁止私有变量的访问，你也可以理解为私有变量的限制是以类为单位，而不是以对象为单位，此外这样做也可以为使用者带来便利。 既然获取值是可以的，那么打印的结果应该为 true，但是如果我们传入的值不是 Foo 的实例，而是一个其他对象呢？ 12345var foo1 = new Foo();console.log(foo1.equals(&#123; value: 2&#125;)); 当然这里代码也是可以正常运行的，但是对于编译器来说，就有一点麻烦了，因为编译器不知道 value 到底是 foo 的正常属性还是私有属性，所以编译器需要做判断，先判断 foo 是不是 Foo 的实例，然后再接着获取值。 这也意味着每次属性访问都需要做这样一个判断，而引擎已经围绕属性访问做了高度优化，懒得改，而且还降低速度。 不过除了这个工作之外，还会有一些其他的内容需要考虑，比如说： 你必须将私有的 key 编码进每个词法环境 for in 可以遍历这些属性吗？ 私有属性和正常属性同名的时候，谁会屏蔽谁？ 怎么防止私有属性的名称不被探测出来。 关于使用 # 而不使用 private 更多的讨论可以参考这个 Issue。 当然这些问题都可以被解决啦，就是麻烦了点。 而如果你选择 #，实现的方式将跟 JavaScript 对象属性完全没有关系，将会使用 private slots 的方式以及使用一个新的 slot 查找语法，总之就是会比 private 的实现方式简单很多。]]></content>
  </entry>
  <entry>
    <title><![CDATA[ES6系列之defineProperty与proxy]]></title>
    <url>%2F2019%2F09%2F19%2FES6%E7%B3%BB%E5%88%97%E4%B9%8BdefineProperty%E4%B8%8Eproxy%2F</url>
    <content type="text"><![CDATA[我们或多或少都听过数据绑定这个词，数据绑定的关键在于监听数据的变化，可是对于这样一个对象：var obj = { value: 1 }，我们该怎么知道obj发生了改变呢？ definePropertyES5提供Object.defineProperty方法，该方法可以在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回这个对象。 语法：Object.defineProperty(obj, prop, descriptor) 参数 12345obj: 要在其上定义属性的对象。prop: 要定义或修改的属性的名称。descriptor: 将被定义或修改的属性的描述符 举个例子： 12345678var obj = &#123;&#125;Object.defineProperty(obj, 'num', &#123; value: 1, writable: true, enumerable: true, configurable: true&#125;)// 对象obj拥有属性num，值为1 虽然我们可以直接添加属性与值，但是使用这种方式，我们能进行更多的配置。 函数的第三个参数descriptor所表示的属性描述符有两种形式：数据描述符和存取描述符。 两者均具有以下两种键值： configurable：当且仅当该属性的configurable为true时，该属性描述符才能够被改变，也能够被删除。默认为false。 enumerable：当且仅当该属性的enumerable为true时，该属性才能够出现在对象的枚举属性中，默认为false。 数据描述符同时具有以下可选键值： value: 该属性对应的值。可以是任何有效的JavaScript值（数值、对象、函数等），默认为undefined。 writable：当且仅当该属性的writable为true时，该属性才能被赋值运算符改变，默认为false。 存取描述符同时具有以下可选键值： get:一个给属性提供getter的方法，如果没有getter则为undefined，该方法返回值被用来用作属性值，默认为undefined set：一个给属性提供setter的方法，如果没有setter则为undefined，该方法将接受唯一参数，并将该参数的新值分配给该属性，默认为undefined 值得注意的是：属性描述符必须是数据描述符或者存取描述符两种之一，不能同时是两者，这就意味着你可以： 123456Object.defineProperty(&#123;&#125;, "num", &#123; value: 1, writable: true, enumerable: true, configurable: true&#125;); 也可以： 1234567891011var value = 1;Object.defineProperty(&#123;&#125;, "num", &#123; get : function()&#123; return value; &#125;, set : function(newValue)&#123; value = newValue; &#125;,a enumerable : true, configurable : true&#125;); 但是不可以： 1234567// 报错Object.defineProperty(&#123;&#125;, "num", &#123; value: 1, get: function() &#123; return 1; &#125;&#125;); 此外，所有的属性描述符都是非必须的，但是 descriptor 这个字段是必须的，如果不进行任何配置，你可以这样： 12var obj = Object.defineProperty(&#123;&#125;, "num", &#123;&#125;);console.log(obj.num); // undefined Setter和Getter之所以讲到defineProperty，是因为我们要使用存取描述符种的get和set，这两种方法又被称为getter和setter。由于getter和setter定义的属性称为存取器属性。 当程序查询存取器属性的值时，JavaScript调用getter方法，这个方法的返回值就是属性存取表达式的值。当程序设置一个存取器属性的值时，JavaScript调用setter方法，将赋值表达式右侧的值当做参数传入setter。从某种意义上讲，这个方法负责设置属性值，可以忽略setter方法的返回值。 举个例子： 1234567891011121314var obj = &#123;&#125;, value = nullObject.defineProperty(obj, 'nul', &#123; get: function() &#123; console.log('执行了get操作') return value &#125;, set: function() &#123; console.log('执行了set操作') value = newValue &#125;&#125;)obj.num = 1 // 执行了set操作console.log(obj.num) // 执行了get操作 这不就是我们要的监控数据改变的方法吗？我们再来封装一下： 12345678910111213141516171819202122function Archiver() &#123; var value = null var archive = [] Object.defineProperty(this, 'num', &#123; get: function() &#123; console.log('执行了get操作') return value &#125;, set: function(value) &#123; console.log('执行了set操作') value = value archive.push(&#123; val: value &#125;) &#125; &#125;) this.getArchive = function() &#123; return archive &#125;&#125;var arc = new Archiver()arc.num = 11; // 执行了 set 操作arc.num = 13; // 执行了 set 操作console.log(arc.getArchive()); // [&#123; val: 11 &#125;, &#123; val: 13 &#125;] watch API既然可以监控数据的改变，那我可以这样设想，即当数据改变的时候，自动进行渲染工作。举个例子： HTML 中有个 span 标签和 button 标签 12&lt;span id="container"&gt;1&lt;/span&gt;&lt;button id="button"&gt;点击加 1&lt;/button&gt; 当点击按钮的时候，span标签里的值加1。 传统的做法是： 1234document.getElementById('button').addEventListener('click', function() &#123; var container = document.getElementById('container') container.innerHTML = Number(container.innerHTML) + 1&#125;) 如果使用defineProperty： 1234567891011121314151617181920var obj = &#123; value: 1&#125;// 储存obj.value的值var value = 1Object.defineProperty(obj, 'value', &#123; get: function() &#123; return value &#125;, set: function(newValue) &#123; value = newValue document.getElementById('container').innerHTML = newValue &#125;&#125;)document.getElementById('button').addEventListener('click', function() &#123; obj.value += 1&#125;) 代码看似增多了，但是当我们需要改变span标签的值，直接修改obj.value的值就可以了。 然而，现在的写法，我们还需要单独声明一个变量存储obj.value的值，因为如果你在set中直接obj.value = newValue就会陷入无限的循环中。此外，我们可能需要监控很多属性值的改变，要是一个一个写，也是很累的，所有我们简单的写了个watch函数。使用效果如下： 1234567891011var obj = &#123; value: 1&#125;watch(obj, 'value', function(newvalue) &#123; document.getElementById('container').innerHTML = newvalu&#125;)document.getElementById('button').addEventListener('click', function() &#123; obj.value += 1&#125;) 现在我们来写这个watch函数： 1234567891011121314151617181920(function() &#123; var root = this function watch(obj, name, func) &#123; var value = obj[name] Object.defineProperty(obj, name, &#123; get: function() &#123; return value &#125;, set: function() &#123; value = newValue func(value) &#125; &#125;) if (value) obj[name] = value &#125; this.watch = watch&#125;) 现在我们已经可以监控对象属性值的改变，并且可以根据属性值的改变，添加回调函数。 proxy使用defineProperty只能重新定义读取(get)和设置(set)行为，到了ES6，提供了Proxy。可以重定义更多的行为，比如in、delete、函数调用等更多行为。 Proxy这个词的原意是代理，用在这里表示由它来‘代理’某些操作。ES6原生提供Proxy构造函数，用来生成Proxy实例。我们来看它的语法: 1var proxy = new Proxy(target, handle) proxy对象的所有用法，都是上面这种形式，不同的只是handler参数的写法。其中，new Proxy()表示生成一个Proxy实例，target参数表示所有拦截的目标对象，handler参数也是一个对象，用来定制拦截行为： 12345678910111213var proxy = new Proxy(&#123;&#125;, &#123; get: function(obj, prop) &#123; console.log('设置get操作') return obj[prop] &#125;, set: function(obj, prop, value) &#123; console.log('设置set操作') obj[prop] = value &#125;&#125;)proxy.time = 35 // 设置set操作console.log(proxy.time) // 设置get操作 35 除了get和set之外，proxy可以拦截多达13种操作，比如has(target, propKey)，可拦截propKey in proxy的操作，返回一个布尔值。 12345678910111213// 使用has方法隐藏某些属性，不被in运算符发现var handler = &#123; has (target, key) &#123; if (key[0] === '_') &#123; return false &#125; return key in target &#125;&#125;var target = &#123; _prop: 'foo', prop: 'foo' &#125;var proxy = new Proxy(target, handler)console.log('_prop' in proxy) // false 又比如说apply方法拦截函数的调用、call和apply操作。 apply方法可以接受三个参数，分别是目标对象、目标对象的上下文对象(this)和目标对象的参数数值，不过这里我们简单演示一下： 123456789var target = function () &#123; return 'I am the target' &#125;var handler = &#123; apply: function () &#123; return 'I am the proxy' &#125;&#125;var p = new Proxy(target, handler)p() // 'I am the target' 又比如说 ownKeys 方法可以拦截对象自身属性的读取操作。具体来说，拦截以下操作： Object.getOwnPropertyNames() Object.getOwnPropertySymbols() Object.keys() 12345678910111213141516let target = &#123; _bar: 'foo', _prop: 'bar', prop: 'baz'&#125;let handler = &#123; ownKeys (target) &#123; return Reflect.ownKeys(target).filter(key =&gt; key[0] !== '_') &#125;&#125;let proxy = new Proxy(target, handler)for (let key of Object.keys(proxy)) &#123; console.log(target[key])&#125; 值得注意的是，proxy 的最大问题在于浏览器支持度不够，而且很多效果无法使用 poilyfill 来弥补。 watch API优化我们使用proxy再来写一下watch函数。 12345678910111213141516171819202122232425262728293031(function() &#123; var root = this function watch(target, func) &#123; var proxy = new Proxy(target, &#123; get: function(target, prop) &#123; return target[prop] &#125;, set: function(target, prop, value) &#123; target[prop] = value func(prop, value) &#125; &#125;) return proxy &#125; this.watch = watch&#125;)()var obj = &#123; value: 1&#125;var newObj = watch(obj, function(key, newvalue) &#123; if (key == 'value') document.getElementById('container').innerHTML = newvalue&#125;)document.getElementById('button').addEventListener('click', function() &#123; newObj.value += 1&#125;) 我们也可以发现，使用 defineProperty 和 proxy 的区别，当使用 defineProperty，我们修改原来的 obj 对象就可以触发拦截，而使用 proxy，就必须修改代理对象，即 Proxy 的实例才可以触发拦截。]]></content>
  </entry>
  <entry>
    <title><![CDATA[ES6系列之异步处理实战]]></title>
    <url>%2F2019%2F09%2F19%2FES6%E7%B3%BB%E5%88%97%E4%B9%8B%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[我们已查找指定目录下的最大文件为例，感受从： 回调函数 -&gt; Promise -&gt; Generator -&gt; Async 异步处理方式的改变。 API介绍为了实现这个功能，我们需要用到几个Nodejs的API，所有我们来简单介绍下。 fs.readdir：方法用于读取目录，返回一个包含文件和目录的数组。 fs.stat: 方法的参数是一个文件或目录，它产生一个对象，该对象包含了该文件或目录的具体信息。此外，该对象还有一个isFile()方法可以判断正在处理的到底是一个文件，还是一个目录。 思路分析我们基本的实现思路就是： 用fs.readdir获取指定目录的内容信息 循环遍历内容信息，使用fs.stat获取该文件或者目录的具体信息 将具体信息储存起来 当全部储存起来，筛选其中的是文件的信息 遍历比较，找出最大文件 获取并返回最大文件 回调函数123456789101112131415161718192021222324252627282930313233343536var fs = require('fs')var path = require('path')function findLargest(dir, cb) &#123; // 读取目录下的所有文件 fs.readdir(dir, function(er, files) &#123; if (er) return cb(er) var counter = files.length var errored = false var stats = [] files.forEach(function(file, index) &#123; // 读取文件信息 fs.stat(path.join(dir, file), function(er, stat) &#123; if (errored) return if (er) &#123; errored = true return cb(er) &#125; stats[index] = stat // 事先算好有多少个文件，读取1个文件信息，计数减一，当为0时，说明读取完毕 if (--couner == 0) &#123; var largest = stats.filter(function(stat) &#123; return stat.isFile()&#125;) .reduce(function(prev, next) &#123; if (prev.size &gt; next.size) return prev return next &#125;) cb(null, files[stats.indexOf(largest)]) &#125; &#125;) &#125;) &#125;)&#125; 使用方式为： 12345// 查找当前目录最大的文件findLargest('./', function(er, filename) &#123; if (er) return console.error(er) console.log('largest file was:', filename)&#125;) Promise123456789101112131415161718192021222324252627282930313233343536var fs = require('fs')var path = require('path')var readDir = function(dir) &#123; return new Promise(function(resolve, reject) &#123; fs.readdir(dir, function(err, files) &#123; if (err) reject(err) resolve(files) &#125;) &#125;)&#125;var stat = function(path) &#123; return new Promise(function(resolve, reject) &#123; fs.stat(path, function(err, stat) &#123; if (err) reject(err) resolve(stat) &#125;) &#125;)&#125;function findLargest(dir) &#123; return readDir(dir).then(function(files) &#123; let promises = files.map(file =&gt; stat(path.join(dir, file))) return Promise.all(promises).then(function(stats) &#123; return &#123; stats, files &#125; &#125;) &#125;).then(data =&gt; &#123; let latgest = data.stats.filter(function(stat) &#123; return stat.isFile() &#125;) .reduce((pre, next) =&gt; &#123; if (prev.size &gt; next.size) return prev return next &#125;) return data.files[data.stats.indexOf(largest)] &#125;)&#125; 使用方式为： 1234567findLargest('./').then(function(filename) &#123; console.log('largest file was:', filename)&#125;).catch(function() &#123; console.log(error)&#125;) Generator12345678910111213141516171819202122232425262728293031323334353637var fs = require('fs')var path = require('path')var co = require('co')var readDir = function(dir) &#123; return new Promise(function(resolve, reject) &#123; fs.readdir(dir, function(err, files) &#123; if (err) reject(err) resolve(files) &#125;) &#125;)&#125;var stat = function(path) &#123; return new Promise(function(resolve, reject) &#123; fs.stat(path, function(err, stat) &#123; if (err) reject(err) resolve(stat) &#125;) &#125;)&#125;function* findLargest(dir) &#123; var files = yield readDir(dir) var stats = yield files.map(function(file) &#123; return stat(path.join(dir, file)) &#125;) let largest = stats.filter(function(stat) &#123; return stat.isFile() &#125;) .reduce((prev, next) =&gt; &#123; if (prev.size &gt; next.size) return prev return next &#125;) return files[stats.indexOf(largest)]&#125; 使用方式为： 1234567co(findLargest, './').then(function(filename) &#123; console.log('largest file was:', filename)&#125;).catch(function() &#123; console.log(error)&#125;) Async12345678910111213141516171819202122232425262728293031323334var fs = require('fs')var path = require('path')var readDir = function(dir) &#123; return new Promise(function(resolve, reject) &#123; fs.readdir(dir, function(err, files) &#123; if (err) reject(err) resolve(files) &#125;) &#125;)&#125;var stat = funcion(path) &#123; return new Promise(function(resolve, reject) &#123; fs.stat(path, function(err, stat) &#123; if (err) reject(err) resolve(stat) &#125;) &#125;)&#125;async function findLargest(dir) &#123; var files = await readDir(dir) let promises = files.map(file =&gt; stat(path.join(dir, file))) var stats = await Promise.all(promises) let largest = stats.filter(function(stat) &#123; return stat.isFile() &#125;) .reduce((prev, next) =&gt; &#123; if (prev.size &gt; next.size) return prev return next &#125;) return files[stats.indexOf(largest)]&#125; 使用方式为： 1234567findLargest('./').then(function(filename) &#123; console.log('largest file was', filename)&#125;).catch(function() &#123; console.log(error)&#125;)]]></content>
  </entry>
  <entry>
    <title><![CDATA[ES6系列之Async]]></title>
    <url>%2F2019%2F09%2F16%2FES6%E7%B3%BB%E5%88%97%E4%B9%8BAsync%2F</url>
    <content type="text"><![CDATA[ES2017标准引入了async函数，使得异步操作变得更加方便。 在异步处理上，async函数就是Generator的语法糖。 举个例子： 1234567891011// 使用generatorvar fetch = require('node-fetch')var co = require('co')function* gen() &#123; var r1 = yield fetch('https://api.github.com/users/github') var json1 = yield r1.json() console.log(json1.bio)&#125;co(gen) 当你使用async时： 12345678910// 使用asyncvar fecth = require('node-fetch')var fetchData = aysnc function() &#123; var r1 = await fetch('https://api.github.com/users/github') var json1 = await r1.json() console.log(json1.bio)&#125;fetchData() 其实async函数的实现原理，就是将generator函数和自动执行器包装在一个函数里。 12345678910async function fn(args) &#123; // ...&#125;// 等同于function fn(args) &#123; return spawn(function* () &#123; //... &#125;)&#125; spawn函数指的是自动执行器，就比如说co。 再加上async函数返回一个Promise对象，你也可以理解为aysnc函数是基于Promise和Generator的一层封装。 async与 Promise严谨的说，async是一种语法，Promise是一个内置对象，两者并不具备可比性，更何况async函数返回一个Promise对象…… 这里主要是展示一些场景，使用async会比使用Promise更优雅的处理异步流程。 代码更加简洁 1234567891011121314// 实例1function fetch() &#123; return ( fetchData() .then(() =&gt; &#123; return 'done' &#125;) )&#125;async function fetch() &#123; await fetchData() return 'done'&#125; 123456789101112131415161718192021222324// 实例2function fetch() &#123; return fetchData() .then(data =&gt; &#123; if (data.moreData) &#123; return fetchAnotherData(data) .then(moreData =&gt; &#123; return moreData &#125;) &#125; else &#123; return data &#125; &#125;)&#125;async function fetch() &#123; const data = await fetchData() if (data.moreData) &#123; const moreData = await fetchAnotherData(data) return moreData &#125; else &#123; return data &#125;&#125; 123456789101112131415161718// 实例3function fetch() &#123; return &#123; fetchData() .then(value1 =&gt; &#123; return fetchMoreData(value1) &#125;) .then(value2 =&gt; &#123; return fetchMoreData2(value2) &#125;) &#125;&#125;async function fetch() &#123; const value1 = await fetchData() const value2 = await fetchMoreData(value1) return fetchMoreData2(value2)&#125; 错误处理 12345678910111213function fetch() &#123; try &#123; fetchData() .then(result =&gt; &#123; const data = JSON.parse(result) &#125;) .catch((err) =&gt; &#123; console.log(err) &#125;) &#125; catch (err) &#123; console.log(err) &#125;&#125; 在这段代码种，try/catch能捕获fetchData()种的一些Promise构造错误，但不能捕获JSON.parse抛出的异常，如果要处理JSON.parse抛出的异常，需要添加catch函数重复一遍异常处理的逻辑。 在实际项目中，错误处理逻辑可能会很复杂，这回导致冗余的代码。 1234567async function fetch() &#123; try &#123; const data = JSON.parse(await fetchData()) &#125; catch (err) &#123; console.log(err) &#125;&#125; async/await的出现使得try/catch就可以捕获同步和异步的错误。 调试 12345678910111213141516171819const fetchData = () =&gt; new Promise((resolve) =&gt; setTimeout(resolve, 1000, 1))const fetchMoreData = (value) =&gt; new Promise((resolve) =&gt; setTimeout(resolve, 1000, value + 1))const fetchMoreData2 = (value) =&gt; new Promise((resolve) =&gt; setTimeout(resolve, 1000, value + 2))function fetch() &#123; return ( fetchData() .then((value1) =&gt; &#123; console.log(value1) return fetchMoreData(value1) &#125;) .then(value2 =&gt; &#123; return fetchMoreData2(value2) &#125;) )&#125;const res = fetch();console.log(res); 因为then中的代码是异步执行，所有当你打断点的时候，代码不会顺序执行，尤其当你使用step over的时候，then函数会直接进入下一个then函数。 123456789101112const fetchData = () =&gt; new Promise((resolve) =&gt; setTimeout(resolve, 1000, 1))const fetchMoreData = () =&gt; new Promise((resolve) =&gt; setTimeout(resolve, 1000, 2))const fetchMoreData2 = () =&gt; new Promise((resolve) =&gt; setTimeout(resolve, 1000, 3))async function fetch() &#123; const value1 = await fetchData() const value2 = await fetchMoreData(value1) return fetchMoreData2(value2)&#125;;const res = fetch();console.log(res); 而使用 async 的时候，则可以像调试同步代码一样调试。 aysnc地狱aysnc地狱主要是指开发者贪图语法上的简洁而让原本可以并行执行的内容变成顺序执行，从而影响了性能，但用地狱形容有点夸张了点…… 例子一 123456(async () =&gt; &#123; const listPromise = getList() const anotherListPromise = getAnotherList() await listPromise await anotherListPromise&#125;)() 也可以使用Promise.all(): 123(async () =&gt; &#123; Promise.all([getList(), getAnotherList().then(...)])&#125;)() 例子二 当然上面这个例子比较简单，我们再来扩充一下： 12345678(async () =&gt; &#123; const listPromise = await getList() const anotherListPromise = await getAnotherList() // dosomething await submit(listPromise) await submiet(anotherListPromise)&#125;) 因为await的特性，整个例子有了明显的先后顺序，然而 getList() 和 getAnotherList() 其实并无依赖，submit(listData) 和 submit(anotherListData) 也没有依赖关系，那么对于这种例子，我们该怎么改写呢？ 基本分为三个步骤： 找出依赖关系 在这里，submit(listPromise)需要getList()之后，submit(anotherListPromise)需要在anotherListPromise()之后。 将互相依赖的语句包裹在async函数中。 1234567891011aysnc function handleList() &#123; const listPromise = await getList() // ... await submit(listPromise)&#125;aysnc function handleAnotherList() &#123; const anotherlistPromise = await getAnotherList() // ... await submit(anotherlistPromise)&#125; 并发执行aysnc函数 123456789101112131415161718192021222324async function handleList() &#123; const listPromise = await getList(); // ... await submit(listData);&#125;async function handleAnotherList() &#123; const anotherListPromise = await getAnotherList() // ... await submit(anotherListData)&#125;// 方法一(async () =&gt; &#123; const handleListPromise = handleList() const handleAnotherListPromise = handleAnotherList() await handleListPromise await handleAnotherListPromise&#125;)()// 方法二(async () =&gt; &#123; Promise.all([handleList(), handleAnotherList()]).then()&#125;)() 继发与并发问题： 给定一个URL数组，如何实现接口和继发和并发？ async继发实现： 12345678// 继发一async function loadData() &#123; var res1 = await fetch(url1) var res2 = await fetch(url2) var res3 = await fetch(url3) return 'whew all done'&#125; 1234567// 继发二async function loadData(urls) &#123; for (const url of urls) &#123; const response = await fetch(url) console.log(await response.text()) &#125;&#125; async并发实现： 12345// 并发async function loadData() &#123; var res = await Promise.all([fetch(ulr1), fetch(url2), fetch(url3)]) return 'whew all done'&#125; 123456789101112// 并发二async function loadData(urls) &#123; const textPormises = urls.map(async url =&gt; &#123; const response = await fetch(url) return response.text() &#125;) // 按次序输出 for (const textPromise of textPromises) &#123; console.log(await textPromise) &#125;&#125; asyn错误捕获尽管我们可以使用try-catch捕获错误，但是当我们需要捕获多个错误并做不同的处理时，很快try-catch就会导致代码杂乱，就比如： 1234567891011121314151617181920212223242526272829303132async function asyncTask(cb) &#123; try &#123; const user = await UserModel.findById(1) if (!user) return cb('No user found') &#125; catch (e) &#123; return cb('Unexpected error occured') &#125; try &#123; const savedTask = await TaskModel(&#123; userId: user.id, name: 'Demo Task' &#125;) &#125; catch (e) &#123; return cb('Error occurred while saving task') &#125; if (user.notificationsEnabled) &#123; try &#123; await NotificationService.sendNotification(user.id, 'Task Created') &#125; catch (e) &#123; return cb('Error while sending notification') &#125; &#125; if (saveTask.assignedUser.id !== user.id) &#123; try &#123; await NotificationService.sendNotification(savedTask.assignedUser.id, 'Task was created for you') &#125; catch (e) &#123; return cb('Error while sending notification') &#125; &#125; cb(null, savedTask)&#125; 为了简化这种错误的捕获，我们可以给await后的promise对象添加catch函数，为此我们需要写一个helper： 1234567// to.jsexport default function to(promise) &#123; return promise.then(data =&gt; &#123; return [null, data] &#125;) .catch(err =&gt; [err])&#125; 整个错误捕获的代码可以简化为： 123456789101112131415import to from './to.js'async function asyncTask() &#123; let err, user, savedTask [err, user] = await to(UserModel.findById(1)) if(!user) throw new CustomerError('No user found') [err, savedTask] = await to(TaskModel(&#123; userId: user.id, name: 'Demo Task' &#125;)) if (err) throw new CustomError('Error occurred while saving task') if (user.notificationsEnabled) &#123; const [err] = await to(NotificationService.sendNotification(user.id, 'Task Created')) if (err) console.error('Just log the error and continue flow') &#125;&#125; async的一些讨论async 会取代 Generator 吗？ Generator 本来是用作生成器，使用 Generator 处理异步请求只是一个比较 hack 的用法，在异步方面，async 可以取代 Generator，但是 async 和 Generator 两个语法本身是用来解决不同的问题的。 async 会取代 Promise 吗？ async 函数返回一个 Promise 对象 面对复杂的异步流程，Promise 提供的 all 和 race 会更加好用 Promise 本身是一个对象，所以可以在代码中任意传递 async 的支持率还很低，即使有 Babel，编译后也要增加 1000 行左右。]]></content>
  </entry>
  <entry>
    <title><![CDATA[ES6系列之Generator的自动执行]]></title>
    <url>%2F2019%2F09%2F16%2FES6%E7%B3%BB%E5%88%97%E4%B9%8BGenerator%E7%9A%84%E8%87%AA%E5%8A%A8%E6%89%A7%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[## 单个异步任务 1234567var fetch = require('node-fetch')function* gen() &#123; var url = 'https://api.github.com/users/github' var result = yield fetch(url) console.log(result.bio)&#125; 为了获得最终的执行结果，你需要这样做： 12345678var g = gen()var result = g.next()result.value.then(function(data) &#123; return data.json()&#125;).then(function(data) &#123; g.next(data)&#125;) 首先执行Generator函数，获取遍历器对象。 然后使用next方法，执行异步任务的第一阶段，即fetch(url)。 注意，由于fetch(url)会返回一个Pr。Promise对象，所以result的值为： 1&#123; value: Promise &#123; &lt;pending&gt; &#125;, done: false &#125; 最后我们为这个Promise对象添加一个then方法，先将其返回的数据格式化data.json()，再调用g.next，将获得的数据传进去，由此可以执行异步任务的第二阶段，代码执行完毕。 多个异步任务上节我们只调用了一个接口，那如果我们调用了多个接口，使用了多个yield，我们岂不是在then函数中不断的嵌套下去…… 所以我们来看看执行多个异步任务的情况 123456789var fetch = require('node-fetch')function* gen() &#123; var r1 = yield fetch('https://api.github.com/users/github') var r2 = yield fetch('https://api.github.com/users/github/followers') var r3 = yield fetch('https://api.github.com/users/github/repos') console.log([r1.bio, r2[0].login, r3[0].full_name].join('\n'))&#125; 为了获得最终的执行结果，你可能要写成： 123456789101112131415161718192021var g = gen()var result1 = g.next()result1.value.then(function(data)&#123; return data.json()&#125;).then(function(data)&#123; return g.next(data).value&#125;).then(function(data)&#123; return data.json()&#125;).then(function(data)&#123; return g.next(data).value&#125;).then(function(data)&#123; return data.json()&#125;).then(function(data)&#123; g.next(data)&#125;) 但我知道你肯定不想写成这样…… 其实，利用递归，我们可以这样写： 123456789101112131415161718function run(gen) &#123; var g = gen() function next(data) &#123; var result = g.next(data) if (result.done) return result.value.then(function(data) &#123; return data.json() &#125;).then(function(data) &#123; next(data) &#125;) &#125; next()&#125;run(gen) 其中的关键就是yield的时候返回一个Promise对象，给这个Promise对象添加then方法，当异步操作成功时执行then中的onFullfilled函数，onFullfilled函数中又去执行g.next，从而让Generator继续执行，然后再返回一个Promise，再在成功时执行g.next，然后再返回…… 启动器函数在run这个启动器函数厚葬，我们在then函数中将数据格式化data.json()，但是更广泛的情况下，比如yield直接跟一个Promise，而非一个fetch函数返回的Promise，因为没有json方法，代码就会报错。所以为了更具备通用性，连同这个例子和启动器，我们修改为： 1234567891011121314151617181920212223242526272829var fetch = require('node-fetch')function* gen() &#123; var r1 = yield fetch('https://api.github.com/users/github') var json1 = yield r1.json(); var r2 = yield fetch('https://api.github.com/users/github/followers') var json2 = yield r2.json(); var r3 = yield fetch('https://api.github.com/users/github/repos') var json3 = yield r3.json(); console.log([json1.bio, json2[0].login, json3[0].full_name].join('\n'))&#125;function run(gen) &#123; var g = gen() function next(data) &#123; var result = g.next(data) if (result.done) return result.value.then(function(data) &#123; next(data) &#125;) &#125; next()&#125;run(gen) 只要yield后跟着一个Promise对象，我们就可以利用这个run函数将Generator函数自动执行。 回调函数yield后一定要跟着一个Promise对象才能保证Generator的自动执行吗？如果只是一个回调函数呢？我们来看个例子： 首先我们来模拟一个普通的异步请求： 12345function fetchData(url, cb) &#123; setTimeout(function() &#123; cb(&#123; status: 200, data: url &#125;) &#125;, 1000)&#125; 我们可以将这种函数改造成： 1234567function fetchData(url) &#123; return function(cb) &#123; setTime(function() &#123; cb( &#123; status: 200, data: url &#125;) &#125;, 1000) &#125;&#125; 对于这样的Generator函数： 123456function* gen() &#123; var r1 = yield fetchData('https://api.github.com/users/github') var r2 = yield fetchData('https://api.github.com/users/github/followers') console.log([r1.data, r2.data].join('\n'))&#125; 如果想获得最终的结果： 123456789var g = gen()var r1 = g.next()r1.value(function(data) &#123; var v2 = g.next(data) r2.value(function(data) &#123; g.next(data) &#125;)&#125;) 如果写成这样的话，我们会面临跟第一节同样的问题，那就是当使用多个 yield 时，代码会循环嵌套起来…… 同样利用递归，所以我们可以将其改造成： 123456789101112131415function run(gen) &#123; var g = gen() function next(data) &#123; var result = g.next(data) if (result.done) return result.value(next) &#125; next()&#125;run(gen) run由此可以看出Generator函数的自动执行需要一种机制，即当异步操作有了结果，能够自动交回执行权。 而两种方法可以做到这一点。 （1）回调函数。将异步操作进行包装，暴露出回调函数，在回调函数里面交回执行权。 （2）Promise 对象。将异步操作包装成 Promise 对象，用 then 方法交回执行权。 在两种方法中，我们各写了一个 run 启动器函数，那我们能不能将这两种方式结合在一些，写一个通用的 run 函数呢？我们尝试一下： 1234567891011121314151617181920212223242526// 第一版function run(gen) &#123; var gen = gen() function next(data) &#123; var result = gen.next(data) if (result.done) returm if (isPromise(result.value)) &#123; result.value.then(function(data) &#123; next(data) &#125;) &#125; else &#123; result.value(next) &#125; &#125; next()&#125;function isPromise(obj) &#123; return 'function' == typeof obj.then&#125;module.exports = run return Promise我们已经写了一个不错的启动器函数，支持yield后跟回调函数或者Promise对象。 现在有一个问题需要思考，就是我们如何获取Generator函数的返回值呢？又如果Generator函数中出现了错误，就比如fetch了一个不存在的接口，这个错误该如何捕获呢？ 这很容易让人联想到Promise，如果这个启动器函数返回一个Promise，我们就可以给这个Promise对象添加then函数，当所有的异步操作执行成功后，我们执行onFullfilled函数，如果由任何失败，就执行onReject函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 第二版function run(gen) &#123; var gen = gen() return new Promise(function(resolve, rejext) &#123; function next(data) &#123; try &#123; var result = gen.next(data) &#125; catch (e) &#123; return reject(e) &#125; if (result.done) &#123; return resolve(result.value) &#125; var value = toPromise(result.value) value.then(function(data) &#123; next(data) &#125;, function(e) &#123; reject(e) &#125;) &#125; next() &#125;)&#125;function isPromise(obj) &#123; return 'function' == typeof obj.then&#125;function toPromise(obj) &#123; if (isPromise(obj)) return obj if ('function' == typeof obj) return thunkToPromise(obj) return obj&#125;function thunkToPromise(fn) &#123; return new Promise(function(resolve, rejext) &#123; fn(function(err, res) &#123; if (err) return rejext(err) resolve(res) &#125;) &#125;)&#125;module.exports = run 与第一版有很大的不同： 首先，我们返回了一个Promise，当result.done为true的时候，我们将该值resolve(result.value)，如果执行的过程中出现错误，被carch住，我们将原因reject(e)。 其次，我们会使用thunkToPromise 将回调函数包装成一个Promise，然后统一添加then函数。在这里值得注意的是，在thunkToPromise 函数中，我们遵循了error first的原则，这意味着当我们处理回调函数的情况时： 12345678// 模拟数据请求function fetchData(url) &#123; return function(cb) &#123; setTimeout(function() &#123; cb(null, &#123; status: 200, data: url &#125;) &#125;, 1000) &#125;&#125; 在成功时，第一个参数应该返回null，表示没有错误原因。 优化我们在第二版的基础上将代码写的更加简洁优雅一点，最终的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// 第三版function run(gen) &#123; return newe Promise(function(resolve, rejecet) &#123; if (typeof gen == 'function') gen = gen() // 如果gen不是一个迭代器 if (!gen || typeof gen.next !== 'function') return resolve(gen) onFulfilled() function onFulfilled(res) &#123; var ret try &#123; ret = gen.next(res) &#125; catch (e) &#123; return reject(e) &#125; next(ret) &#125; function onRejected(err) &#123; var ret try &#123; ret = gen.throw(err) &#125; catch (e) &#123; return reject(e) &#125; next(ret) &#125; function next(ret) &#123; if (ret.done) return resolve(ret.value) var value = toPromise(ret.valeu) if (value &amp;&amp; isPromise(value)) return value.then(onFulfilled, onRejected) return onReject(new TypeError('You may only yield a function, promise ' + 'but the following object was passed: "' + String(ret.value) + '"')) &#125; &#125;)&#125;function isPromise(obj) &#123; return 'function' == typeof obj.then&#125;function toPromise(obj) &#123; if (isPromise(obj)) return obj if ('function' == typeof obj) return thunkToPromise(obj) return obj&#125;function thunkToPromise(fn) &#123; return new Promise(function(resolve, rejext) &#123; fn(function(err, res) &#123; if (err) return reject(err) resolve(res) &#125;) &#125;)&#125;module.exports = run CO如果我们再将这个启动器函数写的完整一些，我们就相当于写了一个co，实际上，上面的代码确实来自co。 而co是什么 co 是大神 TJ Holowaychuk 于 2013 年 6 月发布的一个小模块，用于 Generator 函数的自动执行。 如果直接使用 co 模块，这两种不同的例子可以简写为： 12345678910111213141516// yield 后是一个 Promisevar fetch = require('node-fetch');var co = require('co');function* gen() &#123; var r1 = yield fetch('https://api.github.com/users/github'); var json1 = yield r1.json(); var r2 = yield fetch('https://api.github.com/users/github/followers'); var json2 = yield r2.json(); var r3 = yield fetch('https://api.github.com/users/github/repos'); var json3 = yield r3.json(); console.log([json1.bio, json2[0].login, json3[0].full_name].join('\n'));&#125;co(gen); 12345678910111213141516171819// yield 后是一个回调函数var co = require('co');function fetchData(url) &#123; return function(cb) &#123; setTimeout(function() &#123; cb(null, &#123; status: 200, data: url &#125;) &#125;, 1000) &#125;&#125;function* gen() &#123; var r1 = yield fetchData('https://api.github.com/users/github'); var r2 = yield fetchData('https://api.github.com/users/github/followers'); console.log([r1.data, r2.data].join('\n'));&#125;co(gen);]]></content>
  </entry>
  <entry>
    <title><![CDATA[ES6之Promise]]></title>
    <url>%2F2019%2F09%2F16%2FES6%E4%B9%8BPromise%2F</url>
    <content type="text"><![CDATA[说起Promise，我们一般都会从回调或者回调地狱说起，那么使用回调到底会导致哪些不好的地方呢？ 回调 回调嵌套 使用回调，我们很可能会将业务代码写成如下这种形式： 1234567891011doA( function() &#123; doB() doC(function() &#123; doD() &#125;) doE()&#125;)doF() 当然这是一种简化的形式，我们可以判断出执行的顺序为： 123456doA()doF()doB()doC()doE()doD() 然而在实际项目中，代码会更加杂乱，为了排查问题，我们需要绕过很多碍眼的内容，不断的在函数间进行跳转，使得排查问题的难度也在成倍增加。 当然之所以导致这个问题，其实时因为这种嵌套的书写方式跟人线性的思考方式相维和，以至于我们需要花更多一些精力去思考真正的执行顺序，嵌套和缩进只是这个思考过程中转移注意力的细枝末节而已。 当然了，与人线性的思考方式相维和，还不是最糟糕的，实际上，我们还会在代码中加入各种各样的逻辑判断，就比如说上面这个例子中，doD()必须在doC()完成后才能完成，如果doC()执行失败了呢？我们要重试doC()吗？还是直接转到其他错误处理函数中？当我们将这些判断都加入到这个流程中，很快代码就会变得非常复杂，以至于无法维护和更新。 控制反转 正常书写代码的时候，我们理所当然可以控制自己的代码，然而当我们使用回调的时候，这个回调函数是否能接着执行，其实取决于使用回调的哪个API。就比如： 123456// 回调幻术是否被执行取决于buy模块import &#123;buy&#125; from './buy.js'buy(itemData, function(res) &#123; console.log(res)&#125;) 对于我们经常使用的fetch这种API，一般是没有什么问题的，但是如果我们使用的是第三方的API呢？ 当你调用了第三方的API，对方是否会因为某个错误导致你传入的回调函数执行了多次呢？ 为了避免出现这样的问题，你可以在自己的回调函数中加入判断，可是万一又因为某个错误，这个函数没有执行呢？万一这个回调函数有时同步执行，有时异步执行呢？ 我们总结一下这些情况： 回调函数执行多次 回调函数没有执行 回调函数有时同步执行，有时异步执行 对于这些情况，你可能都要在回调函数中做些处理，并且每次执行回调函数的时候都要做些处理，这就带来了很多重复的代码。 回调地狱我们先来看一个简单的回调地狱的实例。 现在要找出一个目录中最大的文件，处理步骤应该是： 用fs.readdir获取目录中的文件列表 循环遍历文件，使用fs.stat获取文件信息 比较找出最大文件 以最大文件的文件名为参数调用回调 代码如下： 123456789101112131415161718192021222324252627282930313233343536var fs = require('fs')var path = require('path')function findLargest(dir, cb) &#123; // 读取目录下的所有文件 fs.readdir(dir, function(er, files) &#123; if (er) return cb(er) var counter = files.length var errored = false var stats = [] files.forEach(function(file, index) &#123; // 读取文件信息 fs.stat(path.join(dir, file), function(er, stat) &#123; if (errored) return if (er) &#123; errored = true return cb(er) &#125; stats[index] = stat // 事先算好有多少个文件，读完1个文件，计数减1，当为0时，说明读取完毕 if (--counter == 0) &#123; var largest = stats.filter(function(stat) &#123; return stat.isFile() &#125;).reduce(function(prev, next) &#123; if (prev.size &gt; next.size) return prev return next &#125;) cb(null, files[stats.indexOf(largest)]) &#125; &#125;) &#125;) &#125;)&#125; 使用方式为： 12345// 查找当前目录最大的文件findLargest('./', function(er, filename) &#123; if (er) return console.error(er) console.log('largest file was:', filename)&#125;) 看完这个例子，我们再来聊聊回调地狱的其他问题： 难以复用 回调的顺序确定下来之后，相对其中的某些环节进行复用也很困难，牵一发而动全身。 举个例子，如果你想对fs.stat读取文件信息这段代码进行复用，因为代码中引用了外层的变量，提取出来后还需要对外层的代码进行修改。 堆栈信息被断开 我们知道，JavaScript引擎维护了一个执行上下文栈，当函数执行的时候，会创建该函数的执行上下文压入栈中，当函数执行完毕后，会将该执行上下文出栈。 如果A函数中调用了B函数，JavaScript会先将A函数的执行上下文压入栈中，再将B函数的执行上下文压入栈中，当B函数执行完毕，将B函数执行上下文出栈，当A函数执行完毕后，将A函数执行上下文出栈。 这样的好处在于，我们如果中断代码执行，可以检索完整的堆栈信息，从中获取任何我们想要获取的信息。 可以异步回到函数并非如此，比如执行｀fs.readdir｀的时候，其实是将回调函数加入任务队列中，代码继续执行，直到主线程完成后，才会从任务队列中选择已完成的任务并将其加入栈中，此时栈中只有这一个执行上下文，如果回调报错，也无法获取调用该异步操作时的栈中的信息。不容易判定哪里出现了错误。 此外，因为异步的缘故，使用try catch语句也无法直接获取错误。 借助外层变量 当多个异步计算同时进行，比如这里遍历读取文件信息，由于无法预期完成顺序，必须借助外层作用域的变量。比如这里的count、errored、stats等，不仅写起来麻烦，而且如果你忽略了文件读取错误时的情况，不记录错误状态，就会接着读取其他文件，造成无谓的浪费。此外外层的变量，也可能会被其他统一作用域的函数访问并且修改，容易造成误操作。 之所以单独讲讲回调地狱，其实是想说嵌套和缩进只是回调地狱的一个梗而已，它导致的问题远非嵌套导致的可读性降低而已。 PromisePromise使得以上绝大部分的问题都得到了解决。 嵌套问题 举个例子： 12345678function(url, function(err, res, body) &#123; if (err) handleError(err) fs.writeFile('1.txt', body, function(err) &#123; request(url2, function(err, res, body) &#123; if (err) handleError(err) &#125;) &#125;)&#125;) 使用Promise后： 12345678910request(url).then(function(result) &#123; return writeFileAsynv('1.txt', result)&#125;).then(function(result) &#123; return request(url2)&#125;).catch(function(e) &#123; handleError(e)&#125;) 而对于读取最大文件的那个例子，我们使用promise可以简化为： 1234567891011121314151617181920212223242526272829303132333435363738394041var fs = require('fs')var path = require('path')var readDir = function(dir) &#123; return new Promise(function(resolve, reject) &#123; fs.readdir(dir, function(err, files) &#123; if (err) reject(err) resolve(files) &#125;) &#125;)&#125;var stat = function(path) &#123; return new Promise(function(resolve, reject) &#123; fs.stat(path, function(err, stat) &#123; if (err) reject(err) resolve(stat) &#125;) &#125;)&#125;function findLargest(dir) &#123; return readDir(dir) .then(function(files) &#123; let promises = files.map(file =&gt; stat(path.join(dir, file))) return Promise.all(promises).then(function(stats) &#123; return &#123; stats, files &#125; &#125;) &#125;) .then(data =&gt; &#123; let largest = data.stats .filter(function(stat) &#123; return stat.isFile() &#125;) .reduce((prev, next) =&gt; &#123; if (prev.size &gt; next.size) return prev return next &#125;) return data.files[data.stats.indexOf(largest)] &#125;)&#125; 控制反转再反转 前面我们讲到使用第三方回调 API 的时候，可能会遇到如下问题： 回调函数执行多次 回调函数没有执行 回调函数有时同步执行有时异步执行 对于第一个问题，Promise 只能 resolve 一次，剩下的调用都会被忽略。 对于第二个问题，我们可以使用 Promise.race 函数来解决： 12345678910111213function timeoutPromise(delay) &#123; return new Promise(function(resolve, reject) &#123; setTimeout(function() &#123; reject('Timeout!') &#125;, delay) &#125;)&#125;Promise.race([ foo(), timeoutPromise(3000)]).then(function() &#123;&#125;, function(err) &#123;&#125;) 对于第三个问题，为什么有的时候会同步执行，有的时候是异步执行呢？ 我们来看个例子： 1234567891011121314var cache = &#123;...&#125;function downloadFile(url) &#123; if (cache.has(url)) &#123; // 如果存在cache，这里为同步调用 return Promise.resolve(cache.get(url)) &#125; return fetch(url).then(file =&gt; cache.set(url, file)) // 这里为异步调用&#125; console.log('1')console.log('1');getValue.then(() =&gt; console.log('2'));console.log('3'); 在这个例子中，有cache的情况，打印结果为1 2 3 ，在没有cache的时候，打印结果为1 3 2。 然而如果将这种同步和混用的代码作为内部实现，只暴露接口给外部调用，调用方由于无法判断到底是异步还是同步状态，影响程序的可维护性和可测试性。 简单来说就是同步和异步共存的情况无法保证程序逻辑的一致性。 然而Promise解决了这个问题，我们来看个例子： 123456789101112var promise = new Promise(function(resolve) &#123; resolve() console.log(1)&#125;)promise.then(function() &#123; console.log(2)&#125;)console.log(3)// 1 3 2 即使promise对象立刻进入resolved状态，即同步调用resolve函数，then函数中指定的方法依然是异步进行的。 PromiseA+ 规范也有明确的规定： 实践中要确保 onFulfilled 和 onRejected 方法异步执行，且应该在 then 方法被调用的那一轮事件循环之后的新执行栈中执行。 Promise反模式 Promise嵌套 123456// badloadSomething().then(function(something) &#123; loadAnotherthing().then(function(another) &#123; DoSomethingOnThem(something, another) &#125;)&#125;) 12345// goodPromise.all([loadSomething(), loadAnotherthing()]).then(function([something, another]) &#123; DoSomethingOnThem(...[something, another])&#125;) 断开的Promise链 123456789// badfunction anAsyncCall() &#123; var promise = doSomethingAsync() promise.then(function() &#123; somethingComplicated() &#125;) return promise&#125; 1234567// goodfunction anAsyncCall() &#123; var promise = doSomethingAsync() return promise.then(function() &#123; somethingComplicated() &#125;)&#125; 混乱的集合 12345678910111213// badfunction workMyCollection(arr) &#123; var resultArr = [] function _recursive(idx) &#123; if (idx &gt;= resultArr.length) return resultArr return doSomethingAsync(arr[idx]).then(function(res) &#123; resultArr.push(res) return _recursive(idx + 1) &#125;) &#125; return _recursive(0)&#125; 你可以写成： 12345function workMyCollection(arr) &#123; return Promise.all(arr.map(function(item) &#123; return doSomethingAsync(item) &#125;))&#125; 如果你非要以队列的形式执行，你可以写成： 1234567function workMyCollection(arr) &#123; return arr.reduce(function(promise, item) &#123; return promise.then(function(result) &#123; return doSomethingAsyncWithResult(item, result) &#125;) &#125;, Promise.resolve())&#125; catch 123456// badsomethingAsync.then(function() &#123; return somethingElseAsync()&#125;, function(err) &#123; handleMyError(err)&#125;) 如果somethingElseAsync抛出错误，是无法被捕获的，你可以写成： 12345678// goodsomethingAsync.then(function() &#123; return somethingElseAsync()&#125;).then(null, function(err) &#123; handleMyError(err)&#125;) 12345678// goodsomethingAsync().then(function() &#123; return somethingElseAsync()&#125;).catch(function(err) &#123; handleMyError(err)&#125;) 红绿灯问题题目： 红灯三秒亮一次，绿灯一秒亮一次，黄灯两秒亮一次：如何让三个灯不断交替重复亮灯？ 三个亮灯函数已经存在： 123456789function red()&#123; console.log('red');&#125;function green()&#123; console.log('green');&#125;function yellow()&#123; console.log('yellow');&#125; 利用then和递归实现： 1234567891011121314151617181920212223242526272829303132function red()&#123; console.log('red');&#125;function green()&#123; console.log('green');&#125;function yellow()&#123; console.log('yellow');&#125;var light = function(timmer, cb) &#123; return new Promise(function(resolve, reject) &#123; setTimeout(function() &#123; cb() resolve() &#125;, timmer) &#125;)&#125;var step = function() &#123; Promise.resolve().then(function() &#123; return light(3000, red) &#125;).then(function() &#123; return light(2000, green) &#125;).then(function() &#123; return light(1000, yellow) &#125;).then(function() &#123; step() &#125;)&#125;step() promisify有的时候，我们需要将callback语法的API改造成Promise语法，为此我们需要一个promisify的方法。 因为callback语法传参比较明确，最后一个参数传入回调函数，回调函数的第一个参数是一个错误信息，如果没有错误，就是null，所以我们可以直接写出一个简单的promisify方法： 12345678910111213function promisify(original) &#123; return function(...args) &#123; return new Promise((resolve, reject) =&gt; &#123; args.push(function callback(err, ...values) &#123; if (err) &#123; return reject(err) &#125; return resolve(...values) &#125;) original.call(this, ...args) &#125;) &#125;&#125; Promise的局限性 错误被吃掉了 首先我们要理解，什么是错误被吃掉，是指错误信息不被打印吗？ 并不是，举个例子： 12throw new Error('error');console.log(233333); 在这种情况下，由于throw error的缘故，代码被阻断执行，就不会打印233333，再举个例子： 12const promise = new Promise(null)console.log(233333) 以上代码依然会被阻断执行，这是因为如果通过无效的方式使用Promise，并且出现了一个错误阻碍了正常Promise的构造，结果会得到一个立刻跑出的异常，而不是一个被拒绝的Promise。 然而再举个例子： 1234let promise = new Promise(() =&gt; &#123; throw new Error('error')&#125;)console.log(233333) 这次会正常打印233333，说明Promise内部的错误不会影响到Promise外部的代码，而这种情况我们就通常称为“吃掉错误”。 其实着并不是Promise独有的局限性，try…catch也是这样，同样会捕获一个异常并简单的吃掉错误。 而正是因为错误被吃掉了，Promise链中的错误很容易被忽略掉，这也是为什么会一般推荐在Promise链的最后添加一个catch函数，因为对于一个没有错误处理函数的Promise链，任何错误都会在链中被传播下去，直到你注册了错误处理函数。 单一值 Promise只能由一个完成值或一个拒绝原因，然而在真实使用的时候，往往需要传递多个值，一般做法都是构造一个对象或数组，然后再传递，then中获得这个值后，又会进行取值赋值的操作，每次封装和解封都无疑让代码变得笨重。 说真的，并没有什么好的方法，建议使用ES6的解构赋值： 1234Promise.all([Promise.resolve(1), Promise.resolve(2)]).then(([x, y] =&gt; &#123; console.log(x, y)&#125;)) 无法取消 Promise一旦新建，它就会立即执行，无法中途取消。 无法得知pending状态 当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。]]></content>
  </entry>
  <entry>
    <title><![CDATA[ES6系列值WeakMap]]></title>
    <url>%2F2019%2F09%2F16%2FES6%E7%B3%BB%E5%88%97%E4%B9%8BWeakMap%2F</url>
    <content type="text"><![CDATA[我们先从WeakMap的特性说起，然后聊聊WeakMap的一些应用场景。 特性 WeakMap只接受对象作为键名 12345const map = new WeakMap()map.set(1, 2)// TypeError: Invalid value used as weak map keymap.set(null, 2);// TypeError: Invalid value used as weak map key WeakMap的键名所引用的对象是弱应用 这句话其实让我非常费解，我个人觉得这句话真正想表达的意思应该是： WeakMaps hold “weak” references to key objects, 翻译过来应该是 WeakMaps 保持了对键名所引用的对象的弱引用。 我们先聊聊弱引用： 在计算机程序设计中，弱引用与强引用相对，是指不能确保其引用的对象不会被垃圾回收器回收的引用。 一个对象若只被弱引用所引用，则被认为是不可访问（或弱可访问）的，并因此可能在任何时刻被回收。 在 JavaScript 中，一般我们创建一个对象，都是建立一个强引用： 1var obj = new Object(); 只有当我们手动设置obj = null 的时候，才有可能回收obj所引用的对象。 而如果我们能创建一个弱引用的对象 12// 假设可以这样创建一个var obj = new WeakObject() 我们什么都不用做，只用静静的等待垃圾回收机制执行，obj所引用的对象就会被回收。 我们再来看看这句： WeakMap保持了对键名所引用的对象的弱引用 正常情况下，我们举个例子： 1234const key = new Array(5 * 1024 * 1024)const arr = [ [key, 1]] 使用这种方式，我们其实建立了arr和key所引用的对象（我们假设这个真正的对象叫Obj）的强引用。 所有当你设置key = null时，只是去掉了key对Obj的强引用，并没有去除arr对Obj的强引用，所以Obj还是不会被回收掉。 Map类型也是类似： 1234567let map = new Map()let key = new Array(5 * 1024 * 1024)// 建立了map对key'所引用对象的强引用map.set(key, 1)// key = null 不会导致key的原引用对象被回收key = null 我们可以通过Node来证明一下这个问题： 1234567891011121314151617181920// 允许手动执行垃圾回收机制node --expose-gcglobal.gc() // 返回Nodejs的内存占用情况，单位是bytesprocess.memoryUsage() // heapUsed: 460360 = 4.4Mlet map = new Map()let key = new Array(5 * 1024 * 1024)map.set(key, 1)global.gc()process.memoryUsage() // heapUsed: 46751472 注意这里大约是 44.6Mkey = nullglobal.gc()process.memoryUsage() // heapUsed: 46754648 ≈ 44.6M// 这句话其实是无用的，因为 key 已经是 null 了map.delete(key);global.gc();process.memoryUsage(); // heapUsed: 46755856 ≈ 44.6M 如果你想要让 Obj 被回收掉，你需要先 delete(key) 然后再 key = null: 12345let map = new Map();let key = new Array(5 * 1024 * 1024);map.set(key, 1);map.delete(key);key = null; 我们依然通过 Node 证明一下： 123456789101112131415161718node --expose-gcglobal.gc();process.memoryUsage(); // heapUsed: 4638376 ≈ 4.4Mlet map = new Map();let key = new Array(5 * 1024 * 1024);map.set(key, 1);global.gc();process.memoryUsage(); // heapUsed: 46727816 ≈ 44.6Mmap.delete(key);global.gc();process.memoryUsage(); // heapUsed: 46748352 ≈ 44.6Mkey = null;global.gc();process.memoryUsage(); // heapUsed: 4808064 ≈ 4.6M 这个时候就要说到 WeakMap 了： 1234const wm = new WealMap()let key = new Array(5 * 1024 * 1024)wm.set(key, 1)key = null 当我们设置 wm.set(key, 1) 时，其实建立了 wm 对 key 所引用的对象的弱引用，但因为 let key = new Array(5 * 1024 * 1024) 建立了 key 对所引用对象的强引用，被引用的对象并不会被回收，但是当我们设置 key = null 的时候，就只有 wm 对所引用对象的弱引用，下次垃圾回收机制执行的时候，该引用对象就会被回收掉。 我们用 Node 证明一下： 1234567891011121314node --expose-gcglobal.gc();process.memoryUsage(); // heapUsed: 4638992 ≈ 4.4Mconst wm = new WeakMap();let key = new Array(5 * 1024 * 1024);wm.set(key, 1);global.gc();process.memoryUsage(); // heapUsed: 46776176 ≈ 44.6Mkey = null;global.gc();process.memoryUsage(); // heapUsed: 4800792 ≈ 4.6M 所以WeakMap可以帮你省掉手动删除对象关联数据的步骤，所以当你不能或者不想控制关联数据的生命周期时，就可以考虑使用WeakMap 总结这个弱引用的特性，就是WeakMap保持了对键名所引用的对象的弱引用，即垃圾回收机制不将该引用考虑在内。只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存也就是说，一旦不再需要，WeakMap里面的键名对象和所对应的键值对会自动消失，不用手动删除引用。 也正是因为这样的特性，WeakMap内部有多少个成员，取决于垃圾回收机制有没有运行，运行前后很可能成员个数时不一样的，而垃圾回收机制何时运行是不可预测的，因此ES6规定WeakMap不可遍历。 所以WeakMap不像Map，一是没有遍历操作（即没有keys()、values()和entries()方法），也没有size属性，也不支持clear()方法。所以WeakMap只要四个方法可以用：get()、set()、has()、delete().。 应用 在DOM对象上保存相关数据 传统使用jQuery的时候，我们会通过$.data()在DOM对象上存储相关信息（就比如在删除按钮元素上储存帖子的ID信息），jQuery内部会使用一个对象管理DOM和对应的数据，当你将DOM元素删除，DOM对象置为空的时候，相关联的数据并不会被删除，你必须手动执行$.removeData()才能删除掉相关联的数据，WeakMap就可以简化这一操作。 12345678let wm = new WeakMap(), element = document.querySelector('.element')wm.set(element, 'data')let value = wm.get(element)console.log(vlaue) // dataelement.parentNode.removeChild(element)element = null 数据缓存 从上一个例子，我们也可以看出，当我们需要关联对象和数据，比如在不修改原有对象的情况下储存某些属性或者根据对象储存一些计算的值等，而又不想管理这些数据时非常适合考虑使用WeakMap。数据缓存就是一个很好的例子。 12345678910111213const cache = new WeakMap()function countOwnKeys(obj) &#123; if (cache.has(obj)) &#123; console.log('Cached') return cache.get(obj) &#125; else &#123; console.log('Computed') const count = Object.keys(obj).length cache.set(obj, count) return count &#125;&#125; 私有属性 WeakMap也可以被用于实现私有变量，不过在ES6中实现私有变量的方式有很多种，这只是其中一种： 1234567891011121314151617const privateData = new WeakMap()class Person &#123; constructor(name, age) &#123; privateData.set(this, &#123; name: name, age: age &#125;) &#125; getName() &#123; return privateData.get(this).name &#125; getAge() &#123; return privateData.get(this).age &#125;&#125;export default Person]]></content>
  </entry>
  <entry>
    <title><![CDATA[ES6系列之迭代器与for...of]]></title>
    <url>%2F2019%2F09%2F15%2FES6%E7%B3%BB%E5%88%97%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8Efor-of%2F</url>
    <content type="text"><![CDATA[## 起源 一段标准的for循环代码： 12345var color = ['red', 'green', 'blue']for (var i = 0, len = color.length; i &lt; len; i++) &#123; console.log(color[i])&#125; 看着很简单，但是回顾这段代码，实际上我们仅仅是需要数组中元素的值，但是却需要提前获取数组长度，声明索引变量等，尤其当多个循环嵌套的时候，更需要使用多个索引变量，代码的复杂度就会大大增加，比如我们使用双重循环进行去重： 12345678910111213141516function unique(array) &#123; var res = [] for (var i = 0, arrayLen = array.length; i &lt; arrayLen; i++) &#123; for (var j = 0, resLen = res.length; j &lt; resLen; j++) &#123; if (array[i] === res[j]) &#123; break &#125; &#125; if (j === resLen) &#123; res.push(array[i]) &#125; &#125; return res&#125; 为了消除这种复杂度以及减少循环中的错误（比如错误使用其他循环中的变量），ES6提供了迭代器与for…of循环共同解决这个问题。 迭代器所谓迭代器，其实就是一个具有next()方法的对象，每次调用next()都会返回一个结果对象，该结果对象有两个属性，value表示当前的值，done表示遍历是否结束。 我们直接用ES5的语法创建一个迭代器 12345678910111213141516171819202122function createIterator(items) &#123; var i = 0 return &#123; next: function() &#123; var done = i &gt;= item.length var value = !done ? items[i++] : undefined return &#123; done: done, value: value &#125; &#125; &#125;&#125;// iterator就是一个迭代对象var itrtator = createIterator([1, 2, 3])console.log(iterator.next()); // &#123; done: false, value: 1 &#125;console.log(iterator.next()); // &#123; done: false, value: 2 &#125;console.log(iterator.next()); // &#123; done: false, value: 3 &#125;console.log(iterator.next()); // &#123; done: true, value: undefined &#125; for…of除了迭代器之外，我们还需要一个可以遍历迭代器对象的方式，ES6提供了for…of语句，我们直接用for…of遍历一下我们上节生成的遍历器对象： 12345var iterator = createIterator([1, 2,3])for (let value of iterator) &#123; console.log(value)&#125; 结果报错TypeError: iterator is not iterable，表明我们生成的iterator对象并不是iterable（可遍历的）。 那么什么才是iterable（可遍历的）呢？ 其实一种数据结构只需要部署了Iterator接口，我们就称这种数据结构是“可遍历的”（iterable）。 ES6规定，默认的Iterator接口部署在数据结构的Symbol.iterator属性，或者说，一个数据结构只要具有Symbol.iterator属性，就可以认为是“可遍历”（iterable）。 举个例子： 123456789const obj = &#123; value: 1&#125;for (value of obj) &#123; console.log(value)&#125;// TypeError: iterator is not iterable 我们直接for…of遍历一个对象会报错，然而如果我们给该对象添加Symbol.iterator属性： 1234567891011121314const obj = &#123; value: 1&#125;obj[Symbol.iterator] = function() &#123; return createIterator([1, 2,3])&#125;for (value of obj) &#123; console.log(value)&#125;// 1// 2// 3 由此，我们可以发现for…of遍历的其实是对象的Symbol.iterator属性。 默认可遍历对象然而如果我们直接遍历一个数组对象 123456789const colors = ['red', 'green', 'blue']for (let color of colors) &#123; console.log(color)&#125;// red// green// blue 尽管我们没有手动添加Symbol.iterator属性，还是可以遍历成功，这是因为ES6默认部署了Symbol.iterator属性，当然我们也可以手动修改这个属性： 12345678910111213var colors = ['red', 'green', 'blue']colors[Symbol.iterator] = function() &#123; return createIterator([1, 2, 3])&#125;for (let color of colors) &#123; console.log(color)&#125;// 1// 2// 3 除了数组之外，还有一些数组结构默认部署了Symbol.iterator属性。 所以for…of循环可以使用的范围包括： 数组 Set Map 类数组对象，如arguments对象，DOM NodeList对象 Generator对象 字符串 模拟实现for…of其实模拟实现for…of也比较简单，基本就是通过Symbol.iterator属性获取迭代器对象，然后使用while遍历一下： 12345678910111213141516171819function forOf(obj, cb) &#123; let iterable, result if (typeof obj[Symbol.iteratorp] !== 'function') &#123; throw new TypeError(result + ' is not iterable') &#125; if (typeof cb !== 'function') &#123; throw new TypeError('cb must be callable') &#125; iterable = obj[Symbol.iterator]() result = iterable.next() while (!iterable.done) &#123; cb(result.value) result = iterable.next() &#125;&#125; 内建迭代器为了更好的访问对象中的内容，比如有的时候我们仅仅需要数组中的值，但有的时候不仅需要使用值还需要使用索引，ES6为数组、Map、Set集合内建了以下三种迭代器： entries()返回一个遍历器对象，用来遍历[键名，键值]组成的数组。对应数组，键名就是索引值。 keys()返回一个遍历器对象，用来遍历所有的键名。 values()返回一个遍历器对象，用来遍历所有的键值。 以数组为例： 12345678910111213141516171819202122232425var colors = ['red', 'green', 'blue']for (let index of color.keys()) &#123; console.log(index)&#125;// 0// 1// 2for (let color of colors.values()) &#123; console.log(color)&#125;// red// green// bluefor (let itemm of color.entries()) &#123; console.log(item)&#125;// [0, 'red']// [1, 'green']// [2, 'blue'] Map类型与数组类似，但是对于Set类型需要注意以下： 12345678910111213141516171819202122232425var color = new Set(['red', 'green', 'blue'])for (let index of color.keys()) &#123; console.log(index)&#125;// red// green// bluefor (let color of colors.values()) &#123; console.log(color)&#125;// red// green// bluefor (let itemm of color.entries()) &#123; console.log(item)&#125;// [red, 'red']// [green, 'green']// [blue, 'blue'] Set类型的keys()和values()返回的是相同的迭代器，这也意味着在Set这种数据结构中键名与键值相同。 而且每个集合类型都有一个默认的迭代器，在for…of循环中，如果没有显示指定则使用默认的迭代器。数组和Set集合的默认迭代器是values()方法，Map集合的默认迭代器是entries()方法。 这也就是为什么直接for…of遍历Map和Set数据结构，返回不同的数据结构。 123456789const values = new Set([1, 2, 3])for (let value of values) &#123; console.log(value)&#125;// 1// 2// 3 1234567const values = new Map([["key1", "value1"], ["key2", "value2"]]);for (let value of values) &#123; console.log(value);&#125;// ["key1", "value1"]// ["key2", "value2"] 遍历 Map 数据结构的时候可以顺便结合解构赋值： 12345678const values = new Map([["key1", "value1"], ["key2", "value2"]]);for (let [key, value] of values) &#123; console.log(key + ":" + value);&#125;// key1:value1// key2:value2 Babel是如何编译for…of的我们可以在Babel 的 Try it out 中查看编译的结果： 12345const colors = new Set(['red', 'green', 'blue'])for (let color of colors) &#123; console.log(color)&#125; 对于这样一段代码，编译的结果如下： 1234567891011121314151617181920212223242526272829303132'use strict'var colors = new Set(['res', 'green', 'blue'])var _iteratorNormalCompletion = truevar _didIteratorError = falsevar _iteratorError = undefinedtry &#123; for ( var _iterator = colors[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true ) &#123; var color = _setp.value console.log(color) &#125;&#125; catch (err) &#123; _didIteratorError = true _iteratorError = err&#125; finally &#123; try &#123; if (!_iteratorNormalCompletion &amp;&amp; _iterator.return) &#123; _iterator.return() &#125; &#125; finally &#123; if (_didIteratorError) &#123; throw _iteratorError &#125; &#125;&#125; 至少由编译的结果可以看出，使用for of 循环的背后，还是会使用Symbol.iterator接口。 而这段代码稍微复杂的地方有两端，一段是for循环： 12345678for ( var _iterator = colors[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) &#123; var color = _step.value; console.log(color);&#125; 跟标准的for循环写法有些区别，我们看下for语句的语法： 1for (initialize; test; increment) statement initialize、test和increment三个表达式之间用分号分隔，它们分别负责初始化操作、循环条件判断和计数器变量的更新。 for语句其实就相当于： 12345initializewhile (test) &#123; statement increment&#125; 代码的逻辑为：先进行初始化，然后每次循环执行之前会执行test表达式，并判断表达式的结果来决定是否执行循环体，如果test计算结果为真值，则执行循环体中的statement。最后，执行increment表达式。 而且值得注意的是，其实 for 循环中的三个表达式中任意一个都可以被忽略，不过分号还是要写的。 比如 for(;;)，不过这就是一个死循环…… 比如： 12345var i = 0, len = colors.length;for (; i &lt; len; i++) &#123; console.log(colors[i]);&#125; 又比如： 123var i = 0, len = colors.length;for 后我们再来看 Babel 编译的这个 for 循环表达式： 12345678for ( var _iterator = colors[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) &#123; var color = _step.value; console.log(color);&#125; 用 while 的写法相当于： 1234567var _iterator = colors[Symbol.iterator](), _step;while (!(_iteratorNormalCompletion = (_step = _iterator.next()).done)) &#123; var color = _step.value; console.log(color); _iteratorNormalCompletion = true;&#125; 是不是就好懂了很多呢，然后你就会发现，其实 _iteratorNormalCompletion = true 这句是完全没有必要的…… 另外一段稍微复杂的代码是: 12345678910111213try &#123; ...&#125; catch (err) &#123; ...&#125; finally &#123; try &#123; if (!_iteratorNormalCompletion &amp;&amp; _iterator.return) &#123; _iterator.return(); &#125; &#125; finally &#123; ... &#125;&#125; 因为 _iteratorNormalCompletion = (_step = _iterator.next()).done，所以 _iteratorNormalCompletion 表示的就是是否完成了一次完整的迭代过程，如果没有正常的迭代完成，并且迭代器有 return 方法时，就会执行该方法。 而之所以这么做，就要提到迭代器的 return 方法。 引用阮一峰老师的 ECMAScript 6 入门: 遍历器对象除了具有 next 方法，还可以具有 return 方法和 throw 方法。如果你自己写遍历器对象生成函数，那么 next 方法是必须部署的，return 方法和 throw 方法是否部署是可选的。 return 方法的使用场合是，如果 for…of 循环提前退出（通常是因为出错，或者有 break 语句或 continue 语句），就会调用 return 方法。如果一个对象在完成遍历前，需要清理或释放资源，就可以部署 return 方法。 我们可以举个例子： 1234567891011121314151617181920212223242526272829303132333435function createIterator(items) &#123; var i = 0 return &#123; next: function() &#123; var done = i &gt;= items.length var value = !done ? items[i++] : undefiend return &#123; done: done, value: value &#125; &#125;, return: function() &#123; console.log('执行了return方法') return &#123; value: 23333, done: true &#125; &#125; &#125;&#125;var colors = ['red', 'green', 'blue']var iterator = createIterator([1, 2, 3])colors[Symbol.iterator] = function() &#123; return iterator&#125;for (let color of colors) &#123; if (color == 1) break console.log(color)&#125;// 执行了return方法 不过正如你在编译后的代码中看到，仅仅是在有 return 函数的时候执行了 return 函数而已，return 函数中返回的值其实并不生效…… 但是你不返回值或者返回一个基本类型的值的话，结果又会报错…… 1TypeError: Iterator result undefined is not an object 这是因为 return 方法必须返回一个对象，而这又是 Generator 规范决定的…… 总之如果是在浏览器中使用的话，return 函数的返回值其实并不生效 T^T]]></content>
  </entry>
  <entry>
    <title><![CDATA[Symbol的使用场景]]></title>
    <url>%2F2019%2F09%2F14%2FSymbol%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%2F</url>
    <content type="text"><![CDATA[## ES6第7中数据类型——Symbol 已经有的6中数据类型：Undefined、Null、布尔值、字符串、数值、对象，现在ES6新加入一种数据类型——Symbol。我们先来看看它的最大特点：独一无二。 1234567891011// 没有参数的情况var s1 = Symbol()var s2 = Symbol()console.log(s1 === s2) // false// 有参数的情况var s1 = Symbol("foo");var s2 = Symbol("foo");console.log(s1 === s2) // false 这里的的’foo’只是该Symbol的一个描述，并不代表两个参数都为’foo’时，就能够证明这两个Symbol相等。 作为属性名的使用12345678910111213141516var mySymbol1 = Symbol()// 第一种写法a[mySymbol] = 'Hello'// 第二种写法var a = &#123; [mySymbol]: 'Hello'&#125;// 第三种写法var a = &#123;&#125;Object.defineProperty(a, mySymbol, &#123; value: 'Hello' &#125;)// 以上写法都得到同样结果a[mySymbol] // 'Hello' 注意，这里不可以使用a.mySymbol = &#39;hello&#39;来填充该属性值，因为点运算符后面总是字符串。 为什么要是有Symbol？ 那么问题来了，我们究竟为什么要使用Symbol呢？有这样一种场景，我们向区分两个属性，其实我们并不在意这两个属性值究竟是什么，我们在意的是，这两个属性绝对要区分开来！例如： 12345678910111213var shapeType = &#123; triangle: 'Triangle' &#125;function getArea(shape, options) &#123; var area = 0 switch(shape) &#123; case shape.triangle: area = 0.5 * options.width * options.height break &#125; return area&#125; 这个时候，我们仅仅是想区分各种形状，因为不同的形状用不同计算面积的公式。这里是用的是triangle的名字就在‘Triangle’,而事实上我们不想对triangle去特地取个名，我们只想区分triangle这个形状不同于任何其他形状，那么这个时候Symbol就派上用场啦! 123const shapeType = &#123; triangle: Symbol()&#125; 发现了吗，也就是说我们不用非要去给变量赋一个字符串的值，去区分它和别的变量的值不同，因为去给每个变量娶个语义化而又不同的值是一个伤脑子的事，当我们只需要知道每个变量的值是不同的时，我们就可以使用Symbol/]]></content>
  </entry>
  <entry>
    <title><![CDATA[ES6系列之模拟Symbol类型]]></title>
    <url>%2F2019%2F09%2F14%2FES6%E7%B3%BB%E5%88%97%E4%B9%8B%E6%A8%A1%E6%8B%9FSymbol%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[实际上，Symbol的很多特性都无法模拟实现，所以先让我们回顾下有哪些特性，然后挑点能实现的。当然在看的过程中，你也可以思想这个特性是否能实现，如果能实现，该如何实现。 回顾ES6引入了一种新的原始数据类型Symbol，表示独一无二的值。 Symbol值通过Symbol函数生成，使用typeof，结果是“symbol” 12var s = Symbol()console.log(typeof s) // "symbol" Symbol函数前不能使用new命令，否则会报错。这是因为生成的Symbol是一个原始类型的值，不是对象。 instanceof的结果为false 12var s = Symbol('foo')console.log(s instanceof Symbol) // false Symbol函数可以接受一个字符串作为参数，表示对Symbol实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。 12var s1 = Symbol(foo)console.log(s1) // Symbol(foo) 如果Symbol的参数时一个对象，就会调用该对象的toString方法，将其转为字符串，然后才生成一个Symbol值。 1234567const obj = &#123; toString() &#123; return 'abc' &#125;&#125;const sym = Symbol(obj)console.log(sym) // Symbol(abc) Symbol函数的参数只是表示对当前Symbol值的描述，相同参数的Symbol函数的返回值时不相等的。 1234567891011// 没有参数的情况var s1 = Symbol()var s2 = Symbol()console.log(s1 === s2) // false// 有参数的情况var s1 = Symbol('foo')var s2 = Symbol('foo')console.log(s1 === s2) // false Symbol值不能与其他类型的值进行运算，会报错。 12var sym = Symbol('My Symbol')console.log('Your Symbol is ' + sym) // TypeError: can't convert symbol to string Symbol值可以显示转为字符串 123var sym = Symbol('My Symbol')console.log(String(sym)); // 'Symbol(My Symbol)'console.log(sym.toString()); // 'Symbol(My Symbol)' Symbol值可以作为标识符，用于对象的属性名，可以保证不会出现同名的属性 1234567891011121314151617var mySymbol = Symbol()// 第一种写法var a = &#123;&#125;a[mySymbol] = 'Hello!'// 第二种写法var a = &#123; [mySymbol]: 'Hello!'&#125;// 第三种写法var a = &#123;&#125;Object.defineProperty(a, mySybol, &#123; value: 'Hello!' &#125;)// 以上写法都得到同样结果console.log(a[mySymbol]) // 'Hello!' Symbol作为属性名，该属性不会出现在for…in、for…of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回。但是，它也不是私有属性，有一个Object.getOwnPropertySymbols方法，可以获取指定对象的所以Symbol属性名。 12345678910var obj = &#123;&#125;var a = Symbol('a')var b = Symbol('b')obj[a] = 'Hello'obj[b] = 'World'var objectSymbols = Object.getOwnPropertySymbols(obj)console.log(objectSymbols) // [Symbol(a), Symbol(b)] 如果我们希望使用同一个Symbol值，可以使用Symbol.for。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的Symbol值。如果有，就返回这个Symbol值，否则就新建并返回一个该字符串为名称的Symbol值。 1234var s1 = Symbol.for('foo')var s2 = Symbol.for('foo')console.log(s1 === s2) Symbol.keyFor方法返回一个已登记的Symbol类型值的key。 12345var s1 = Symbol.for('foo')console.log(Symbol.keyFor(s1)) // 'foo'var s2 = Symbol('foo')console.log(Symbol.keyFor(s2)) // undefined 分析看完以上的特性，你觉得哪些特性是可以模拟实现的呢？ 如果我们要模拟实现一个 Symbol 的话，基本的思路就是构建一个 Symbol 函数，然后直接返回一个独一无二的值。 不过在此之前，我们先看看规范中调用 Symbol 时到底做了哪些工作： Symbol ( [ description ] )When Symbol is called with optional argument description, the following steps are taken: If NewTarget is not undefined, throw a TypeError exception. If description is undefined, var descString be undefined. Else, var descString be ToString(description). ReturnIfAbrupt(descString). Return a new unique Symbol value whose [[Description]] value is descString. 当调用 Symbol 的时候，会采用以下步骤： 如果使用 new ，就报错 如果 description 是 undefined，让 descString 为 undefined 否则 让 descString 为 ToString(description) 如果报错，就返回 返回一个新的唯一的 Symbol 值，它的内部属性 [[Description]] 值为 descString 考虑到还需要定义一个 [[Description]] 属性，如果直接返回一个基本类型的值，是无法做到这一点的，所以我们最终还是返回一个对象。 第一版参照着规范，其实我们已经开始写起来了： 1234567891011121314151617181920212223242526272829// 第一版(function() &#123; var root = this var SymbolPolyfill = function Symbol(description) &#123; // 实现特性第二点：Symbol函数前不能使用new命令 if (this instanceof SymbolPolyfill) &#123; throw new TypeError('Symbol is not a constructor') &#125; // 实现特性第五点：如果Symbol的参数是一个对象，就会调用该对象的toString方法，将其转为字符串，然后才生成一个Symbol值。 var descString = description === undefined ? undefined : String(description) var symbol = Object.create(null) Object.defineProperties(symbol, &#123; '__Description__': &#123; value: descString, writable: false, enumerable: false, configurable: false &#125; &#125;) // 实现特性第六点：因为调用该方法，返回的是一个新对象，两个对象之间，只要引用不用，就不会相等 return symbol &#125; root.SymbolPolyfill = SymbolPolyfill()&#125;)() 只需要参照规范，我们已经实现了特性的第2、5、6点。 第二版我们来看看其他的特性该如何实现： 使用typeof，结果为’symbol’ 利用ES5，我们并不能修改typeof操作符的结果，所以这个无法实现。 instanceof的结果为false 因为不是通过new的方式实现的，所以instanceof的结果自然是false Symbol函数可以接受一个字符串作为参数，表示对Symbol实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。 当我们打印一个原生Symbol值的时候： 1console.log(Symbol('1')) // Symbol(1) 可时我们模拟实现的时候返回的确实一个对象，所以这个也是无法实现的，当然你修改console.log这个方法就是另讲。 Symbol值可以显式转为字符串 1234var sym = Symbol('My symbol');console.log(String(sym)); // 'Symbol(My symbol)'console.log(sym.toString()); // 'Symbol(My symbol)' 当调用 String 方法的时候，如果该对象有 toString 方法，就会调用该 toString 方法，所以我们只要给返回的对象添加一个 toString 方法，即可实现这两个效果。 12345678// 第二版// 前面代码相同var symbol = Object.create(&#123; toString: function() &#123; return 'Sybol(' + this.__Description__ + ')' &#125;,&#125;)// 后面代码相同 第三版 Symbol值可以作为标识符，用于对象的属性名，可以保证不会出现同名的属性。 看着好像没什么，这点其实和第8点是冲突的，这是因为当我们模拟的所谓Symbol值其实是一个有着toString方法的对象，当对象作为对象的属性名的时候，就会进行隐式类型转换，还是会调用我们添加的toString方法，对于 Symbol(‘foo’) 和 Symbol(‘foo’)两个 Symbol 值，虽然描述一样，但是因为两个对象，所以并不相等，但是当作为对象的属性名的时候，都会隐式转换为ymbol(foo) 字符串，这个时候就会造成同名的属性。举个例子： 12345678910var a = SymbolPolyfill('foo')var b = SymbolPolyfill('foo')console.log(a === b) // falsevar o = &#123;&#125;o[a] = 'hello'o[b] = 'world'console.log(o) // &#123; Symbol(foo): 'world' &#125; 为了防止不会出现同名的属性，毕竟这是一个非常重要的特性，迫不得已，我们需要修改toString方法，让它返回一个唯一值，所以第八点就无法实现了，而且我们还需要再写一个用来生成唯一值的方法，就命名为generateName，我们将该唯一值添加到返回对象的Name属性中保存下俩。 12345678910111213141516171819202122232425262728293031323334353637383940414243// 第三版(function() &#123; var root = this var generateName = (function() &#123; var postfix = 0 return function(descString) &#123; postfix++ return '@@' + descString + '_' + postfix &#125; &#125;)() var SymbolPolyfill = function Symbol(description) &#123; if (this instanceof SymbolPolyfill) throw new TypeError('Symbol is not a constructor'); var descString = description === undefined ? undefined : String(description) var symbol = Object.create(&#123; toString: function() &#123; return this.__Name__; &#125; &#125;) Object.defineProperties(symbol, &#123; '__Description__': &#123; value: descString, writable: false, enumerable: false, configurable: false &#125;, '__Name__': &#123; value: generateName(descString), writable: false, enumerable: false, configurable: false &#125; &#125;); return symbol; &#125; root.SymbolPolyfill = SymbolPolyfill&#125;)() 此时再看下这个例子： 12345678910var a = SymbolPolyfill('foo');var b = SymbolPolyfill('foo');console.log(a === b); // falsevar o = &#123;&#125;;o[a] = 'hello';o[b] = 'hi';console.log(o); // Object &#123; "@@foo_1": "hello", "@@foo_2": "hi" &#125; 第四版我们再看看接下来的特性。 Symbol值不能与其他类型的值进行运算，会报错 以 + 操作符为例,当进行隐式类型转换的时候，会先调用对象的valueOf方法，如果没有返回基本值就会再调用toString方法，所以我们考虑再valueOf方法中进行报错，比如： 1234567var symbol = Object.create(&#123; valueOf: function() &#123; throw new Error('Cannot convert a Symbol value') &#125;&#125;)console.log('1' + symbol) // 报错 看着很简单的解决这个问题，可是如果我们是显示调用valueOf方法呢》对于一个原生的Symbol值： 12var s1 = Symbol('foo')console.log(s1.valueOf()) // Symbol(foo) 是的，对于原生Symbol，显示的调用valueOf方法，会直接返回该Symbol值，而我们又无法判断是显式还是隐式的调用，所以这个我们就只能实现一半，要不然实现隐式调用报错，要不然实现显式调用返回该值，那……我们选择不报错的那个吧，即后者。 我们迫不得已的修改 valueOf 函数： 123456789101112// 第四版// 前面面代码相同 ……var symbol = Object.create(&#123; toString: function() &#123; return this.__Name__; &#125;, valueOf: function() &#123; return this; &#125;&#125;);// 后面代码相同 …… 第五版 Symbol 作为属性名，该属性不会出现在 for…in、for…of 循环中，也不会被 Object.keys()、Object.getOwnPropertyNames()、JSON.stringify() 返回。但是，它也不是私有属性，有一个 Object.getOwnPropertySymbols 方法，可以获取指定对象的所有 Symbol 属性名。 嗯，无法实现。 有时，我们希望重新使用同一个Symbol值，Symbol.for方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的Symbol值。如果有，就返回这个Symbol值，否则就新建并返回一个以该字符串为名称的Symbol值。 这个实现类似与函数记忆，我们建立一个对象，用来存储已经船舰的Symbol值即可 Symbol.ketFor方法返回一个已登记的Symbol类型值的key 面临forMap查找该值对应的键值即可。 12345678910111213141516171819202122232425262728// 第五版// 前面代码相同......var SymbolPolyfill = function() &#123; ... &#125;var forMap = &#123;&#125;Object.defineProperties(SymbolPolyfill, &#123; 'for': &#123; value: function(description) &#123; var descString = description === undefined ? undefined : String(description) return forMap[descString] ? forMap[descString] : forMap[descString] = SymbolPolyfill(descString) &#125;, writable: true, enumerable: false, configurable: true &#125;, 'keyFor': &#123; value: function(symbol) &#123; for (var key in forMap) &#123; if (forMap[key] === symbol) return key &#125; &#125;, writable: true, enumerable: false, configurable: true &#125;&#125;)// 后面代码相同..... 完整实现综上所述： 无法实现的特性：1、4、7、8、10 可以实现的特性：2、3、5、6、9、11、12 最后的实现如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970(function() &#123; var root = this var generateName = (function() &#123; var postdix = 0 return function(descString) &#123; postfix++ return '@@' + descString + '_' + postfix &#125; &#125;)() var SymbolPolyfill = function Symbol(description) &#123; if (this instanceof SymbolPolyfill) &#123; throw new TypeError('Symbol is not a contructor') &#125; var descString = description === undefined ? undefined : String(description) var symbol = Object.create(&#123; toString: function() &#123; return this.__Name__ &#125;, valueOf: function() &#123; return this &#125; &#125;) Object.defineProperties(symbol, &#123; '__Description__': &#123; value: descString, writable: false, enumerabel: false, configurable: false &#125;, '__Name__': &#123; value: generateName(descString), writable: false, enumerable: false, configurable: false &#125; &#125;) return symbol &#125; var forMap = &#123;&#125; Object.defineProperties(SymbolPolyfill, &#123; 'for': &#123; value: function(description) &#123; var descString = description === undefined ? undefined : String(description) return forMap[descString] ? forMap[descString] : forMap[descString] = SymbolPolyfill(descString) &#125;, writable: true, enumerable: false, configurable: true &#125;, 'keyFor': &#123; value: function(symbol) &#123; for (var key in forMap) &#123; if (forMap[key] === symbol) &#123; return key &#125; &#125; &#125;, writable: true, enumerable: false, configurable: true &#125; &#125;) root.SymbolPolyfill = SymbolPolyfill&#125;)()]]></content>
  </entry>
  <entry>
    <title><![CDATA[ES6系列之箭头函数]]></title>
    <url>%2F2019%2F09%2F13%2FES6%E7%B3%BB%E5%88%97%E4%B9%8B%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[我们先来回顾下箭头函数的基本语法。 1let func = value =&gt; value 相当于： 123let func = function(value) &#123; return value&#125; 如果需要给函数传入多个参数： 1let func = (value, num) =&gt; value + num 如果函数的代码块需要多条语句： 123let func = (value, num) =&gt; &#123; return value * num&#125; 如果需要直接返回一个对象： 1let func = (value, num) =&gt; (&#123;total: value * num&#125;) 与变量解构结合： 123456789let func = (&#123;value, num&#125;) =&gt; (&#123;total: value * num&#125;))// 使用var result = func(&#123; value: 10, num: 10&#125;)console.log(result) // &#123;total: 100&#125; 比较我们重点比较一下箭头函数与普通函数。主要区别有： 没有this 箭头函数没有this，所有需要通过查找作用域链来确定this的值。 这就意味着如果箭头函数被非箭头函数包含，this绑定的就是最近一次非箭头函数的this/ 模拟一个实际开发中的例子。 我们的需求是点击一个按钮，改变该按钮的背景色。 为了方便开发，我们抽离一个Button组件，当需要使用的时候，直接： 12// 传入元素id值即可绑定该元素点击时改变背景色的事件new Button('button') HTML代码如下： 123&lt;button id="button"&gt; 点击变色&lt;/button&gt; JavaScript代码如下： 1234567891011121314function Button(id) &#123; this.element = document.querySelector('#' + id) this.bindEvent()&#125;Button.prototype.bindEvent = function() &#123; this.element.addEventListener('click', this.setBgColor, false)&#125;Button.prototype.setBgColor = function() &#123; this.element.sytle.backgroundColor = '#1abc9c'&#125;var button = new Button('button') 看着好像没有问题，结果却是报错 Uncaught TypeError: Cannot read property &#39;style&#39; of undefined。 这是因为当使用addEventListener()为一个元素注册事件的时候，事件函数里的this值是该元素的引用。 所有如果我们在setBgColor中console.log(this)，this指向的是按钮元素，那this.element就是undefined，报错自然就理所当然了。 也许你会问，既然this都指向了按钮元素，那我们直接修改setBgColor函数为： 123Button.prototype.setBgColor = function() &#123; this.style.backgroundColor = '#1abc9c'&#125; 确实可以这样做，但是在实际的开发中，我们可能会在setBgColor中还调用其他的函数，比如写成这种： 1234Button.prototype.setBgColor = function() &#123; this.setElementColor() this.setOtherElementColor()&#125; 所以我们还是希望setBgColor中的this是指向实例对象的，这样就可以调用其他的函数。 利用ES5，我们一般会这样做： 123Button.prototype.bindEvent = function() &#123; this.element.addEventListener('click', this.setBgColor.bind(this), false)&#125; 为了避免addEventListener的影响，使用bind强制绑定setBgColor()的this为实例对象。 使用ES6，我们可以更好的解决这个问题： 123Button.prototype.bindEvent = function() &#123; this.element.addEventListener('click', event =&gt; this.setBgColor(event), false)&#125; 由于箭头函数没有this，所以会向外层查找this的值，即bindEvent中的this，此时this指向实例对象，所以可以正确的调用this.setBgColor方法。而this.setBgColor中的this也会正确指向实例对象。 在这里再额外提一点，就是注意bindEvent和setBgColor在这里使用的是普通函数的形式，而非箭头函数，如果我们改成箭头函数，会导致函数里的this指向window对象（非严格模式下）。 最后，因为箭头函数没有this，所以也不能用call()、apply()、bind()这些方法改变this的指向，可以看一个例子： 123var value = 1var result = (() =&gt; this.value).bind(&#123;value: 2&#125;)()console.log(result) 没有arguments 箭头函数没有自己的arguments对象，这不一定是件坏事，因为箭头函数可以访问外围函数的arguments对象： 123456function constant() &#123; return () =&gt; arguments[0]&#125;var result = constant(1)console.log(result()) // 1 那如果我们就是要访问箭头函数的参数呢？ 我们可以通过命名参数或rest参数的形式访问参数。 1let nums = (...nums) =&gt; nums 不能通过new关键字调用 JavaScript函数有两个内部方法：[[Call]]和[[Construct]] 当通过new调用函数时，执行[[Construct]]方法，创建一个实例对象，然后再执行函数体，将this绑定到实例上。 当直接调用的时候，执行[[Call]]方法，直接执行函数体。 箭头函数并没有[[Construct]]方法，不能被用作构造函数，如果通过new的方式调用，会报错。 12var Foo = () =&gt; &#123;&#125;var foo = new Foo() // TypeError: Foo is not a constructor 没有new.target 因为不能使用new调用，所以也没有new.target值。 没有原型 由于不能使用new调用箭头函数，所以也没有构建原型的需求，于是箭头函数也不存在prototype这个属性。 12var Foo = () =&gt; &#123;&#125;console.log(Foo.prototype) // undefined 没有super 连原型都没有，自然也不饿能通过super来访问原型的属性，所以箭头函数也没有super的，不过跟this、arguments、new.target一样，这些值有外围最近一层非箭头函数 决定。 总结最后，关于箭头函数，引用 MDN 的介绍就是： An arrow function expression has a shorter syntax than a function expression and does not have its own this, arguments, super, or new.target. These function expressions are best suited for non-method functions, and they cannot be used as constructors. 翻译过来就是： 箭头函数表达式的语法比函数表达式更短，并且不绑定自己的this，arguments，super或 new.target。这些函数表达式最适合用于非方法函数(non-method functions)，并且它们不能用作构造函数。 那么什么是 non-method functions 呢？ 我们先来看看 method 的定义： A method is a function which is a property of an object. 对象属性中的函数就被称之为 method，那么 non-mehtod 就是指不被用作对象属性中的函数了，可是为什么说箭头函数更适合 non-method 呢？ 让我们来看一个例子就明白了： 123456789var obj = &#123; i: 10, b: () =&gt; console.log(this.i, this), c：function() &#123; console.log(this.i, this) &#125;&#125;obj.b() // undefined Windowobj.c() // 10, Object &#123;...&#125; 自执行函数自执行函数的形式： 123(function() &#123; console.log(1)&#125;)() 或者： 123(function() &#123; console.log(1)&#125;()) 利用箭头简化自执行函数的写法： 123(() =&gt; &#123; console.log(1)&#125;)() 但是注意：使用以下这种写法却会报错： 123(() =&gt; &#123; console.log(1)&#125;())]]></content>
  </entry>
  <entry>
    <title><![CDATA[模板字符串]]></title>
    <url>%2F2019%2F09%2F13%2FES6%E7%B3%BB%E5%88%97%E4%B9%8B%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[## 基础语法 12let message = `Hello World`console.log(message) 如果需要在字符串中使用反撇号，可以使用反斜杠转义： 12let message = `Hello \` World`console.log(message) 值得一提的是，在模板字符串中，空格、缩进、换行都会被保留： 1234567let message = ` &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt;`console.log(message) 注意，打印的结果中第一行是一个换行，你可以使用trim函数消除换行： 1234567let message = ` &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt;`.trim()console.log(message) 嵌入变量模板字符串支持嵌入变量，只需要将变量名写在${}之中，其实不止变量，任意的JavaScript表达式都是可以的： 123let x =1, y = 2let message = `&lt;ul&gt;&lt;li&gt;$&#123;x&#125;&lt;/li&gt;&lt;li&gt;$&#123;x + y&#125;&lt;/li&gt;&lt;/ul&gt;`;console.log(message); // &lt;ul&gt;&lt;li&gt;1&lt;/li&gt;&lt;li&gt;3&lt;/li&gt;&lt;/ul&gt; 值得一提的是，模板字符串支持嵌套： 1234567891011let arr = [&#123;value: 1&#125;, &#123;value: 2&#125;];let message = ` &lt;ul&gt; $&#123;arr.map((item) =&gt; &#123; return ` &lt;li&gt;$&#123;item.value&#125;&lt;/li&gt; ` &#125;)&#125; &lt;/ul&gt;`;console.log(message); 打印结果如下： 注意，在li标签中间多了个逗号，这是因为当大括号中的值不是字符串时，会将其转为字符串，比如一个数组[1, 2, 3]就会被转为1, 2, 3，逗号就是这样产生的。 如果要消除这个逗号，我们可以先join一下： 1234567891011let arr = [&#123;value: 1&#125;, &#123;value: 2&#125;];let message = ` &lt;ul&gt; $&#123;arr.map((item) =&gt; &#123; return ` &lt;li&gt;$&#123;item.value&#125;&lt;/li&gt; ` &#125;).join(&apos;&apos;)&#125; &lt;/ul&gt;`;console.log(message); 打印结果如下： 标签模板模板标签时一个非常重要的能力，模板字符串可以紧跟一个函数名后面，该函数将被调用来处理这个模板字符串，举个例子： 123let x = 'Hi', y = 'Kevin'var res = message`$&#123;x&#125;, I am $&#123;y&#125;`console.log(res) 我们可以定义message函数来处理返回的字符串： 1234567// literals 文字// 注意在这个例子中literals的第一个元素和最后一个元素都是空字符串function message(literals, value1, value2) &#123; console.log(literals) console.log(value1) console.log(value2)&#125; 我们利用这些参数将其拼回去： 1234567891011function message(literals, ...values) &#123; let result = '' for (let i = 0, i &lt; values.length; i++) &#123; result += literals[i] result += values[i] &#125; result += literals[literals.length - 1] return result&#125; 我也可以这样写： 1234567function message(literals, ...values) &#123; let result = literals.reduce((prev, next, i) =&gt; &#123; let value = values[i - 1] return prev + value + next &#125;) return result&#125; 学着拼合回去是一件非常重要的事情，因为我们经过各种处理，最终都还是要拼回去的…… oneLine讲完基础，我们可以来看一些实际的需求： 123456let message = ` Hi, Daisy! I am Kevin.`; 出于可能性 或者其他原因，我希望书写的时候是换行的，但是最终输出的字符是在一行，这就需要借助模板标签来实现了，我们尝试写一个这样的函数： 1234567891011// oneLine 第一版function oneLine(template, ...expressions) &#123; let result = template.reduce(prev, next, i) =&gt; &#123; let expression = expressions[i - 1] return prev + expression + next &#125; result = result.replace(/(\s+)/g, " ") result = result.trim() return result&#125; 实现原理很简单，拼合回去然后将多个空白符如换行符、空格等替换成一个空格。 使用如下： 1234567let message = oneLine ` Hi, Daisy! I am Kevin.`;console.log(message); // Hi, Daisy! I am Kevin. 不过你再用下去就会发现一个问题，如果字符间就包括多个空格呢？举个例子： 1234let message = oneLine` Preserve eg sentences. Double spaces within input lines.`; 如果使用这种匹配方式，sentences. 与 Double 之间的两个空格也会被替换成一个空格。 我们可以再优化一下，我们想要的效果是将每行前面的多个空格替换成一个空格，其实应该匹配的是换行符以及换行符后面的多个空格，然后将其替换成一个空格，我们可以将正则改成： 1result = result.replace(/(\n\s*)/g, " "); 就可以正确的匹配代码。最终的代码如下： 123456789101112// oneLine 第二版function oneLine(template, ...expressions) &#123; let result = template.reduce((prev, next, i) =&gt; &#123; let expression = expressions[i - 1]; return prev + expression + next; &#125;); result = result.replace(/(\n\s*)/g, " "); result = result.trim(); return result;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[ES6系列之let和const]]></title>
    <url>%2F2019%2F09%2F13%2FES6%E7%B3%BB%E5%88%97%E4%B9%8Blet%E5%92%8Cconst%2F</url>
    <content type="text"><![CDATA[通过 var声明的变量存在变量提升的特性： 12345if (condition) &#123; var value = 1&#125;console.log(value) 初学者可能会觉得只有condition为true的时候，才会创建value，如果condition为false，结果应该是报错，然而因为变量提升的原因，代码相当于： 123456var valueif (condition) &#123; value = 1&#125;console.log(value) 如果condition为false，结果会是undefined。 除此之外，在for循环中： 12345for (var i = 0; i &lt; 10; i++) &#123; ···&#125;console.log(i) 为了加强对变量生命周期的控制，ECMAScript6引入块级作用域。 块级作用域存在于： 函数内部 块中（字符 { 和 } 之间的区域） let和const块级声明用于声明在指定块的作用域之外无法访问的变量。 let和const都是块级声明的一种。 我们来回顾下let和const的特点。 不会被提升 12345if (false) &#123; let valur = 1&#125;console.log(value) // Uncaught ReferenceError: value is not defined 重复声明报错 12var value = 1var value = 2 // Uncaught SyntaxError: Identifier 'value' has already been declared 不绑定全局作用域 当在全局作用域中使用var声明的时候，会创建一个新的全局变量作为全局对象的属性。 12var value = 1console.log(window.value) // 1 然而，let和const不会： 12let value = 1console.log(window.value) // undefined 再来说下let和const的区别： const用于声明常量，其值一旦被设定不能再被修改，否则会报错 值得一提的是：const声明不允许修改绑定，但允许修改值，这意味着当用const声明对象时： 12345678910const data = &#123; value: 1&#125;// 没问题data.value = 2data.num = 3// 报错data = &#123;&#125; // Uncaught TypeError: Assignment to constant variable. 暂时死区临时死区（Temporal Dead Zone），简称为TDZ。 let和const声明的变量不会被提升到作用域顶部，如果在声明之前访问这些变量，会导致报错： 12console.log(typeof value) // Uncaught ReferenceError: value is not definedlet value = 1 这是因为JavaScript引擎在扫描代码发现变量声明时，要么将它们提升到作用域顶部（遇到var声明），要么将声明放在TDZ中（遇到let和const声明）。访问TDZ中的变量会触发运行时错误。只有执行过变量声明语句后，变量才会从TDZ中移除，然后方可访问。 看似很好理解，不保证不会犯错： 12345678910111213var value = 'global'// 例子1(function() &#123; console.log(value) let value = 'local'&#125;())// 例子2&#123; console.log(value) const value = 'local'&#125; 两个例子中，结果并不会打印’global’，而是报错Uncaught ReferenceError: value is not defined，就是因为 TDZ 的缘故。 循环中的块级作用域1234567var funcs = []for (var i = 0, i &lt; 3; i++) &#123; funcs[i] = function () &#123; console.log(i) &#125;&#125;funcs[0]() // 3 一个老生常谈的面试题，解决方案如下： 123456789var funcs = []for (var i = 0; i &lt; 3; i++) &#123; funcs[i] = (function(i) &#123; return function() &#123; console.log(i) &#125; &#125;(i))&#125;funcs[0]() // 0 ES6的let为这个问题提供了新的解决方案： 1234567var funcs = []for (let i = 0; i &lt; 3; i++) &#123; function[i] = function () &#123; console.log(i) &#125;&#125;funcs[0]() // 0 问题在于，上面讲了let不提升，不能重复声明，不能绑定全局作用域等等特性，可是为什么在这里就能正确打印出i值呢？ 如果是不重复声明，在循环第二次的时候，又用let声明了i，应该报错呀，就算因为某种原因，重复声明不报错，一遍一遍迭代，i的值最终还应该是3呀。 设置循环变量的那个部分是一个单独的作用域，就比如： 1234567for (let i = 0; i &lt; 3; i++) &#123; let i = 'abc' console.log(i)&#125;// abc// abc// abc 这个例子是对的，如果我们把let改成var呢？ 12345for (var i = 0; i &lt; 3; i++) &#123; var i = 'abc' console.log(i)&#125;// abc 为什么结果就不一样了呢，如果有单独的作用域，结果应该是相同的 如果要追究这个问题，就要抛弃掉之前所讲的这些特性！这是因为 let 声明在循环内部的行为是标准中专门定义的，不一定就与 let 的不提升特性有关，其实，在早期的 let 实现中就不包含这一行为。 我们会发现，在for循环中使用let和var，底层会使用不同的处理方式。 那么当使用let的时候底层到底是怎样做的呢？ 简单的来说，就是在 for (let i = 0; i &lt; 3; i++) 中，即圆括号之内建立一个隐藏的作用域，这就可以解释为什么： 1234567for (let i = 0; i &lt; 3; i++) &#123; let i = 'abc' console.log(i)&#125;// abc// abc// abc 然后每次迭代循环时都创建一个新变量，并以之前迭代中同名变量的值将其初始化。这样对于下面这样一段代码： 1234567var funcs = []for (let i = 0; i &lt; 3; i++) &#123; funcs[i] = function () &#123; console.log(i) &#125;&#125;funcs[0]() // 0 就相当于： 123456789101112131415161718// 伪代码(let i = 0) &#123; funcs[0] = function() &#123; console.log(i) &#125;;&#125;(let i = 1) &#123; funcs[1] = function() &#123; console.log(i) &#125;;&#125;(let i = 2) &#123; funcs[2] = function() &#123; console.log(i) &#125;;&#125;; 当执行函数的时候，根据词法作用域就可以找到正确的值，其实也可以理解为let声明模仿了闭包的做法来简化循环过程。 循环中的let和const不过到这里还没有结束，如果我们把let改成const呢？ 1234567var funcs = [];for (const i = 0; i &lt; 10; i++) &#123; funcs[i] = function () &#123; console.log(i); &#125;;&#125;funcs[0](); // Uncaught TypeError: Assignment to constant variable. 结果会是报错，因为虽然我们每次都创建了一个新的变量，然而我们在迭代中尝试修改const的值，所有最终会报错。 说完了普通的for循环，我们还有for in 循环。 那下面的结果时什么呢？ 12345678var funcs = [], object = &#123;a: 1, b: 1, c: 1&#125;;for (var key in object) &#123; funcs.push(function()&#123; console.log(key) &#125;);&#125;funcs[0]() 结果是’c’ 那如果把 var 改成 let 或者 const 呢？ 使用 let，结果自然会是 ‘a’，const 呢？ 报错还是 ‘a’? 结果是正确打印 ‘a’，这是因为在 for in 循环中，每次迭代不会修改已有的绑定，而是会创建一个新的绑定。]]></content>
  </entry>
  <entry>
    <title><![CDATA[数组去重]]></title>
    <url>%2F2019%2F09%2F10%2FJavaScript%E4%B8%93%E9%A2%98%E4%B9%8B%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%2F</url>
    <content type="text"><![CDATA[数组去重的方法： 双重循环也许我们先想到的是使用indexOf来循环判断一遍，但是再这个方法之前，让我们先看看最原始的方法： 12345678910111213141516171819var array = [1, 1, '1', '1']function unique(array) &#123; // res用来存储结果 for (var i = 0, arrayLen = array.length; i &lt; arrayLen; i++) &#123; for (var j = 0, resLen = res.length; j &lt; resLen; j++) &#123; if (array[i] === res[j]) &#123; break; &#125; &#125; // 如果array[i]是唯一的，那么执行完循环，j等于resLen if (j === resLen) &#123; res.push(array[i]) &#125; &#125; return res&#125;console.log(unique(array)) // [1, '1'] 在这个方法中，我们使用循环嵌套，最外层循环array，里面循环res，如果array[i]的值res[j]的值相等就跳出循环，如果都不等于，说明元素是唯一的，这时候j的值就会等于res的长度，根据这个特点进行判断，将值添加进res。 indexOf我们可以用indexOf简化内层的循环 1234567891011121314var array = [1, 1, '1', '1']function unique(array) &#123; var res = [] for (var i = 0, len = array.length; i &lt; len; i++) &#123; var current = array[i] if (res.indexOf(current) === -1) &#123; res.push(current) &#125; &#125; return res;&#125;console.log(unique(array)) 排序后去重‘试想我们先将要去重的数组使用sort方法排序后，相同的值就会被排在一起，然后我们就可以只判断当前元素与上一个元素是否相同，相同就说明重复，不相同就添加进res，让我们写个demo： 1234567891011121314151617var array = [1, 1, '1', '1']function unique(array) &#123; var res = [] var sortedArray = array.concat().sort() var seen for (var i = 0, len = sortedArray.length; i &lt; len; i++) &#123; // 如果是第一个元素或者相邻的元素不相同 if (!i || seen !== sortedArray[i]) &#123; res.push(sortedArray[i]) &#125; seen = sortedArray[i] &#125; return res&#125;console.log(unique(array)) 如果我们对一个已经排好序的数组去重，这种方法效率肯定高于使用indexOf。 unique API知道了这两种方法后，我们可以去尝试写一个名为unique的工具函数，我们根据一个参数isSorted判断传入的数组是否是已排序的，如果为true，我们就判断相邻元素是否相同，如果为false，我们就使用indexOf进行判断。 123456789101112131415161718192021222324var array1 = [1, 2, '1', 2, 1]var array2 = [1, 1, '1', 2, 2]// 第一版function unique(array, isSorted) &#123; var res = [] var seen = [] for (var i = 0, len = array.length; i &lt; len; i++) &#123; var value = array[i] if (isSorted) &#123; if (!i || seen !== value) &#123; res.push(value) &#125; seen = value &#125; else if (res.indexOf(value) === -1) &#123; res.push(value) &#125; &#125; return res&#125;console.log(unique(array1)) // [1, 2, '1']console.log(unique(array2, true)) // [1, '1', 2] 优化尽管unique已经可以试下去重功能，但是为了让这个API更加强大，我们来考虑一个需求： 字母的大小写视为一致，比如’a‘和’A‘，保留一个就可以了。 虽然我们可以先处理数组种的所有数据，比如将所有的字母转成小写，然后再传入unique函数，但是有没有方法可以省掉处理数组的这一循环，直接就在去重的循环中做呢？ 1234567891011121314151617181920212223var array3 = [1, 1, 'a', 'A', 2, 2]// 第二版function unique(array, isSorted, iteratee) &#123; var value = array[i] var computed = iteratee ? itertee(value, i, array) : value if (isSorted) &#123; if (!i || seen !== computed) &#123; res.push(value) &#125; seen = computed &#125; else if (iteratee) &#123; if (seen.indexOf(computed) === -1) &#123; seen.push(computed) res.push(value) &#125; &#125; else if (res.indexOf(value) === -1) &#123; res.push(value) &#125; return res&#125;console.log(unique(array3, false, function(item) &#123; return typeof item == 'string' ? item.toLowerCase() : item&#125;)) 在这一版中，函数传递了三个参数： array：表示要去重的数组 isSorted：表示函数传入的数组是否已排过序，如果为true，将会采用更快的方法进行去重 iteratee：传入一个函数，可以对每个函数进行重新的计算，然后根据处理的结果进行去重 filterES5提供了filter方法，我们可以用来简化外层函数： 比如使用indexOf的方法： 12345678910var array = [1, 2, 1, 1, '1']function unique(array) &#123; var res = array.filter(function(item, index, array) &#123; return array.indexOf(item) === index &#125;) return res&#125;console.log(unique(array)) 排序去重的方法： 123456789var array = [1, 2, 1, 1, '1']function unique(array) &#123; return array.concat().sort().filter(function(item, index, array) &#123; return !index || item !== array[index - 1] &#125;)&#125;console.log(unique(array)) Object键值对去重的方法众多，尽管我们写了个uniqueAPI，但是让我们看看其他的方法拓展下视野： 这种方法是利用一个空的Object对象，我们把数组的值存成Object的key值，比如Object[value1] = true，在判断另一个值的时候，如果Object[value2]存在的话，就说明该值是重复的。示例代码如下： 12345678910var array = [1, 2, 1, 1, '1']function unique(array) &#123; var obj = &#123;&#125; return array.filter(function(item, index, array)&#123; return obj.hasOwnProperty(item) ? false : (obj[item] = true) &#125;)&#125;console.log(unique(array)) // [1, 2] 我们可以发现是有问题的，因为1和‘1’是不同的，但是这种方法会判断为同一个值，这是因为对象的键值只能是字符串，所有我们可以使用typeof item + item拼成字符串作为key值来避免这个问题： 12345678910var array = [1, 2, 1, 1, '1']function unique(array) &#123; var obj = &#123;&#125; return array.filter(function(item, index ,array) &#123; return obj.hasOwnProperty(typeof item + item) ? false : (obj[typeof item + item] = true) &#125;)&#125;console.log(unique(array)) // [1, 2, '1'] 然而，即便如此，我们依然无法正确区别两个对象，比如{value: 1}和{value: 2}，因为typeof item + item 的结果都会是 object[object Object]，不过我们可以使用 JSON.stringify 将对象序列化： 1234567891011var array = [&#123;value: 1&#125;, &#123;value: 1&#125;, &#123;value: 2&#125;]function unique(array) &#123; var obj = &#123;&#125; return array.filter(function(item, index, array) &#123; console.log(typeof item + JSON.stringify(item)) return obj.hasOwnProperty(typeof item + JSON.stirngify(item)) ? false : (obj[typeof item + JSON.stringify(item)] = true) &#125;)&#125;console.log(unique(array)) // [&#123;value: 1&#125;, &#123;value: 2&#125;] ES6随着ES6的到来，去重的方法又有了进展，比如我们可以使用Set和Map数据结构，以Set为例，ES6提供了新的数据结构Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。 1234567var array = [1, 2, 1, 1, '1']function unique(array) &#123; return Array.from(new Set(array))&#125;console.log(unique(array)) // [1, 2, '1'] 甚至可以再简化下： 123function unique(array) &#123; return [...new Set(array)]&#125; 还可以再简化下： 1var unique = (a) =&gt; [...new Set(a)] 此外，如果用Map的话： 1234function unique(arr) &#123; const seen = new Map() return arr.filter((a) =&gt; !seen,has(a) &amp;&amp; seen.set(a, 1))&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[节流]]></title>
    <url>%2F2019%2F09%2F10%2FJavaScript%E4%B8%93%E9%A2%98%E4%B9%8B%E8%8A%82%E6%B5%81%2F</url>
    <content type="text"><![CDATA[节流的原理：如果你持续触发事件，每隔一段时间，只执行一次事件。根据首次是否执行以及结束后是否执行，效果有所不同，实现的方式也有所不同。我们用leading代表首次是否执行，trailing代表结束后是否再执行一次。 关于节流的实现，有两种主流的实现方式，一种是使用时间戳，一种是设置时间器。 使用时间戳让我们来看第一种方法：使用时间戳，当触发事件的时候，我们取出当前的时间戳，然后减去之前的事件戳（最一开始设为0），如果大于设置的时间周期就执行函数，然后更新时间戳为当前的时间戳，如果小于，就不执行。 123456789101112131415// 第一版function throttle(func, wait) &#123; var context, args; var previous = 0; return function() &#123; var now = +new Date(); context = this; args = arguments; if (now - previous &gt; wait) &#123; func.apply(context, args); previous = now; &#125; &#125;&#125; 例子依然是用讲 debounce 中的例子，如果你要使用： 1container.onmousemove = throttle(getUserAction, 1000); 效果演示如下： 我们可以看到：当鼠标移入的时候，事件立刻执行，每过 1s 会执行一次，如果在 4.2s 停止触发，以后不会再执行事件。 使用定时器接下来，我们讲讲第二种实现方式，使用定时器。 当触发事件的时候，我们设置一个定时器，再触发事件的时候，如果定时器存在就不执行，直到定时器执行然后执行函数，清空定时器，这样就可以设置下个定时器。 1234567891011121314151617// 第二版function throttle(func, wait) &#123; var timeout; var previous = 0; return function() &#123; context = this; args = arguments; if (!timeout) &#123; timeout = setTimeout(function()&#123; timeout = null; func.apply(context, args) &#125;, wait) &#125; &#125;&#125; 为了让效果更加明显，我们设置wait的时间为3s，效果演示如下： 我们可以看到：当鼠标移入的时候，事件不会立刻执行，晃了3s后终于执行了一次，此后每3s执行一次，当数字显示为3的时候，立刻移除鼠标，相当于大约 9.2s 的时候停止触发，但是依然会在第 12s 的时候执行一次事件。 所以比较两个方法： 第一种事件会立刻执行，第二种事件会在 n 秒后第一次执行 第一种事件停止触发后没有办法再执行事件，第二种事件停止触发后依然会再执行一次事件 双剑合璧那我们想要一个什么样的呢？ 有人就说了：我想要一个有头有尾的！就是鼠标移入能立刻执行，停止触发的时候还能再执行一次！ 所以我们综合两者的优势，然后双剑合璧，写一版代码： 12345678910111213141516171819202122232425262728293031// 第三版function throttle(func, wait) &#123; var timeout, context, args, result; var previous = 0; var later = function() &#123; previous = +new Date(); timeout = null; func.apply(context, args) &#125;; var throttled = function() &#123; var now = +new Date(); //下次触发 func 剩余的时间 var remaining = wait - (now - previous); context = this; args = arguments; // 如果没有剩余的时间了或者你改了系统时间 if (remaining &lt;= 0 || remaining &gt; wait) &#123; if (timeout) &#123; clearTimeout(timeout); timeout = null; &#125; previous = now; func.apply(context, args); &#125; else if (!timeout) &#123; timeout = setTimeout(later, remaining); &#125; &#125;; return throttled;&#125; 效果演示如下： 我们可以看到：鼠标移入，事件立刻执行，晃了3s，事件再一次执行，当数字变成3的时候，也就是6s后，我们立刻移出鼠标，停止触发事件，9s的时候，依然会再执行一次事件。 优化但是如果我们需要无头有尾，或者有头无尾的情况，如何是好？ 那我们设置个options作为第三个参数，然后根据传的值判断到底哪种效果，我们约定： leading：false 表示禁用第一次执行 trailing：false 表示禁用停止触发的回调 我们来改一下代码： 123456789101112131415161718192021222324252627282930313233// 第四版function throttle(func, wait, options) &#123; var timeout, context, args, result; var previous = 0; if (!options) options = &#123;&#125;; var later = function() &#123; previous = options.leading === false ? 0 : new Date().getTime(); timeout = null; func.apply(context, args); if (!timeout) context = args = null; &#125;; var throttled = function() &#123; var now = new Date().getTime(); if (!previous &amp;&amp; options.leading === false) previous = now; var remaining = wait - (now - previous); context = this; args = arguments; if (remaining &lt;= 0 || remaining &gt; wait) &#123; if (timeout) &#123; clearTimeout(timeout); timeout = null; &#125; previous = now; func.apply(context, args); if (!timeout) context = args = null; &#125; else if (!timeout &amp;&amp; options.trailing !== false) &#123; timeout = setTimeout(later, remaining); &#125; &#125;; return throttled;&#125; 取消在 debounce 的实现中，我们加了一个 cancel 方法，throttle 我们也加个 cancel 方法： 1234567891011121314151617181920212223242526272829303132333435363738// 第五版 function throttle(func, wait, options) &#123; var timeout, context, args, result; var previous = 0; if (!options) options = &#123;&#125;; var later = function() &#123; previous = options.leading === false ? 0 : new Date().getTime(); timeout = null; func.apply(context, args); if (!timeout) context = args = null; &#125;; var throttled = function() &#123; var now = new Date().getTime(); if (!previous &amp;&amp; options.leading === false) previous = now; var remaining = wait - (now - previous); context = this; args = arguments; if (remaining &lt;= 0 || remaining &gt; wait) &#123; if (timeout) &#123; clearTimeout(timeout); timeout = null; &#125; previous = now; func.apply(context, args); if (!timeout) context = args = null; &#125; else if (!timeout &amp;&amp; options.trailing !== false) &#123; timeout = setTimeout(later, remaining); &#125; &#125;; throttled.cancel = function() &#123; clearTimeout(timeout); previous = 0; timeout = null; &#125; return throttled;&#125; 注意我们要注意 underscore 的实现中有这样一个问题： 那就是 leading：false 和 trailing: false 不能同时设置。 如果同时设置的话，比如当你将鼠标移出的时候，因为 trailing 设置为 false，停止触发的时候不会设置定时器，所以只要再过了设置的时间，再移入的话，就会立刻执行，就违反了 leading: false，bug 就出来了，所以，这个 throttle 只有三种用法： 1234567container.onmousemove = throttle(getUserAction, 1000);container.onmousemove = throttle(getUserAction, 1000, &#123; leading: false&#125;);container.onmousemove = throttle(getUserAction, 1000, &#123; trailing: false&#125;);]]></content>
  </entry>
  <entry>
    <title><![CDATA[防抖]]></title>
    <url>%2F2019%2F09%2F09%2FJavaScript%E4%B8%93%E9%A2%98%E4%B9%8B%E9%98%B2%E6%8A%96%2F</url>
    <content type="text"><![CDATA[在前端开发中会遇到一些频繁的事件触发，比如： window的resize、scroll mousedown、mousemove keyup、keydown …… 为此，我们举个示例代码来了解事件如何频繁的触发： 我们写个index.html文件： 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang="zh-cmn-Hans"&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta http-equiv="x-ua-compatible" content="IE=edge, chrome=1"&gt; &lt;title&gt;debounce&lt;/title&gt; &lt;style&gt; #container&#123; width: 100%; height: 200px; line-height: 200px; text-align: center; color: #fff; background-color: #444; font-size: 30px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="container"&gt;&lt;/div&gt; &lt;script src="debounce.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; debounce.js文件的代码如下： 12345678var count = 1;var container = document.getElementById('container');function getUserAction() &#123; container.innerHTML = count++;&#125;;container.onmousemove = getUserAction; 我们来看看效果： 从左边滑到右边就触发了165次getUserAction函数！ 因为这个例子很简单，所有浏览器完全反应的过来，可是如果是复杂的回调函数或是ajax请求呢？假设1秒触发了60次，每个回调就必须在1000 / 60 = 16.67ms内完成，否则就会有卡顿出现。 为了解决这个问题，一般有两种解决方案： debounce防抖 throttle节流 防抖防抖的原理是：你尽管触发事件，但是我一定在事件触发n秒后才执行，如果你在一个事件触发的n秒内又触发了这个事件，那我就以新的事件的时间为准，n秒后才执行，总之，就是等你触发完事件n秒内不再触发事件，我才执行，真是任性啊！ 第一版 根据这段表述，我们可以写第一版的代码： 12345678// 第一版function debounce(func, wait) &#123; var timeout; return function () &#123; clearTimeout(timeout) timeout = setTimeout(func, wait); &#125;&#125; 如果我们要使用它，以最开始的例子为例： 1container.onmousemove = debounce(getUserAction, 1000); 现在随你怎么移动，反正你移动完 1000ms 内不再触发，我才执行事件。看看使用效果： 顿时就从 165 次降低成了 1 次! this 如果我们在getUserAction函数中console.log(this)，在不使用debounce函数的时候，this的值为： 1&lt;div id="container"&gt;&lt;/div&gt; 但是如果使用我们的debouce函数，this就会指向Window对象！ 所有我们需要将this指向正确的对象。 12345678910111213// 第二版function debounce(func, wait) &#123; var timeout; return function () &#123; var context = this; clearTimeout(timeout) timeout = setTimeout(function()&#123; func.apply(context) &#125;, wait); &#125;&#125; 现在 this 已经可以正确指向了。让我们看下个问题： event对象 JavaScript在事件处理函数中会提供事件对象event，我们修改下getUserAction函数： 1234function getUserAction(e) &#123; console.log(e); container.innerHTML = count++;&#125;; 如果我们不使用debouce函数，这里会打印MouseEvent对象，如图所示： 但是在我们实现的 debounce 函数中，却只会打印undefined！ 所有我们再修改一下代码： 1234567891011121314// 第三版function debounce(func, wait) &#123; var timeout; return function () &#123; var context = this; var args = arguments; clearTimeout(timeout) timeout = setTimeout(function()&#123; func.apply(context, args) &#125;, wait); &#125;&#125; 到此为止，我们修复了两个小问题： this指向 event对象 立即执行 这个时候，代码已经很完善了，到是为了让这个函数更加完善，我们接下来思考一个新的需求。 这个需求就是： 我不希望非要等到事件停止触发后才执行，我希望立即执行函数，然后等到停止触发n秒后，才可以重新触发执行。 对此我们加个immediate参数判断是否是立刻执行。 12345678910111213141516171819202122232425// 第四版function debounce(func, wait, immediate) &#123; var timeout; return function () &#123; var context = this; var args = arguments; if (timeout) clearTimeout(timeout); if (immediate) &#123; // 如果已经执行过，不再执行 var callNow = !timeout; timeout = setTimeout(function()&#123; timeout = null; &#125;, wait) if (callNow) func.apply(context, args) &#125; else &#123; timeout = setTimeout(function()&#123; func.apply(context, args) &#125;, wait); &#125; &#125;&#125; 再来看看使用效果： 返回值 此时需要注意，就是getUserAction函数可能是有返回值的，所有我们也要返回函数的执行结果，但是但immediate为false的时候，因为使用了setTimeout，我们将func.apply(context, args)的返回值赋给变量，最后再return的时候，值将会一直是undefined，所有我们只在immediate为true的时候返回函数的执行结果。 1234567891011121314151617181920212223242526/ 第五版function debounce(func, wait, immediate) &#123; var timeout, result; return function () &#123; var context = this; var args = arguments; if (timeout) clearTimeout(timeout); if (immediate) &#123; // 如果已经执行过，不再执行 var callNow = !timeout; timeout = setTimeout(function()&#123; timeout = null; &#125;, wait) if (callNow) result = func.apply(context, args) &#125; else &#123; timeout = setTimeout(function()&#123; func.apply(context, args) &#125;, wait); &#125; return result; &#125;&#125; 取消 最后我们再思考一个小需求，我希望能取消debounce函数，比如说我debounce的使劲按间隔是10秒钟，immediate为true，这样的话，我只有的等10秒后重新触发事件，现在我希望有一个按钮，点击后，取消防抖，这样我再去触发，就可以立即执行了。 为了这个需求，我们写最后一版的代码： 123456789101112131415161718192021222324252627282930313233/ 第六版function debounce(func, wait, immediate) &#123; var timeout, result; var debounced = function () &#123; var context = this; var args = arguments; if (timeout) clearTimeout(timeout); if (immediate) &#123; // 如果已经执行过，不再执行 var callNow = !timeout; timeout = setTimeout(function()&#123; timeout = null; &#125;, wait) if (callNow) result = func.apply(context, args) &#125; else &#123; timeout = setTimeout(function()&#123; func.apply(context, args) &#125;, wait); &#125; return result; &#125;; debounced.cancel = function() &#123; clearTimeout(timeout); timeout = null; &#125;; return debounced;&#125; 那么该如何使用这个 cancel 函数呢？依然是以上面的 demo 为例： 1234567891011121314var count = 1;var container = document.getElementById('container');function getUserAction(e) &#123; container.innerHTML = count++;&#125;;var setUseAction = debounce(getUserAction, 10000, true);container.onmousemove = setUseAction;document.getElementById("button").addEventListener('click', function()&#123; setUseAction.cancel();&#125;) 演示效果如下：]]></content>
  </entry>
  <entry>
    <title><![CDATA[透彻掌握Promise]]></title>
    <url>%2F2019%2F09%2F02%2F%E9%80%8F%E5%BD%BB%E6%8E%8C%E6%8F%A1Promise%2F</url>
    <content type="text"><![CDATA[在实际的使用中，有非常多的应用场景我们不能立即知道应该如何继续往下执行。最重要也是最主要的一个场景就是ajax场景。通俗的说，由于网速的不同，可能你得到的返回值时间也是不同的，这个时候我们就需要等待，结果出来了之后才知道怎么样继续下来。 1234567891011121314// 简单的ajax原生实现var url = 'https://hq.tigerbrokers.com/fundamental/finance_calendar/getType/2017-02-26/2017-06-10';var result;var XHR = new XMLHttpRequest();XHR.open('GET', url, true);XHR.send();XHR.onreadystatechange = function() &#123; if (XHR.readyState == 4 &amp;&amp; XHR.status == 200) &#123; result = XHR.response; console.log(result); &#125;&#125; 在ajax的原生实现中，利用了onreadystatechange事件，当该事件触发并且符合一定条件时，才能拿到我们想要的数据，之后我们才能开始处理数据。 这样做看上去并没有什么麻烦，但是如果这个时间，我们还需要做另一个ajax请求，这个新的ajax的其中一个参数，要从上一个ajax请求中获取，这个时间我们就要这样做。 12345678910111213141516171819202122var url = 'https://hq.tigerbrokers.com/fundamental/finance_calendar/getType/2017-02-26/2017-06-10';var result;var XHR = new XMLHttpRequest();XHR.open('GET', url, true);XHR.send();XHR.onreadystatechange = function() &#123; if (XHR.readyState == 4 &amp;&amp; XHR.status == 200) &#123; result = XHR.response; console.log(result); // 伪代码 var url2 = 'http:xxx.yyy.com/zzz?ddd=' + result.someParams; var XHR2 = new XMLHttpRequest(); XHR2.open('GET', url, true); XHR2.send(); XHR2.onreadystatechange = function() &#123; ... &#125; &#125;&#125; 当出现第三个ajax（甚至更多）依然依赖上一个请求的时候，我们的代码就变成了一场灾难。这场灾难往往被称为回调地狱。 因此我们需要一个叫做Promise的东西来解决这个问题。 当然除了回调地狱之外，我们还有一个非常重要的需求：为了我们的代码更具可读性与可维护性，我们需要将数据请求与数据处理明确的区分开来。上面的写法时完全没有区分来，当数据变得复杂时，也许我们自己都无法轻松维护自己的代码了。这也是模块化过程中，必须要掌握的一个重要的技能。 当我们想要确保某代码在谁谁之后执行时，我们可以利用函数调用栈，将我们想要执行的代码放入回调函数中。 12345678910111213// 一个简单的封装function want() &#123; console.log('这是你想要执行的代码');&#125;function fn(want) &#123; console.log('这里表示执行了一大堆各种代码'); // 其他代码执行完毕，最后执行回调函数 want &amp;&amp; want();&#125;fn(want); 利用回调函数封装，是我们在初学JavaScript时常常会使用的技能。 确保我们想要的代码压后执行，除了利用函数调用栈的执行顺序之外，还可以利用事件队列机制。 1234567891011function want() &#123; console.log('这是你想要执行的代码');&#125;function fn(want) &#123; // 将想要执行的代码放入队列中，根据事件循环的机制，我们就不用非得将它放到最后面了，由你自由选择 want &amp;&amp; setTimeout(want, 0); console.log('这里表示执行了一大堆各种代码');&#125;fn(want); 如果浏览器已经支持了原生的Promise对象，那么我们就知道，浏览器的JS引擎里已经有了Promise队列，这样就可以利用Promise将任务放在它的队列中去。 123456789101112131415161718192021222324function want() &#123; console.log('这是你想要执行的代码');&#125;function fn(want) &#123; console.log('这里表示执行了一大堆各种代码'); // 返回Promise对象 return new Promise(function(resolve, reject) &#123; if (typeof want == 'function') &#123; resolve(want); &#125; else &#123; reject('TypeError: '+ want +'不是一个函数') &#125; &#125;)&#125;fn(want).then(function(want) &#123; want();&#125;)fn('1234').catch(function(err) &#123; console.log(err);&#125;) 看上去变得更加复杂了，但是代码变得更加健壮，处理了错误输入的情况。 为了更好的往下扩展Promise的应用，这里需要先跟大家介绍一下Promsie的基础知识。 Promise对象有三种状态，他们分别是： pending: 等待中，或者进行中，表示还没有得到结果 resolved(Fulfilled): 已经完成，表示得到了我们想要的结果，可以继续往下执行 rejected: 也表示得到结果，但是由于结果并非我们所愿，因此拒绝执行 这三种状态不受外界影响，而且状态只能从pending改变为resolved或者rejected，并且不可逆。在Promise对象的构造函数中，将一个函数作为第一个参数。而这个函数，就是用来处理Promise的状态变化。 1234new Promise(function(resolve, reject) &#123; if(true) &#123; resolve() &#125;; if(false) &#123; reject() &#125;;&#125;) 上面的resolved和reject都为一个函数，它们的作用分别是将状态修改为resolved和reject。 Promise对象中的then方法，可以接收构造函数中处理的状态变化，并分别对应执行。then方法有2个参数，第一个函数接收resolved状态的执行，第二个参数接收reject状态的执行。 12345678910111213141516function fn(num) &#123; return new Promise(function(resolve, reject) &#123; if (typeof num == 'number') &#123; resolve(); &#125; else &#123; reject(); &#125; &#125;).then(function() &#123; console.log('参数是一个number值'); &#125;, function() &#123; console.log('参数不是一个number值'); &#125;)&#125;fn('hahha');fn(1234); then方法的执行结果也会返回一个Promise对象。因此我们还可以继续then的链式执行，这也是解决回调地狱的主要方式。 123456789101112131415161718function fn(num) &#123; return new Promise(function(resolve, reject) &#123; if (typeof num == 'number') &#123; resolve(); &#125; else &#123; reject(); &#125; &#125;) .then(function() &#123; console.log('参数是一个number值'); &#125;) .then(null, function() &#123; console.log('参数不是一个number值'); &#125;)&#125;fn('hahha');fn(1234); then(null, function() {}) 就等同于catch(function() {}) Promise中的数据传递 大家自行从下面的例子中领悟： 123456789101112131415161718192021222324252627var fn = function(num) &#123; return new Promise(function(resolve, reject) &#123; if (typeof num == 'number') &#123; resolve(num); &#125; else &#123; reject('TypeError'); &#125; &#125;)&#125;fn(2).then(function(num) &#123; console.log('first: ' + num); return num + 1;&#125;).then(function(num) &#123; console.log('second: ' + num); return num + 1;&#125;).then(function(num) &#123; console.log('third: ' + num); return num + 1;&#125;);// 输出结果first: 2second: 3third: 4 OK，了解了这些基础知识之后，我们再回过头，利用Promise的知识，对最开始的ajax的例子进行一个简单的封装。看看会是什么样子。 123456789101112131415161718192021222324252627var url = 'https://hq.tigerbrokers.com/fundamental/finance_calendar/getType/2017-02-26/2017-06-10';// 封装一个get请求的方法function getJSON(url) &#123; return new Promise(function(resolve, reject) &#123; var XHR = new XMLHttpRequest(); XHR.open('GET', url, true); XHR.send(); XHR.onreadystatechange = function() &#123; if (XHR.readyState == 4) &#123; if (XHR.status == 200) &#123; try &#123; var response = JSON.parse(XHR.responseText); resolve(response); &#125; catch (e) &#123; reject(e); &#125; &#125; else &#123; reject(new Error(XHR.statusText)); &#125; &#125; &#125; &#125;)&#125;getJSON(url).then(resp =&gt; console.log(resp)); 为了健壮性，处理了很多可能出现的异常，总之，就是正确的返回结果，就resolve一下，错误的返回结果，就reject一下。并且利用上面的参数传递的方式，将正确结果或者错误信息通过他们的参数传递出来。 现在所有的库几乎都将ajax请求利用Promise进行了封装，因此我们在使用jQuery等库中的ajax请求时，都可以利用Promise来让我们的代码更加优雅和简单。这也是Promise最常用的一个场景，因此我们一定要非常非常熟悉它，这样才能在应用的时候更加灵活。 Promise.all 当有一个ajax请求，它的参数需要另外2个甚至多个请求都要有返回结果之后才能确定，那么这个时候，就需要用到Promise.all来帮助我们应对这个场景。 Promise.all接收一个Promise对象组成的数组作为参数，当这个数组所有的Promise对象状态都变成resolved或者reject的时候，它才会去调用then方法。 1234567891011var url = 'https://hq.tigerbrokers.com/fundamental/finance_calendar/getType/2017-02-26/2017-06-10';var url1 = 'https://hq.tigerbrokers.com/fundamental/finance_calendar/getType/2017-03-26/2017-06-10';function renderAll() &#123; return Promise.all([getJSON(url), getJSON(url1)]);&#125;renderAll().then(function(value) &#123; // 建议大家在浏览器中看看这里的value值 console.log(value);&#125;) Promise.race 与Promise.all相似的是，Promise.race都是以一个Promise对象组成的数组作为参数，不同的是，只要当数组中的其中一个Promise状态变成resolved或者rejected时，就可以调用then方法了。而传递给then方法的值也会有所不同。 1234567function renderRace() &#123; return Promise.race([getJSON(url), getJSON(url1)]);&#125;renderRace().then(function(value) &#123; console.log(value);&#125;)]]></content>
  </entry>
  <entry>
    <title><![CDATA[详解面向对象、构造函数、原型与原型链]]></title>
    <url>%2F2019%2F09%2F02%2F%E8%AF%A6%E8%A7%A3%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E3%80%81%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%2F</url>
    <content type="text"><![CDATA[## 对象的定义 在ECMAScript-262中，对象被定义为“无无序属性的集合，其属性可以包含基本值、对象或者函数”。 也就是说，在JavaScript中对象无非就是由一些无序的key-value对组成。其中value可以是基本值，对象或者函数。 1234567// 这里的person就是一个对象var person = &#123; name: 'Tom', age: 18, getName: function() &#123;&#125;, parent: &#123;&#125;&#125; 创建对象 我们可以通过构造函数的方式创建一个对象。 1var obj = new Object(); 也可以通过字面量的方式创建一个简单的对象。 1var obj = &#123;&#125;; 当我们想要给我们创建的简单对象添加方法时，可以这样表示。 1234567891011121314// 可以这样var person = &#123;&#125;;person.name = "TOM";person.getName = function() &#123; return this.name;&#125;// 也可以这样var person = &#123; name: "TOM", getName: function() &#123; return this.name; &#125;&#125; 访问对象的属性和方法。 加入我们有一个简单的对象，如下所示。 1234567ar person = &#123; name: 'TOM', age: '20', getName: function() &#123; return this.name &#125;&#125; 当我们想要访问他的name属性时，可以用如下两种方式访问。 1234person.name// 或者person['name'] 如果我们想要访问的属性名是一个变量时，常常会使用第二种方式。例如我们要同时访问person的name与age，可以这样写： 123['name', 'age'].forEach(function(item) &#123; console.log(person[item]);&#125;) 这种方式一定要重视，记住它以后在我们处理复杂数据的时候会有很大的帮助。 工厂模式使用上面的方式创建对象很简单，但是在很多时候并不能满足我们的需求，就以person对象为例。加入我们在实例开发中，不仅仅需要一个名字叫做TOM的person对象，同时还需要另外一个名为Jake的person对象，虽然它们很多相似之处，但是我们不得不重复写两次。 123456789101112131415var perTom = &#123; name: 'TOM', age: 20, getName: function() &#123; return this.name &#125;&#125;;var perJake = &#123; name: 'Jake', age: 22, getName: function() &#123; return this.name &#125;&#125; 但显然这并不是合理的方式，当相似的对象太多时，大家都会崩溃。 所以我们可以使用工厂模式的方式解决这个问题。顾名思义，工厂模式就是我们提供一个模子，然后通过这个模子复制出我们需要的对象。我们需要多少个，就复制多少个。 123456789101112131415161718var createPerson = function(name, age) &#123; // 声明一个中间对象，该对象就是工厂模式的模子 var o = new Object(); // 依次添加我们需要的属性与方法 o.name = name; o.age = age; o.getName = function() &#123; return this.name; &#125; return o;&#125;// 创建两个实例var perTom = createPerson('TOM', 20);var PerJake = createPerson('Jake', 22); 相信上面的代码并不难理解。也不用吧工厂模式看的太过高大上了。很显然。工厂模式帮助我们解决了重复代码上的麻烦，让我们可以写很少的代码，就能够创建很多个person对象。但是这里还有两个麻烦需要我们注意。 第一个就是我们这样处理是无法识别对象实例的类型。使用instanceof可以识别对象的类型，如下例子： 12345var obj = &#123;&#125;;var foo = function() &#123;&#125;console.log(obj instanceof Object); // trueconsole.log(foo instanceof Function); // true 因此在工厂模式的基础上，我们需要使用构造函数的方式来解决这个麻烦。 构造函数在JavaScript中，new关键字 可以让一个函数变得与众不同。通过下面的例子。我们来一探new关键字的神奇之处。 123456function demo() &#123; console.log(this);&#125;demo(); // windownew demo(); // demo 为了能够直观的感受它们的不同，建议大家动手实践观察一下。很显然，使用new之后函数内部发生了一些变化，让this指向改变。那么new关键字到底做了什么事情呢。 1234567891011121314151617181920212223242526272829303132333435363738// 先一本正经的创建一个构造函数，其实该函数与普通函数并无区别var Person = function(name, age) &#123; this.name = name; this.age = age; this.getName = function() &#123; return this.name; &#125;&#125;// 将构造函数以参数形式传入function New(func) &#123; // 声明一个中间对象，该对象为最终返回的实例 var res = &#123;&#125;; if (func.prototype !== null) &#123; // 将实例的原型指向构造函数的原型 res.__proto__ = func.prototype; &#125; // ret为构造函数执行的结果，这里通过apply，将构造函数内部的this指向修改为指向res，即为实例对象 var ret = func.apply(res, Array.prototype.slice.call(arguments, 1)); // 当我们在构造函数中明确指定了返回对象时，那么new的执行结果就是该返回对象 if ((typeof ret === "object" || typeof ret === "function") &amp;&amp; ret !== null) &#123; return ret; &#125; // 如果没有明确指定返回对象，则默认返回res，这个res就是实例对象 return res;&#125;// 通过new声明创建实例，这里的p1，实际接收的正是new中返回的resvar p1 = New(Person, 'tom', 20);console.log(p1.getName());// 当然，这里也可以判断出实例的类型了console.log(p1 instanceof Person); // true JavaScript内部再通过其他的一些特殊处理，将var p1 = New(Person, &#39;tom&#39;, 20); 等效于var p1 = new Person(&#39;tom&#39;, 20);。就是我们认识的new关键字了。具体怎么处理的，我也不知道，别刨根问底了，一直回答下去太难 - -！ 为了能够判断实例与对象的关系，我们就使用构造函数来搞定。 123456789101112var Person = function(name, age) &#123; this.name = name; this.age = age; this.getName = function() &#123; return this.name; &#125;&#125;var p1 = new Person('Ness', 20);console.log(p1.getName()); // Nessconsole.log(p1 instanceof Person); // true 关于构造函数，如果你暂时不能够理解new的具体实现，就先记住下面这几个结论吧。 与普通函数相比，构造函数并没有任何特别的地方，首字母大写只是我们约定的小规定，用于区分普通函数； new关键字让构造函数具有了与普通函数不同的许多特点，而new的过程中，执行了如下过程： 声明一个中间对象； 将该中间对象的原型指向构造函数的原型； 将构造函数的this，指向该中间对象； 返回该中间对象，即返回实例对象。 原型虽然构造函数解决了判断实例类型的问题，但是说到底，这还是一个对象的复制过程。跟工厂模式颇有相似之处。也就是说。当我们声明了100个person对象，那么就有100个getName方法被重新生成。 这里的每一个getName方法实现的原理其实是一模一样的。但是由于分别属于不同的实例，就不得不一直为getName分配空间。这就是工厂模式存在的第二个麻烦。 对此，我们需要使用原型对象帮我们解决。 我们创建的每一个函数，都可以由一个prototype属性，该属性指向一个对象。这个对象就是我们这里说的原型。 当我们在创建对象时，可以根据自己的需求，选择性的将一些属性和方法通过prototype属性，挂载到原型对象上。而每一个new出来的实例，都有一个__proto__属性，该属性指向构造函数的原型对象，通过这个对象，让实例对象也能够访问原型对象上的方法。因此，当所有的实例都能够通过__proto__访问到原型对象时，原型对象的方法与属性就变成了共有方法与属性。 我们通过一个简单的例子与图示，来了解构造函数、实例与原型三者之间的关系。 1234567891011121314// 声明构造函数function Person(name, age) &#123; this.name = name; this.age = age;&#125;// 通过prototye属性，将方法挂载到原型对象上Person.prototype.getName = function() &#123; return this.name;&#125;var p1 = new Person('tim', 10);var p2 = new Person('jak', 22);console.log(p1.getName === p2.getName); // true 通过图示我们可以看出，构造函数的prototype与所有实例对象的__proto__都指向原型对象。而原型对象的constructor指向构造函数。 除此之外，还可以从图中看出，实例对象实际上对前面我们所说的中间对象的复制，而中间对象中的属性与方法都在构造函数中添加。于是根据构造函数与原型的特性，我们就可以将在构造函数中，通过this声明的属性与方法称为私有变量与方法，它们被当前被某一个实例对象所独有。而通过原型声明的属性与方法，我们可以称之为共有属性与方法，它们可以被所有的实例对象访问。 当我们访问实例对象中的属性或者方法时，会优先访问实例对象自身的属性与方法。 123456789101112131415function Person(name, age) &#123; this.name = name; this.age = age; this.getName = function() &#123; console.log('this is constructor.'); &#125;&#125;Person.prototype.getName = function() &#123; return this.name;&#125;var p1 = new Person('tim', 10);p1.getName(); // this is constructor. 在这个例子中，我们同时在原型与构造函数中都声明了一个getName函数，运行代码的结果表示原型中的访问并没有被访问。 我们还可以通过in来判断。一个对象是否拥有某一个属性或者方法，无论时该属性/方法存在与实例对象还是原型对象。 123456789101112function Person(name, age) &#123; this.name = name; this.age = age;&#125;Person.prototype.getName = function() &#123; return this.name;&#125;var p1 = new Person('tim', 10);console.log('name' in p1); // true in的这种特性最常用的场景之一，就是判断当前页面是否在移动端打开。 123isMobile = 'ontouchstart' in document;// 很多人喜欢用浏览器UA的方式来判断，但并不是很好的方式 更简单的原型写法 根据前面的例子的写法，如果我们要在原型上添加更多的方法，可以这样写， 123456unction Person() &#123;&#125;Person.prototype.getName = function() &#123;&#125;Person.prototype.getAge = function() &#123;&#125;Person.prototype.sayHello = function() &#123;&#125;... ... 除此之外，我还可以使用更为简单的写法。 12345678function Person() &#123;&#125;Person.prototype = &#123; constructor: Person, getName: function() &#123;&#125;, getAge: function() &#123;&#125;, sayHello: function() &#123;&#125;&#125; 这种字面量的写法看上去简单很多，但是有一个需要特别注意的地方。Person.prototype = {}实际上是重新创建了一个{}对象并赋值给Person.prototype，这里的{}并不是最初的那个原型对象。因此它里面并不包含constructor属性。为了保证正确性，我们必须在新创建的{}对象中显示的设置constructor的指向。即上面的constructor: Person。 原型链原型对象其实也是普通的对象。几乎所有的对象都可能是原型对象，也可能是实例对象。而且还可以同时是原型对象与实例对象。这样的一个对象，正是构成原型链的一个节点。因此理解了原型。那么原型链并不是一个多么复杂的概念。 我们知道所有的函数都有一个叫做toString的方法。那么这个方法到底是在那里的呢？ 先随意声明一个函数 1function add() &#123;&#125; 那么我们可以用如下的图来表示这个函数的原型链。 原型链 其中add是Function对象的实例。而Function的原型对象同时又是Object原型的实例。这样就构成了一条原型链。原型链的访问，其实跟作用域链有很大的相似之处，他们都是一次单向的查找过程。因此实例对象能够通过原型链，访问到处于原型链上对象的所有属性与方法。这也是foo最终能够访问到处于Object原型对象上的toString方法的原因。 基于原型链的特性，我们可以很轻松的实现继承。 继承我们常常结合构造函数与原型来创建一个对象，因为构造函数与原型的不同特性，分别解决了我们不同的困扰。因此当我们想要实现继承时，就必须根据构造函数与原型的不同而采取不同的策略。 我们声明一个Person对象，该对象将作为父级，而子级cPerson将要继承Person的所有属性与方法。 12345678function Person(name, age) &#123; this.name = name; this.age = age;&#125;Person.prototype.getName = function() &#123; return this.name;&#125; 首先我们来看构造函数的继承，在上面我们已经了解了构造函数的本质，它其实是在new内部实现的一个复制过程。而我们在继承时想要的是，让父级构造函数中的操作在子级的构造函数中重现一遍即可。我们可以通过call方法来达到目的。 12345// 构造函数的继承function cPerson(name, age, job) &#123; Person.call(this, name, age); this.job = job;&#125; 而原型的继承，则只需要将子级的原型对象设置为父级的一个实例，加入到原型链中即可。 12345// 继承原型cPerson.prototype = new Person(name, age);// 添加更多方法cPerson.prototype.getLive = function() &#123;&#125; 当然关于继承还有更好的方式。 更好的继承假设原型链的终点Object.prototype为原型链的E（end）端，原型链的起点为S（start）端。 通过前面原型链的学习我们知道，处于S端的对象，可以通过S-&gt;E的单向查找，访问到原型链上的所有方法与属性。因此这给继承提够了理论基础。我们只需要在S端添加新的对象，那么新对象就能够通过原型链访问到父级的方法与属性。 因为封装一个对象由构造函数与原型共同组成，因此继承也分别由构造函数的继承与原型的继承。 假设我们已经封装好了一个父类对象Person，如下。 123456789101112var Person = function(name, age) &#123; this.name = name; this.age = age;&#125;Person.prototype.getName = function() &#123; return this.name;&#125;Person.prototype.getAge = function() &#123; return this.age;&#125; 构造函数的继承比较简单，我们可以借助call/apply来实现。假设我们要通过继承封装一个Student的子类对象，那么构造函数可以如下实现。 12345678910111213var Student = function(name, age, grade) &#123; // 通过call方法还原Person构造函数中的所有处理逻辑 Student.call(Person, name, age); this.grade = grade;&#125;// 等价于var Student = function(name, age, grade) &#123; this.name = name; this.age = age; this.grade = grade;&#125; 原型的继承则稍微需要一点思考，首先我们应该考虑，如何将子类对象的原型加入到原型链中？我们只需要让子类对象的原型，成为父类对象的一个实例，然后通过_proto_就可以访问父类对象的原型。这样就继承了父类原型中的方法与属性了。 因此我们可以先封装一个方法，该方法根据父类对象的原型创建一个实例。该实例将会作为子类对象的原型。 1234567891011unction create(proto, options) &#123; // 创建一个空对象 var tmp = &#123;&#125;; // 让这个新的空对象成为父类对象的实例 tmp.__proto__ = proto; // 传入的方法都挂载到新对象上，新的对象将作为子类对象的原型 Object.defineProperties(tmp, options); return tmp;&#125; 简单封装了create对象之后，我们就可以使用该方法来实现原型的继承了。 1234567891011Student.prototype = create(Person.prototype, &#123; // 不要忘了重新指定构造函数 constructor: &#123; value: Student &#125; getGrade: &#123; value: function() &#123; return this.grade &#125; &#125;&#125;) 那么我们来验证一下我们这里实现的继承是否正确。 12345var s1 = new Student('ming', 22, 5);console.log(s1.getName()); // mingconsole.log(s1.getAge()); // 22console.log(s1.getGrade()); // 5 全部都能正常访问，没问题。在ECMAScript5中直接提供了Object.create方法来完成我们上面自己封装的create的功能。因此我们可以直接使用Object.create. 1234567891011tudent.prototype = create(Person.prototype, &#123; // 不要忘了重新指定构造函数 constructor: &#123; value: Student &#125; getGrade: &#123; value: function() &#123; return this.grade &#125; &#125;&#125;) 完整代码如下： 123456789101112131415161718192021222324252627282930313233343536function Person(name, age) &#123; this.name = name; this.age = age;&#125;Person.prototype.getName = function() &#123; return this.name&#125;Person.prototype.getAge = function() &#123; return this.age;&#125;function Student(name, age, grade) &#123; // 构造函数继承 Person.call(this, name, age); this.grade = grade;&#125;// 原型继承Student.prototype = Object.create(Person.prototype, &#123; // 不要忘了重新指定构造函数 constructor: &#123; value: Student &#125; getGrade: &#123; value: function() &#123; return this.grade &#125; &#125;&#125;)var s1 = new Student('ming', 22, 5);console.log(s1.getName()); // mingconsole.log(s1.getAge()); // 22console.log(s1.getGrade()); // 5 属性类型在上面的继承实现上，使用了一个大家可能不太熟悉的方法defineProperties。并且在定义getGrade时使用了一个很奇怪的方式。 12345getGrade: &#123; value: function() &#123; return this.grade &#125;&#125; 这其实是对象中的属性类型。在我们平常的使用中，给对象添加一个属性时，直接使用object.param的方式就可以了，或者直接在对象中挂载。 123var person = &#123; name: 'TOM'&#125; 在ECMAScript5中，对每个属性都添加几个属性类型，来描述这些属性的特点。 configurable: 表示该属性是否能被delete删除。当其值为false时，其他的特性也不能被改变。默认值为true enumerable: 是否能枚举。也就是是否能被for-in遍历。默认值为true writable: 是否能修改值。默认为true value: 该属性的具体值是多少。默认为undefined get: 当我们通过person.name访问name的值时，get将被调用。该方法可以自定义返回的具体值时多少。get默认值为undefined set: 当我们通过person.name = &#39;Jake&#39;设置name的值时，set方法将被调用。该方法可以自定义设置值的具体方式。set默认值为undefined 需要注意的是，不能同时设置value、writable 与 get、set的值。 我们可以通过Object.defineProperty方法来修改这些属性类型。 下面我们用一些简单的例子来演示一下这些属性类型的具体表现。 onfigurable 1234567891011121314151617181920212223// 用普通的方式给person对象添加一个name属性，值为TOMvar person = &#123; name: 'TOM'&#125;// 使用delete删除该属性delete person.name; // 返回true 表示删除成功// 通过Object.defineProperty重新添加name属性// 并设置name的属性类型的configurable为false，表示不能再用delete删除Object.defineProperty(person, 'name', &#123; configurable: false, value: 'Jake' // 设置name属性的值&#125;)// 再次delete，已经不能删除了delete person.name // falseconsole.log(person.name) // 值为Jake// 试图改变valueperson.name = "alex";console.log(person.name) // Jake 改变失败 enumerable 123456789101112131415161718192021222324252627var person = &#123; name: 'TOM', age: 20&#125;// 使用for-in枚举person的属性var params = [];for(var key in person) &#123; params.push(key);&#125;// 查看枚举结果console.log(params); // ['name', 'age']// 重新设置name属性的类型，让其不可被枚举Object.defineProperty(person, 'name', &#123; enumerable: false&#125;)var params_ = [];for(var key in person) &#123; params_.push(key)&#125;// 再次查看枚举结果console.log(params_); // ['age'] writable 12345678910111213141516171819var person = &#123; name: 'TOM'&#125;// 修改name的值person.name = 'Jake';// 查看修改结果console.log(person.name); // Jake 修改成功// 设置name的值不能被修改Object.defineProperty(person, 'name', &#123; writable: false&#125;)// 再次试图修改name的值person.name = 'alex';console.log(person.name); // Jake 修改失败 value 12345678var person = &#123;&#125;// 添加一个name属性Object.defineProperty(person, 'name', &#123; value: 'TOM'&#125;)console.log(person.name) // TOM get/set 12345678910111213141516171819202122var person = &#123;&#125;// 通过get与set自定义访问与设置name属性的方式Object.defineProperty(person, 'name', &#123; get: function() &#123; // 一直返回TOM return 'TOM' &#125;, set: function(value) &#123; // 设置name属性时，返回该字符串，value为新值 console.log(value + ' in set'); &#125;&#125;)// 第一次访问name，调用getconsole.log(person.name) // TOM// 尝试修改name值，此时set方法被调用person.name = 'alex' // alex in set// 第二次访问name，还是调用getconsole.log(person.name) // TOM 请尽量同时设置get、set。如果仅仅只设置了get，那么我们将无法设置该属性值。如果仅仅只设置了set，我们也无法读取该属性的值。 1234567891011121314151617181920Object.defineProperty`只能设置一个属性的属性特性。当我们想要同时设置多个属性的特性时，需要使用我们之前提到过的`Object.definePropertiesvar person = &#123;&#125;Object.defineProperties(person, &#123; name: &#123; value: &apos;Jake&apos;, configurable: true &#125;, age: &#123; get: function() &#123; return this.value || 22 &#125;, set: function(value) &#123; this.value = value &#125; &#125;&#125;)person.name // Jakeperson.age // 22 读取属性的特性值我们可以使用Object.getOwnPropertyDescriptor方法读取某一个属性的特性值。 123456789101112131415161718var person = &#123;&#125;Object.defineProperty(person, 'name', &#123; value: 'alex', writable: false, configurable: false&#125;)var descripter = Object.getOwnPropertyDescriptor(person, 'name');console.log(descripter); // 返回结果如下descripter = &#123; configurable: false, enumerable: false, value: 'alex', writable: false&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[深入理解函数的柯里化]]></title>
    <url>%2F2019%2F09%2F02%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%87%BD%E6%95%B0%E7%9A%84%E6%9F%AF%E9%87%8C%E5%8C%96%2F</url>
    <content type="text"><![CDATA[柯里化是函数的一个比较高级的应用，想要理解它并不简单。 柯里化是指一个函数（假设叫做createCurry），它接收函数A作为参数，运行后能够返回一个新的函数。并且这个新的函数能够处理函数A的剩余参数。 这样的定义可能不太好理解，我们先从下面的例子配合理解。 如果有一个接收三个参数的函数A： 123function A(a, b, c) &#123; // do something&#125; 又假如我们有一个已经封装好了的柯里化createCurry。它接收bar作为参数，能够将A转化为柯里化函数，返回结果就是这个被转化之后的函数。 1var _A = createCurry(A); 那么_A作为createCurry运行的返回函数，它能够处理A的剩余参数。因此下面的运行结果都是等价的。 12345_A(1, 2, 3);_A(1, 2)(3);_A(1)(2, 3);_A(1)(2)(3);A(1, 2, 3); 函数A被createCurry转化之后得到柯里化函数A，A能够处理A的所有剩余参数。因此柯里化也被成为部分求值。 在简单的场景下，我们可以不用借助柯里化通用式来转化得到柯里化函数，我们可以凭借眼力自己封装。 例如有一个简单的加法函数，他能够将自身的三个参数加起来并返回计算结果。 123function add(a, b, c) &#123; return a + b + c;&#125; 那么add函数的柯里化函数_add则可以如下： 1234567function _add(a) &#123; return function(b) &#123; return function(c) &#123; return a + b + c; &#125; &#125;&#125; 因此下面的运算方式是等价的。 12add(1, 2, 3);_add(1)(2)(3); 当然，柯里化通用式具备更加强大的能力，我们靠眼力自己封装的柯里化函数则自由度偏低。因此我们仍然需要知道自己如何去封装这样一个柯里化的通用式。 首先通过_add可以看出，柯里化函数的运行过程其实是一个参数的收集过程，我们将每一次传入的参数收集起来，并在最里层里面处理。因此我们在实现createCurry时，可以借助这个思路来进行封装。 封装如下: 12345678910111213141516171819// 简单实现，参数只能从右到左传递function createCurry(func, args) &#123; var arity = func.length; var args = args || []; return function() &#123; var _args = [].slice.call(arguments); [].push.apply(_args, args); // 如果参数个数小于最初的func.length，则递归调用，继续收集参数 if (_args.length &lt; arity) &#123; return createCurry.call(this, func, _args); &#125; // 参数收集完毕，则执行func return func.apply(this, _args); &#125;&#125; 尽管我已经做了足够详细的注解，但是我想理解起来也并不是那么容易，因此建议大家用点耐心多阅读几遍。这个createCurry函数的封装借助闭包与递归，实现了一个参数收集，并在收集完毕之后执行所有参数的一个过程。 因此聪明的读者可能已经发现，把函数经过createCurry转化为一个柯里化函数，最后执行的结果，不是正好相当于执行函数自身吗？柯里化是不是把简单的问题复杂化了？ 如果你能够提出这样的问题，那么说明你确实已经对柯里化有了一定的了解。柯里化确实是把简答的问题复杂化了，但是复杂化的同时，我们在使用函数时拥有了更加多的自由度。而这里对于函数参数的自由处理，正是柯里化的核心所在。 我们来举一个非常常见的例子。 如果我们想要验证一串数字是否是正确的手机号，那么按照普通的思路来做，大家可能是这样封装，如下： 123function checkPhone(phoneNumber) &#123; return /^1[34578]\d&#123;9&#125;$/.test(phoneNumber);&#125; 而如果我们想要验证是否是邮箱呢？这么封装： 123function checkEmail(email) &#123; return /^(\w)+(\.\w+)*@(\w)+((\.\w+)+)$/.test(email);&#125; 我们还可能会遇到验证身份证号，验证密码等各种验证信息，因此在实践中，为了统一逻辑，，我们就会封装一个更为通用的函数，将用于验证的正则与将要被验证的字符串作为参数传入。 123function check(targetString, reg) &#123; return reg.test(targetString);&#125; 但是这样封装之后，在使用时又会稍微麻烦一点，因为会总是输入一串正则，这样就导致了使用时的效率低下。 12check(/^1[34578]\d&#123;9&#125;$/, '14900000088');check(/^(\w)+(\.\w+)*@(\w)+((\.\w+)+)$/, 'test@163.com'); 那么这个时候，我们就可以借助柯里化，在check的基础上再做一层封装，以简化使用。 1234var _check = createCurry(check);var checkPhone = _check(/^1[34578]\d&#123;9&#125;$/);var checkEmail = _check(/^(\w)+(\.\w+)*@(\w)+((\.\w+)+)$/); 最后在使用的时候就会变得更加直观与简洁了。 12checkPhone('183888888');checkEmail('xxxxx@test.com'); 经过这个过程我们发现，柯里化能够应对更加复杂的逻辑封装。当情况变得多变，柯里化依然能够应付自如。 虽然柯里化确实在一定程度上将问题复杂化了，也让代码更加不容易理解，但是柯里化在面对复杂情况下的灵活性却让我们不得不爱。 当然这个案例本身情况还算简单，所以还不能够特别明显的凸显柯里化的优势，我们的主要目的在于借助这个案例帮助大家了解柯里化在实践中的用途。 我们继续来思考一个例子。这个例子与map有关。在高阶函数的章节中，我们分析了封装map方法的思考过程。由于我们没有办法确认一个数组在遍历时会执行什么操作，因此我们只能将调用for循环的这个统一逻辑封装起来，而具体的操作则通过参数传入的形式让使用者自定义。这就是map函数。 但是，这是针对了所有的情况我们才会这样想。 实践中我们常常会发现，在我们的某个项目中，针对于某一个数组的操作其实是固定的，也就是说，同样的操作，可能会在项目的不同地方调用很多次。 于是，这个时候，我们就可以在map函数的基础上，进行二次封装，以简化我们在项目中的使用。假如这个在我们项目中会调用多次的操作是将数组的每一项都转化为百分比 1 –&gt; 100%。 普通思维下我们可以这样来封装。 1234567function getNewArray(array) &#123; return array.map(function(item) &#123; return item * 100 + '%' &#125;)&#125;getNewArray([1, 2, 3, 0.12]); // ['100%', '200%', '300%', '12%']; 而如果借助柯里化来二次封装这样的逻辑，则会如下实现： 123456789101112function _map(func, array) &#123; return array.map(func);&#125;var _getNewArray = createCurry(_map);var getNewArray = _getNewArray(function(item) &#123; return item * 100 + '%'&#125;)getNewArray([1, 2, 3, 0.12]); // ['100%', '200%', '300%', '12%'];getNewArray([0.01, 1]); // ['1%', '100%'] 如果我们的项目中的固定操作是希望对数组进行一个过滤，找出数组中的所有Number类型的数据。借助柯里化思维我们可以这样做。 123456789101112131415161718192021222324252627282930function _filter(func, array) &#123; return array.filter(func);&#125;var _find = createCurry(_filter);var findNumber = _find(function(item) &#123; if (typeof item == 'number') &#123; return item; &#125;&#125;)findNumber([1, 2, 3, '2', '3', 4]); // [1, 2, 3, 4]// 当我们继续封装另外的过滤操作时就会变得非常简单// 找出数字为20的子项var find20 = _find(function(item, i) &#123; if (typeof item === 20) &#123; return i; &#125;&#125;)find20([1, 2, 3, 30, 20, 100]); // 4// 找出数组中大于100的所有数据var findGreater100 = _find(function(item) &#123; if (item &gt; 100) &#123; return item; &#125;&#125;)findGreater100([1, 2, 101, 300, 2, 122]); // [101, 300, 122] 我采用了与check例子不一样的思维方向来想大家展示我们在使用柯里化时的想法。目的是想告诉大家，柯里化能够帮助我们应对更多更复杂的场景。 当然不得不承认，这些例子都太简单了，简单到如果使用柯里化的思维来处理他们显得有一点多此一举，而且变得难以理解。因此我想读者朋友们也很难从这些例子中感受到柯里化的魅力。不过没关系，如果我们能够通过这些例子掌握到柯里化的思维，那就是最好的结果了。在未来你的实践中，如果你发现用普通的思维封装一些逻辑慢慢变得困难，不妨想一想在这里学到的柯里化思维，应用起来，柯里化足够强大的自由度一定能给你一个惊喜。 当然也并不建议在任何情况下以炫技为目的的去使用柯里化，在柯里化的实现中，我们知道柯里化虽然具有了更多的自由度，但同时柯里化通用式里调用了arguments对象，使用了递归与闭包，因此柯里化的自由度是以牺牲了一定的性能为代价换来的。只有在情况变得复杂时，才是柯里化大显身手的时候。 额外知识补充无限参数的柯里化。 该部分内容可忽略 在前端面试中，你可能会遇到这样一个涉及到柯里化的题目。 1234// 实现一个add方法，使计算结果能够满足如下预期：add(1)(2)(3) = 6;add(1, 2, 3)(4) = 10;add(1)(2)(3)(4)(5) = 15; 这个题目的目的是想让add执行之后返回一个函数能够继续执行，最终运算的结果是所有出现过的参数之和。而这个题目的难点则在于参数的不固定。我们不知道函数会执行几次。因此我们不能使用上面我们封装的createCurry的通用公式来转换一个柯里化函数。只能自己封装，那么怎么办呢？在此之前，补充2个非常重要的知识点。 一个是ES6函数的不定参数。假如我们有一个数组，希望把这个数组中所有的子项展开传递给一个函数作为参数。那么我们应该怎么做？ 12345// 大家可以思考一下，如果将args数组的子项展开作为add的参数传入function add(a, b, c, d) &#123; return a + b + c + d;&#125;var args = [1, 3, 100, 1]; 在ES5中，我们可以借助之前学过的apply来达到我们的目的。 1add.apply(null, args); // 105 而在ES6中，提供了一种新的语法来解决这个问题，那就是不定参。写法如下： 1add(...args); // 105 这两种写法是等效的。OK，先记在这里。在接下的实现中，我们会用到不定参数的特性。 第二个要补充的知识点是函数的隐式转换。当我们直接将函数参与其他的计算时，函数会默认调用toString方法，直接将函数体转换为字符串参与计算。 12function fn() &#123; return 20 &#125;console.log(fn + 10); // 输出结果 function fn() &#123; return 20 &#125;10 但是我们可以重写函数的toString方法，让函数参与计算时，输出我们想要的结果。 1234function fn() &#123; return 20; &#125;fn.toString = function() &#123; return 30 &#125;console.log(fn + 10); // 40 除此之外，当我们重写函数的valueOf方法也能够改变函数的隐式转换结果。 1234function fn() &#123; return 20; &#125;fn.valueOf = function() &#123; return 60 &#125;console.log(fn + 10); // 70 当我们同时重写函数的toString方法与valueOf方法时，最终的结果会取valueOf方法的返回结果。 12345function fn() &#123; return 20; &#125;fn.valueOf = function() &#123; return 50 &#125;fn.toString = function() &#123; return 30 &#125;console.log(fn + 10); // 60 补充了这两个知识点之后，我们可以来尝试完成之前的题目了。add方法的实现仍然会是一个参数的收集过程。当add函数执行到最后时，仍然返回的是一个函数，但是我们可以通过定义toString/valueOf的方式，让这个函数可以直接参与计算，并且转换的结果是我们想要的。而且它本身也仍然可以继续执行接收新的参数。实现方式如下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445function add() &#123; // 第一次执行时，定义一个数组专门用来存储所有的参数 var _args = [].slice.call(arguments); // 在内部声明一个函数，利用闭包的特性保存_args并收集所有的参数值 var adder = function () &#123; var _adder = function() &#123; // [].push.apply(_args, [].slice.call(arguments)); _args.push(...arguments); return _adder; &#125;; // 利用隐式转换的特性，当最后执行时隐式转换，并计算最终的值返回 _adder.toString = function () &#123; return _args.reduce(function (a, b) &#123; return a + b; &#125;); &#125; return _adder; &#125; // return adder.apply(null, _args); return adder(..._args);&#125;var a = add(1)(2)(3)(4); // f 10var b = add(1, 2, 3, 4); // f 10var c = add(1, 2)(3, 4); // f 10var d = add(1, 2, 3)(4); // f 10// 可以利用隐式转换的特性参与计算console.log(a + 10); // 20console.log(b + 20); // 30console.log(c + 30); // 40console.log(d + 40); // 50// 也可以继续传入参数，得到的结果再次利用隐式转换参与计算console.log(a(10) + 100); // 120console.log(b(10) + 100); // 120console.log(c(10) + 100); // 120console.log(d(10) + 100); // 120// 其实上栗中的add方法，就是下面这个函数的柯里化函数，只不过我们并没有使用通用式来转化，而是自己封装function add(...args) &#123; return args.reduce((a, b) =&gt; a + b);&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[函数与函数式编程]]></title>
    <url>%2F2019%2F09%2F01%2F%E5%87%BD%E6%95%B0%E4%B8%8E%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[纵观JavaScript中所有必须需要掌握的重点知识中，函数时我们在初学的时候最容易忽视的一个知识点。在学习的过程中，可能会有很多人、很多文章告诉你面向对象很重要，原型很重要，可是却很少有人告诉你，面向对象中所有的重点难点，几乎都与函数息息相关。 函数声明、函数表达式、匿名函数与自执行函数关于函数在实际开发中的应用，大体可以总结为函数声明、函数表达式、匿名函数、自执行函数。 函数声明 我们知道JavaScript中，有两种声明方式，一个是使用var的变量声明，另一个是使用function的函数声明。 变量对象的创建过程中，函数声明比变量声明具有更优先的执行顺序，即我们常常提到的函数声明提前。因此我们在执行上下文中，无论在任何位置声明了函数，我们都可以在同一个执行上下文直接使用该函数。 12345fn(); // functionfunction fn() &#123; console.log('function');&#125; 函数表达式 与函数声明不同，函数表达式使用var声明，那么我们在确认他是否可以正确使用的时候就必须依照var的规则进行判断，即变量声明。我们知道使用var进行变量声明，其实是进行了两边操作。 123456// 变量声明var a = 20;// 实际执行顺序var a = undefined; // 变量声明，初始值undefined，变量提升，提升顺序次于function声明a = 20; // 变量赋值，该操作不会提升 同样的道理，当我们使用变量声明的方式来声明函数时，就是我们常常说的函数表达式。函数表达式的提升方式与变量声明一致。 1234fn(); // 报错var fn = function() &#123; console.log('function');&#125; 上面例子的执行顺序为： 12345var fn = undefined; // 变量声明提升fn(); // 执行报错fn = function() &#123; // 赋值操作，此时将后边函数的引用赋值给fn console.log('function');&#125; 因此，由于声明方式的不同，导致了函数声明与函数表达式在使用上的一些差异需要我们注意，除此之外，这两种形式的函数在使用上并无不同。 对于上面例子中，函数表达式中的赋值操作，在其他一些地方也会被经常使用，我们清楚其中的关系即可。 12345678910111213141516171819202122// 在构造函数中添加方法function Person(name) &#123; this.name = name; this.age = age; // 在构造函数内部中添加方法 this.getAge = function() &#123; return this.age; &#125; this.&#125;// 给原型添加方法Person.prototype.getName = function() &#123; return this.name;&#125;// 在对象中添加方法var a = &#123; m: 20, getM: function() &#123; return this.m; &#125;&#125; 匿名函数 在上面我们大概讲述了函数表达式中的赋值操作。而匿名函数，顾名思义，就是指没有被显示进行赋值操作的函数。它的使用场景，多作为一个参数传入另一个函数中。 12345678var a = 10;var fn = function(bar, num) &#123; return bar() + num;&#125;fn(function() &#123; return a;&#125;, 20) 在上面的例子中，fn的第一个参数传入了一个匿名函数。虽然该匿名函数没有显示的进行赋值操作，我们没有办法再外部执行上下文中引用它。但是在fn函数内部，我们将该匿名函数赋值给了变量bar，保存在了fn变量对象的arguments对象中。 1234567891011121314151617181920// 变量对象在fn上下文执行过程中的创建阶段VO(fn) = &#123; arguments: &#123; bar: undefined, num: undefined, length: 2 &#125;&#125;// 变量对象在fn上下文执行过程中的执行阶段// 变量对象变为活动对象，并完成赋值操作与执行可执行代码VO -&gt; AOAO(fn) = &#123; arguments: &#123; bar: function() &#123; return a &#125;, num: 20, length: 2 &#125;&#125; 由于匿名函数传入另一个函数之后，最终会在另一个函数中执行，因此我们也常常称这个匿名函数为回调函数。匿名函数的这个应用场景几乎承担了函数的所有难以理解的知识点。 函数自执行与块级作用域 在ES5中，没有块级作用域，因此我们常常使用函数自执行的方式来模仿块级作用域，这样就提供了一个独立的执行上下文，结合闭包，就为模块化提供了基础。而函数自执行，其实就是匿名函数的一种应用。 123(function() &#123; // ...&#125;)(); 一个模块往往可以包括：私有变量、私有方法、公有变量和公有方法。 根据作用域链的单向访问，外面可能很容易在这个独立二点模块中，外部执行环境是无法访问内部的任何变量与方法的，因此我们可以很容易的创建属于这个模块的私有变量与私有方法。 12345678910(function() &#123; // 私有变量 var age = 20; var name = 'Tom'; // 私有方法 function getName() &#123; return `your name is ` + name; &#125;&#125;)(); 但是公有方法与变量应该怎么办？利用闭包，我们可以访问到执行上下文内部的变量和方法，因此，我们只需要根据闭包的定义，创建一个闭包，将你认为需要公开的变量和方法开放出来即可。 123456789101112131415161718(function() &#123; // 私有变量 var age = 20; var name = 'Tom'; // 私有方法 function getName() &#123; return `your name is ` + name; &#125; // 共有方法 function getAge() &#123; return age; &#125; // 将引用保存在外部执行环境的变量中，形成闭包，防止该执行环境被垃圾回收 window.getAge = getAge;&#125;)(); 闭包在模块中有着重要作用，为了让大家更进一步的理解闭包，我们看看jQuery是如何利用模块与闭包的。 123456789101112131415161718192021222324// 使用函数自执行的方式创建模块(function(window, undefined) &#123; // 声明jQuery构造函数 var jQuery = function(name) &#123; // 主动在构造函数中，返回一个jQuery实例 return new jQuery.fn.init(name); &#125; // 添加原型方法 jQuery.prototype = jQuery.fn = &#123; constructor: jQuery, init:function() &#123; ... &#125;, css: function() &#123; ... &#125; &#125; jQuery.fn.init.prototype = jQuery.fn; // 将jQuery改名为$，并将引用保存在window上，形成闭包，对外开发jQuery构造函数，这样我们就可以访问所有挂载在jQuery原型上的方法了 window.jQuery = window.$ = jQuery; &#125;)(window);// 在使用时，我们直接执行了构造函数，因为在jQuery的构造函数中通过一些手段，返回的是jQuery的实例，所以我们就不用再每次用的时候在自己new了$('#div1'); 函数参数传递方式：按值传递基本数据类型复制，是直接值发生了复制，因此改变后，各自相互不影响。但是引用数据类型的复制，是保存在变量对象中的引用发生了复制，因此复制之后的这两个引用实际访问的实际是同一个堆内存中的值。当改变其中一个时，另外一个自然也被改变。如下例。 123456789var a = 20;var b = a;b = 10;console.log(a); // 20var m = &#123; a: 1, b: 2 &#125;var n = m;n.a = 5;console.log(m.a) // 5 当值作为函数的参数传递到函数内部时，也有同样的差异。我们知道，函数的参数在进入函数后，实际时被保存在函数的变量对象中，因此这个时候相当于发送了一次复制。 12345678var a = 20;function fn(a) &#123; a = a + 10; return a;&#125;fn(a);console.log(a); // 20 正是由于这样的不同，导致了许多人在理解函数参数的传递方式时，就有许多困惑。到底是按值传递还是按引用传递？实际上结论仍然是按值传递，只不过当我们期望传递一个引用类型时，真正传递的，只是这个引用类型保存在变量对象中的引用而已。为了说明这个问题，我们看看下面这个例子。 123456789101112var person = &#123; name: 'Nicholas', age: 20&#125;function setName(obj) &#123; // 传入一个引用 obj = &#123;&#125;; // 将传入的引用指向另外的值 obj.name = 'Greg'; // 修改引用的name属性&#125;setName(person);console.log(person.name); // Nicholas 未被改变 在上面的例子中，如果person是按引用传递，那么person就会自动被修改为指向其name属性值为Gerg的新对象。但是我们从结果中看到，person对象并未发生任何改变，因此只是在函数内部引用被修改而已。 函数式编程虽然JavaScript并不是一门纯函数式编程语言，但是它使用了许多函数式编程的特性。因此了解这些特性可以让我们更加了解自己的代码。 当我们需要使用一个函数时，通常情况下就是想要将一些功能、逻辑等封装起来。相信大家对封装这个概念并不陌生。 我们通常通过函数封装来完成一个事情，例如我想要计算任何三个数的和，我们就可以将这三个数作为参数，封装一个简单的函数。 封装一个简单的函数。 123function add(a, b, c) &#123; return a + b + c;&#125; 当我们想要计算三个数的和时，直接调用该方法即可。 1add(1, 2, 3); // 6 当然，当我们想要做的事情比较简单的时候，可能还看不出来封装成为函数之后带来的便利。如果我们想要做的事情稍微复杂一点呢。例如我想要计算一个数组中的所有子项目的和。 12345function mergeArr(arr) &#123; var result = 0; for(var i = 0; i &lt; arr.length; i++) &#123; result += arr[i] &#125; return result;&#125; 如果我们不通过函数封装的方式，那么再每次想要实现这个功能时，就不得不重新使用一次for循环，这样的后果就是我们的代码中充斥着越来越多的重复代码。而封装之后，当我们想要再次做这件事情的时候，只需要一句话就可以了。 1mergeArr([1, 2, 3, 4, 5]); 当然，我相信大家对于函数封装的意义都应该有非常明确的认知，但是我们要面临的问题是，当我们想要去封装一个函数时，如何做才是最佳实践呢？ 函数式编程能给我们答案。 我们在初学时，往往会不由自主的使用命令式编程的风格来完成我们想要干的事情。因为命令式编程更加的简单，直白。例如我们现在有一个数组，array = [1, 3, &#39;h&#39;, 5, &#39;m&#39;, &#39;4&#39;]，现在想要找出这个数组中的所有类型为number的子项。当我们使用命令式编程思维时，可能就会直接这样做。 1234567var array = [1, 3, 'h', 5, 'm', '4'];var res = [];for(var i = 0; i &lt; array.length; i ++) &#123; if (typeof array[i] === 'number') &#123; res.push(array[i]); &#125;&#125; 在这种实现方式中，我们平铺直叙的实现了我们的目的。这样做的问题在于，当我们在另外的时刻，想要找出另外一个数组中所有的子项时，我们不得不把同样的逻辑再写一次。当出现次数变多时，我们的代码也变得更加糟糕且难以维护。 而函数式编程的思维则建议我们将这种会多次出现的功能封装起来以备调用。 123456789101112131415function getNumbers(array) &#123; var res = []; array.forEach(function(item) &#123; if (typeof item === 'number') &#123; res.push(item); &#125; &#125;) return res;&#125;// 以上是我们的封装，以下是功能实现var array = [1, 3, 'h', 5, 'm', '4'];var res = getNumbers(array); 因此当我们将功能封装之后，我们实现同样的功能时，只需要写一行代码。而如果未来需求变动，或者稍作修改，我们只需要对getNumbers方法进行调整就可以了。而且我们在使用时，只需要关心这个方法能做什么，而不用关心他具体是怎么实现的。这也是函数式编程思维与命令式不同的地方之一。 函数式编程思维还具有以下几个特征。 函数时第一等公民 所谓“第一等公民（first class）”，指的时函数与其他数据类型一样，处于平等地位，可以赋值给其他变量，也可以作为参数，传入另一个函数，或者作为别的函数的返回值。这些场景，我们应该见过很多。 123456789var a = function foo() &#123;&#125; // 赋值function fn(function() &#123;&#125;, num) &#123;&#125; // 函数作为参数// 函数作为返回值function var() &#123; return function() &#123; ... ... &#125;&#125; 当然，这都是JavaScript的基本概念。但是我想很多人，甚至包括正在阅读的你自己都可能会无视这些概念。可以用一个简单的例子来验证一下。 我们先自定义这样一个函数。 123function delay() &#123; console.log('5000ms之后执行该方法.');&#125; 现在要做的是，如果要求你结合setTimeout方法，让delay方法延迟5000ms执行，应该怎么做？ 其实很简单，对不对，直接这样就可以了。 123var timer = setTimeout(function() &#123; delay();&#125;, 5000); 那么现在问题来了，如果你对函数是一等公民有一个深刻的认知，我想你会发现上面这种写法其实是有一些问题的。所以思考一下，问题出在哪里？ 函数既然能够作为一个参数传入另外一个函数，那么我们是不是可以直接将delay作为setTimeout的第一个参数，而不用额外的多加一层匿名函数呢？ 因此，其实最正确的解法应该这样写。 1var timer = setTimeout(delay, 5000); 当然，如果你已经提前想到这样做了，那么恭喜你，说明你在JavaScript上比普通人更有天赋。其实第一种糟糕的方式很多人都在用，包括有多年工作经验的人也没有完全避免。而他们甚至还不知道自己问题出在什么地方。 在未来的实践中，你还会遇到更多类似的场景。为了验证读者朋友们的理解，我们不妨来思考一下如何如何优化下面的代码。 12345678910function getUser(path, callback) &#123; return $.get(path, function(info) &#123; return callback(info); &#125;)&#125;getUser('/api/user', function(resp) &#123; // resp为成功请求之后返回的数据 console.log(resp);&#125;) 优化的原理和setTimeout的例子一模一样，我这里卖个关子，不打算告诉大家结论，仅提示一句，getUser优化之后，仅有一句代码。考验大家学习成果的时候到了 ^ ^。 只用”表达式”，不用”语句” “表达式”（expression）是一个单纯的运算过程，总是有返回值；”语句”（statement）是执行某种操作，没有返回值。函数式编程要求，只使用表达式，不使用语句。也就是说，每一步都是单纯的运算，而且都有返回值。 假如我们的项目中，多处需要改变某个元素的背景色。因此我们可以这样封装一下。 12345678var ele = document.querySelector('.test');function setBackgroundColor(color) &#123; ele.style.backgroundColor = color;&#125;// 多处使用setBackgroundColor('red');setBackgroundColor('#ccc'); 我们可以很明显的感受到，setBackgroundColor封装的仅仅只是一条语句。这并不是理想的效果。函数式编程期望一个函数有输入，也有输出。因此良好的习惯应该如下做。 123456789function setBackgroundColor(ele, color) &#123; ele.style.backgroundColor = color; return color;&#125;// 多处使用var ele = document.querySelector('.test');setBackgroundColor(ele, 'red');setBackgroundColor(ele, '#ccc'); 了解这一点，可以让我们自己在封装函数的时候养成良好的习惯。 纯函数 相同的输入总会得到相同的输出，并且不会产生副作用的函数，就是纯函数。 所谓”副作用”（side effect），指的是函数内部与外部互动（最典型的情况，就是修改全局变量的值），产生运算以外的其他结果。 函数式编程强调没有”副作用”，意味着函数要保持独立，所有功能就是返回一个新的值，没有其他行为，尤其是不得修改外部变量的值。 即所谓的只要是同样的参数传入，返回的结果一定是相等的。 例如我们期望封装一个函数，能够得到传入数组的最后一项。那么可以通过下面两种方式来实现。 123456789101112function getLast(arr) &#123; return arr[arr.length];&#125;function getLast_(arr) &#123; return arr.pop();&#125;var source = [1, 2, 3, 4];var last = getLast(source); // 返回结果4 原数组不变var last_ = getLast_(source); // 返回结果4 原数据最后一项被删除 getLast与getLast_虽然同样能够获得数组的最后一项值，但是getLast_改变了原数组。而当原始数组被改变，那么当我们再次调用该方法时，得到的结果就会变得不一样。这样不可预测的封装方式，在我们看来是非常糟糕的。它会把我们的数据搞得非常混乱。在JavaScript原生支持的数据方法中，也有许多不纯的方法，我们在使用时需要非常警惕，我们要清晰的知道原始数据的改变是否会留下隐患。 12345678910111213141516var source = [1, 2, 3, 4, 5];source.slice(1, 3); // 纯函数 返回[2, 3] source不变source.splice(1, 3); // 不纯的 返回[2, 3, 4] source被改变source.pop(); // 不纯的source.push(6); // 不纯的source.shift(); // 不纯的source.unshift(1); // 不纯的source.reverse(); // 不纯的// 我也不能短时间知道现在source被改变成了什么样子，干脆重新约定一下source = [1, 2, 3, 4, 5];source.concat([6, 7]); // 纯函数 返回[1, 2, 3, 4, 5, 6, 7] source不变source.join('-'); // 纯函数 返回1-2-3-4-5 source不变 闭包 闭包是函数式编程语言的重要特性，我也在前面几篇文章中说了很多关于闭包的内容。这里不再赘述。]]></content>
  </entry>
  <entry>
    <title><![CDATA[全方位解读this]]></title>
    <url>%2F2019%2F09%2F01%2F%E5%85%A8%E6%96%B9%E4%BD%8D%E8%A7%A3%E8%AF%BBthis%2F</url>
    <content type="text"><![CDATA[我们在学习JavaScript的过程中，由于对一些概念理解得不是很清楚，但是又想要通过一些方式把它记下来，于是就很容易草率的给这些概念定下一些方便自己记忆的有偏差的结论.有的不准确的结论在网上还广为流传。 比如对于this指向的理解中，有这样一种说法：谁调用它，this就指向谁。在我刚开始学习this的时候，我是非常相信这句话的。因为在一些情况下，这样理解也还算说得通。可是我常常会在开发中遇到一些不一样的情况，一个由于this的错误调用，可以让我懵逼一整天。那个时候我也查资料，在群里问大神，可是我仍然搞不清楚“我特么到底错哪里了”。其实只是因为我心中有一个不太准确的结论。 所以，我认为需要有这样一篇文章，来帮助大家全方位的解读this。让大家对this，有一个正确的，全面的认知。 首先我们需要得到一个非常重要的、一定要牢记在心的结论，this的指向，是在函数被调用的时候确定的。也就是执行上下文被创建时确定的。因此，一个函数中this指向，可以是非常灵活的。比如下面的例子中，同一个函数由于调用方式的不同，this指向了不一样的对象。 1234567891011ar a = 10;var obj = &#123; a: 20&#125;function fn () &#123; console.log(this.a);&#125;fn(); // 10fn.call(obj); // 20 除此之外，在函数执行过程中，this一旦被确定，就不可更改了。 1234567891011var a = 10;var obj = &#123; a: 20&#125;function fn () &#123; this = obj; // 这句话试图修改this，运行后会报错 console.log(this.a);&#125;fn(); 全局对象中的this对于全局对象的this，我之前在总结变量对象的时候提到过，它是一个比较特殊的存在。全局环境中的this，指向它本身。因此，这也相对简单，没有那么多复杂的情况需要考虑。 12345678910111213// 通过this绑定到全局对象this.a2 = 20;// 通过声明绑定到变量对象，但在全局环境中，变量对象就是它自身var a1 = 10;// 仅仅只有赋值操作，标识符会隐式绑定到全局对象a3 = 30;// 输出结果会全部符合预期console.log(a1);console.log(a2);console.log(a3); 函数中的this在总结函数中this指向之前，我们先来体验一下函数中this的不定态。 不定。 123456// demo01var a = 20;function fn() &#123; console.log(this.a);&#125;fn(); 123456789// demo02var a = 20;function fn() &#123; function foo() &#123; console.log(this.a); &#125; foo();&#125;fn(); 123456789101112// demo03var a = 20;var obj = &#123; a: 10, c: this.a + 20, fn: function () &#123; return this.a; &#125;&#125;console.log(obj.c);console.log(obj.fn()); 这几个例子需要花点时间仔细感受一下，如果你暂时没想明白怎么回事，也不用着急，我们一点一点来分析。 在分析前，我们先直接了当的抛出结论。 在一个函数上下文，this由调用者提供，由调用函数的方式来决定。如果调用的函数，被某一个对象所拥有，那么该函数在调用时，内部的this指向该对象。如果函数独立调用，那么该函数内部的this，则指向undefined。但是在非严格模式中，当this指向undefined时，它会被自动指向全局对象。 从结论中我们可以看出，想要准确确定this指向，找到函数的调用者以及区分他是否是独立调用就变得十分关键。 12345678// 为了能够准确判断，我们在函数内部使用严格模式，因为非严格模式会自动指向全局function fn() &#123; 'use strict'; console.log(this);&#125;fn(); // fn是调用者，独立调用window.fn(); // fn是调用者，被window所拥有 在上面的简单例子中，fn()作为独立调用者，按照定义的理解，它内部的this指向就为undefined。而window.fn()则因为fn被window所拥有，内部的this就指向了window对象。 那么掌握了这个规则，现在回过头去看看上面的三个例子，通过添加/去除严格模式，那么你就会发现，原来this已经变得不那么虚无缥缈，已经有迹可循了。 但是我们需要特别注意的是demo03。在demo03中，对象obj中的c属性使用this.a + 20来计算。这里我们需要明确的一点是，单独的{}是不会形成新的作用域的，因此这里的this.a，由于并没有作用域的限制，所以它仍然处于全局作用域之中。所以这里的this其实是指向的window对象。 那么我们修改一下demo03的代码，大家可以思考一下会发生什么变化。 12345678910111213141516'use strict';var a = 20;function foo () &#123; var a = 1; var obj = &#123; a: 10, c: this.a + 20, fn: function () &#123; return this.a; &#125; &#125; return obj.c;&#125;console.log(foo()); // ？console.log(window.foo()); // ? 实际开发中，并不推荐这样使用this； 上面多次提到的严格模式，需要大家认真对待，因为在实际开发中，现在基本已经全部采用严格模式了，而最新的ES6，也是默认支持严格模式。 再来看一些容易理解错误的例子，加深一下对调用者与是否独立运行的理解。 1234567891011var a = 20;var foo = &#123; a: 10, getA: function () &#123; return this.a; &#125;&#125;console.log(foo.getA()); // 10var test = foo.getA;console.log(test()); // 20 foo.getA()中，getA是调用者，他不是独立调用，被对象foo所拥有，因此它的this指向了foo。而test()作为调用者，尽管他与foo.getA的引用相同，但是它是独立调用的，因此this指向undefined，在非严格模式，自动转向全局window。 稍微修改一下代码，大家自行理解。 123456789var a = 20;function getA() &#123; return this.a;&#125;var foo = &#123; a: 10, getA: getA&#125;console.log(foo.getA()); // 10 灵机一动，再来一个。如下例子。 123456789101112131415function foo() &#123; console.log(this.a)&#125;function active(fn) &#123; fn(); // 真实调用者，为独立调用&#125;var a = 20;var obj = &#123; a: 10, getA: foo&#125;active(obj.getA); 使用call，apply显示指定thisJavaScript内部提供了一种机制，让我们可以自行手段设置this的指向。它们就是call与apply。所有的函数都具有两个方法，它们除了参数略有不同，其功能完全一样。它们的第一个参数都为this将要指向的对象。 如下例子，fn并非属于对象obj的方法，但是通过call，我们将fn内部的this绑定obj，因此就可以使用this.a访问obj的a属性，这就是call/apply的用法。 12345678function fn() &#123; console.log(this.a);&#125;var obj = &#123; a: 20&#125;fn.call(obj); 而call与apply后面的参数，都是向将要执行的函数传递参数。其中call以一个个的形式传递，apply以数组的形式传递，这也是它们唯一的不同点。 123456789function fn(num1, num2) &#123; console.log(this.a + num1 + num2);&#125;var obj = &#123; a: 20&#125;fn.call(obj, 100, 10); // 130fn.apply(obj, [20, 10]); // 50 因为call/apply的存在，这让JavaScript变得十分灵活。因此就让call/apply拥有了很多有用处的场景。简单总结几点，也欢迎大家补充。 将类数组对象转换为数组 12345678910111213141516171819function exam(a, b, c, d, e) &#123; // 先看看函数的自带属性 arguments 什么是样子的 console.log(arguments); // 使用call/apply将arguments转换为数组, 返回结果为数组，arguments自身不会改变 var arg = [].slice.call(arguments); console.log(arg);&#125;exam(2, 8, 9, 10, 3);// result:// &#123; '0': 2, '1': 8, '2': 9, '3': 10, '4': 3 &#125;// [ 2, 8, 9, 10, 3 ]//// 也常常使用该方法将DOM中的nodelist转换为数组// [].slice.call( document.getElementsByTagName('li') ); 根据自己的需要灵活修改this指向 12345678910var foo = &#123; name: 'joker', showName: function() &#123; console.log(this.name); &#125;&#125;var bar = &#123; name: 'rose'&#125;foo.showName.call(bar); 实现继承 1234567891011121314151617181920212223// 定义父级的构造函数var Person = function(name, age) &#123; this.name = name; this.age = age; this.gender = ['man', 'woman'];&#125;// 定义子类的构造函数var Student = function(name, age, high) &#123; // use call Person.call(this, name, age); this.high = high;&#125;Student.prototype.message = function() &#123; console.log('name:'+this.name+', age:'+this.age+', high:'+this.high+', gender:'+this.gender[0]+';');&#125;new Student('xiaom', 12, '150cm').message();// result// ----------// name:xiaom, age:12, high:150cm, gender:man; 简单给有面向对象基础的朋友解释一下。在Student的构造函数中，借助call方法，将父级的构造函数执行了一次，相当于将Person中的代码，在Sudent中复制了一份，其中的this指向为从Student中new出来的实例对象。call方法保证了this的指向正确，因此就相当于实现了继承。Student的构造函数等同于下。 1234567var Student = function(name, age, high) &#123; this.name = name; this.age = age; this.gender = ['man', 'woman']; // Person.call(this, name, age); 这一句话，相当于上面三句话，因此实现了继承 this.high = high;&#125; 在向其他执行上下文的传递中，确保this的指向保持不变 如下面的例子中，我们期待的是getA被obj调用时，this指向obj，但是由于匿名函数的存在导致了this指向的丢失，在这个匿名函数中this指向了全局，因此我们需要想一些办法找回正确的this指向。 12345678910var obj = &#123; a: 20, getA: function() &#123; setTimeout(function() &#123; console.log(this.a) &#125;, 1000) &#125;&#125;obj.getA(); 常规的解决办法很简单，就是使用一个变量，将this的引用保存起来。我们常常会用到这方法，但是我们也要借助上面讲到过的知识，来判断this是否在传递中被修改了，如果没有被修改，就没有必要这样使用了。 123456789var obj = &#123; a: 20, getA: function() &#123; var self = this; setTimeout(function() &#123; console.log(self.a) &#125;, 1000) &#125;&#125; 另外就是借助闭包与apply方法，封装一个bind方法。 12345678910111213141516function bind(fn, obj) &#123; return function() &#123; return fn.apply(obj, arguments); &#125;&#125;var obj = &#123; a: 20, getA: function() &#123; setTimeout(bind(function() &#123; console.log(this.a) &#125;, this), 1000) &#125;&#125;obj.getA(); 当然，也可以使用ES5中已经自带的bind方法。它与我上面封装的bind方法是一样的效果。 12345678var obj = &#123; a: 20, getA: function() &#123; setTimeout(function() &#123; console.log(this.a) &#125;.bind(this), 1000) &#125;&#125; 构造函数与原型方法上的this在封装对象的时候，我们几乎都会用到this，但是，只有少数人搞明白了在这个过程中的this指向，就算我们理解了原型，也不一定理解了this。所以这一部分，我认为将会为这篇文章最重要最核心的部分。理解了这里，将会对你学习JS面向对象产生巨大的帮助。 结合下面的例子，我在例子抛出几个问题大家思考一下。 1234567891011121314151617function Person(name, age) &#123; // 这里的this指向了谁? this.name = name; this.age = age; &#125;Person.prototype.getName = function() &#123; // 这里的this又指向了谁？ return this.name;&#125;// 上面的2个this，是同一个吗，他们是否指向了原型对象？var p1 = new Person('Nick', 20);p1.getName(); 我们已经知道，this，是在函数调用过程中确定，因此，搞明白new的过程中到底发生了什么就变得十分重要。 通过new操作符调用构造函数，会经历以下4个阶段。 创建一个新的对象； 将构造函数的this指向这个新对象； 指向构造函数的代码，为这个对象添加属性，方法等； 返回新对象。 因此，当new操作符调用构造函数时，this其实指向的是这个新创建的对象，最后又将新的对象返回出来，被实例对象p1接收。因此，我们可以说，这个时候，构造函数的this，指向了新的实例对象，p1。 而原型方法上的this就好理解多了，根据上边对函数中this的定义，p1.getName()中的getName为调用者，他被p1所拥有，因此getName中的this，也是指向了p1。]]></content>
  </entry>
  <entry>
    <title><![CDATA[图解作用域链与闭包]]></title>
    <url>%2F2019%2F09%2F01%2F%E5%9B%BE%E8%A7%A3%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E4%B8%8E%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[初学JavaScript的时候，我在学习闭包上，走了很多弯路。而这次重新回过头来对基础知识进行梳理，要讲清楚闭包，也是一个非常大的挑战。 作用域与作用域链作用域 在JavaScript中，我们可以将作用域定义为一套规则，这套规则用来管理引擎如何在当前作用域以及嵌套的子作用域中根据标识符进行变量查询。 JavaScript中只有全局作用域与函数作用域（因为eval我们平时开发中几乎不会用到它，这里不讨论）。 作用域与执行上下文是完全不同的两个概念。 JavaScript代码的整个执行过程，分为两个阶段，代码编译阶段与代码执行阶段。编译阶段有编译器完成，将代码翻译成可执行代码，这个阶段作用域规则会确定。执行阶段由引擎完成，主要任务是执行可执行代码，执行上下文在这个阶段创建。 作用域链 回顾之前我们分析的执行上下文的生命周期，如下图。 我们直到函数在调用激活时，会创建对应的执行上下文，在执行上下文生成的过程中，变量对象、作用域链和this的值会分别被去顶。 作用域链，是由当前环境与上层环境的一系列变量对象组成，它保证了当前执行环境对符合访问权限的变量和函数的有序访问。 为了帮助大家理解作用域链。我们结合一个例子，以及相应的图示来说明。 1234567891011121314var a = 20;function test() &#123; var b = a + 10; function innerTest() &#123; var c = 10; return b + c; &#125; return innerTest();&#125;test(); 在上面的列子中，全局、函数test、函数innerTest的执行上下文先后创建，我们设定它们的变量对象分别为VO(global),VO(test)和VO(innerTest)。而innerTest的作用域链则包含了这三个变量对象，所以innerTest的执行上下文可如下表示。 1234innerTestEC = &#123; VO: &#123;...&#125;, // 变量对象 scopeChain: [VO(innerTest), VO(test), VO(global)], // 作用域链&#125; 我们可以直接用一个数组来表示作用域链，数组的第一项scopeChain[0]为作用域链的最前端，而数组的最后一项，为作用域链的最末端，所有的最末端都为全局变量对象。 哼多人会误解为当前作用域与上层作用域为包含关系，但其实并不是。而是以最前端为起点，最末端为终点的单方向通道。 注意：因为变量对象在执行上下文进入执行阶段时，变成了活动对象，所以用AO表示。 闭包对于那些有一点 JavaScript 使用经验但从未真正理解闭包概念的人来说，理解闭包可以看作是某种意义上的重生，突破闭包的瓶颈可以使你功力大增。 闭包是一种特殊的对象。 它由两部分组成，执行上下文（代号A），以及在该上下文中创建的函数（代号B）。 当B执行时，如果访问了A中变量对象的值，那么闭包就产生了。 在大多数理解中，包括许多书中，文章里都以函数B的名字代指这里产生的闭包。而在chrome中，则以执行上下文A的函数名代指闭包。 因此我们只需要知道，一个闭包对象，由A、B共同组成，在以后的篇幅中，我将以chrome的标准来称呼。 1234567891011121314// demo01function foo() &#123; var a = 20; var b = 30; function bar() &#123; return a + b; &#125; return bar;&#125;var bar = foo();bar(); 上面的例子，首先有执行上下文foo，在foo中定义了函数bar，而通过对外返回bar的方式让bar得以执行。当bar执行时，访问了foo内部的变量a，b。因此这个时候闭包产生。 我们知道，函数的执行上下文，在执行完毕之后也就是生命周期结束，该函数的执行上下文就会失去引用。其占用的内存空间很快就会被垃圾回收器释放。可是闭包的存在，会阻止这一过程。 先来一个简单的例子。 123456789101112131415var fn = null;function foo() &#123; var a = 2; function innnerFoo() &#123; console.log(a); &#125; fn = innnerFoo; // 将 innnerFoo的引用，赋值给全局变量中的fn&#125;function bar() &#123; fn(); // 此处的保留的innerFoo的引用&#125;foo();bar(); // 2 在上面的例子中，foo()执行完毕之后，按照常理、其执行环境生命周期结束，所占内存被垃圾收集器释放，但是通过fn = innerFoo，函数innerFoo的引用被保留了下来，复制给了全局变量fn。这个行为，导致了foo的变量对象，也被保留了下来。于是，函数fn在函数bar内部执行时，依然可以访问这个被保留下来的变量对象。所以此刻仍然能够访问到变量a的值。 这样，我们就可以称为foo为闭包。 下面展示闭包foo的作用域链。 我们可以在chrome浏览器的开发者工具中查看这段代码运行时产生的函数调用栈与作用域链的生成情况。 在上面的图上，红色箭头所指的正是闭包。其中Call Stack为当前的函数调用栈，Scope为当前正在被执行的函数的作用域链，Local为当前的局部变量。 所以通过闭包，我们可以在其他的执行上下文中访问函数的内部变量。比如上面例子中。我们在函数bar的执行环境中访问到了函数foo的变量a。个人认为，从应用层面，这是闭包的重要特性。利用这个特性，我们可以实现很多有意思的东西。 不过读者朋友们需要注意的是，虽然例子中的闭包被保存在了全局变量中，但是闭包的作用域链并不会发生任何改变。在闭包中，能访问到的变量，仍然是作用域链上能够查询到的变量。 对上面的例子稍作修改，如果我们在函数bar中声明一个变量c，并在闭包fn中试图访问该变量，运行结果会抛出错误。 1234567891011121314151617var fn = null;function foo() &#123; var a = 2; function innnerFoo() &#123; console.log(c); // 在这里，试图访问函数bar中的c变量，会抛出错误 console.log(a); &#125; fn = innnerFoo; // 将 innnerFoo的引用，赋值给全局变量中的fn&#125;function bar() &#123; var c = 100; fn(); // 此处的保留的innerFoo的引用&#125;foo();bar(); 闭包的应用场景 除了面试，在实践中，闭包有两个非常重要的应用场景。分别是模块化与柯里化。 柯里化 在函数式编程中，利用闭包能够实现很多炫酷的功能，柯里化便是其中很重要的一种。 模块 在我看来，模块是闭包最强大的一个应用场景。如果你是初学者，对于模块的了解可以暂时不用放在心上，因为理解模块需要更多的基础知识。但是如果你已经有了很多JavaScript的使用经验，在彻底了解了闭包之后，不妨借助本文介绍的作用域链与闭包的思路，重新理一理关于模块的知识。这对于我们理解各种各样的设计模式具有莫大的帮助。 123456789101112131415(function () &#123; var a = 10; var b = 20; function add(num1, num2) &#123; var num1 = !!num1 ? num1 : a; var num2 = !!num2 ? num2 : b; return num1 + num2; &#125; window.add = add;&#125;)();add(10, 20); 在上面的例子中，我使用函数自执行的方式，创建了一个模块。add是模块对外暴露的一个公共方法。而变量a，b被作为私有变量。在面向对象的开发中，我们常常需要考虑是将变量作为私有变量，还是放在构造函数中的this中，因此理解闭包，以及原型链是一个非常重要的事情。模块十分重要，因此我会在以后的文章专门介绍，这里就暂时不多说啦。 为了验证自己有没有搞懂作用域链与闭包，这里留下一个经典的思考题，常常也会在面试中被问到。 利用闭包，修改下面的代码，让循环输出的结果依次为1， 2， 3， 4， 5 12345for (var i=1; i&lt;=5; i++) &#123; setTimeout( function timer() &#123; console.log(i); &#125;, i*1000 );&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[变量对象图解]]></title>
    <url>%2F2019%2F09%2F01%2F%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1%E5%9B%BE%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[在JavaScript中，我们肯定不可避免需要声明变量和函数，可是JS解析器是如何找到这些变量的呢？我们还得对执行上下文有个更进一步的了解。 一个执行上下文的什么周期分为两个阶段： 创建阶段：在这个阶段中，执行上下文会分别创建变量对象，建立作用域链，以及确定this的指向。 代码执行阶段：创建完成之后，就会开始执行代码。这个时候，会完成变量赋值，函数引用，以及执行其他代码。 从这里我们就可以看出详细了解执行上下文几位重要，，因为其中涉及到了变量对象，作用域链，this等很多人没弄明白，但是却极为重要的概念。它关系到我们能不能真正理解JavaScript。 变量对象（Variable Object）变量对象的创建，依次经历了一下几个过程。 建立arguments对象，检查当前上下文的参数，建立该对象下的属性与属性值。 建立当前上下文的函数声明，也就是使用function关键字声明的函数。在变量对象中以函数名建立一个属性，属性值为指向该函数所在内存地址的引用。如果函数名的属性已经存在，那么该属性将会被新的引用所覆盖。 检查当前上下文中的变量声明，每找到一个变量声明，就在变量对象中以变量名建立一个属性，属性值为undefined。如果该变量名的属性已经存在，为了防止同名的函数被修改为undefined，则会直接跳过，原属性不会被修改。 许多读者在阅读到这的时候会因为下面的这样场景对于“跳过”一词产生疑问。既然变量声明的foo遇到函数声明的foo会跳过，可是为什么最后foo的输出结果仍然是被覆盖了？ 1234function foo() &#123; console.log('function foo') &#125;var foo = 20;console.log(foo); // 20 其实只是大家在阅读的时候不够仔细，因为上面的三条规则仅仅适用于变量对象的创建过程。也就是执行上下文的创建过程。而foo = 20是在执行上下文的执行过程中运行的，输出结果自然会是20。对比下例。 1234567891011121314console.log(foo); // function foofunction foo() &#123; console.log('function foo') &#125;var foo = 20;// 上栗的执行顺序为// 首先将所有函数声明放入变量对象中function foo() &#123; console.log('function foo') &#125;// 其次将所有变量声明放入变量对象中，但是因为foo已经存在同名函数，因此此时会跳过undefined的赋值// var foo = undefined;// 然后开始执行阶段代码的执行console.log(foo); // function foofoo = 20; 根据这个规则，理解变量提升就变得十分简单了。在很多文章中虽然提到了变量提升，但是具体是怎么回事还真的很多人都说不出来，以后在面试中用变量对象的创建过程跟面试官解释变量提升，保证瞬间提升逼格。 在上面的规则中，function声明会比var声明优先级更高一点。 123456789101112// demo01function test() &#123; console.log(a); console.log(foo()); var a = 1; function foo() &#123; return 2; &#125;&#125;test(); 在上例中，我们直接从test()的执行上下文开始理解。全局作用域中运行test()时，test()的执行上下文开始创建。为了便于理解，我们用如下形式来表示。 123456789101112131415// 创建过程testEC = &#123; // 变量对象 VO: &#123;&#125;, scopeChain: &#123;&#125;&#125;// 因为本文暂时不详细解释作用域链，所以把变量对象专门提出来说明// VO 为 Variable Object的缩写，即变量对象VO = &#123; arguments: &#123;...&#125;, //注：在浏览器的展示中，函数的参数可能并不是放在arguments对象中，这里为了方便理解，我做了这样的处理 foo: &lt;foo reference&gt; // 表示foo的地址引用 a: undefined&#125; 未进入执行阶段之前，变量对象中的属性都不能访问！但是进入执行阶段之后，变量对象转变为了活动对象，里面的属性都能被访问了，然后开始进行执行阶段的操作。 如果在面试的时候被问到变量对象和活动对象有什么区别，就可以自如应答了。它们其实就是同一个对象，只是处于执行上下文的不同生命周期。不过只有处于函数调用栈栈顶的执行上下文的变量对象，才会变成活动对象。 12345678// 执行阶段VO -&gt; AO // Active ObjectAO = &#123; arguments: &#123;...&#125;, foo: &lt;foo reference&gt;, a: 1, this: Window&#125; 因此，上面的例子demo1，执行顺序就变成了这样 1234567891011function test() &#123; function foo() &#123; return 2; &#125; var a; console.log(a); console.log(foo()); a = 1;&#125;test(); 再来一个例子，巩固一下我们的理解。 1234567891011121314151617181920212223242526272829303132// demo2function test() &#123; console.log(foo); console.log(bar); var foo = 'Hello'; console.log(foo); var bar = function () &#123; return 'world'; &#125; function foo() &#123; return 'hello'; &#125;&#125;test();// 创建阶段VO = &#123; arguments: &#123;...&#125;, foo: &lt;foo reference&gt;, bar: undefined&#125;// 这里有一个需要注意的地方，因为var声明的变量当遇到同名的属性时，会跳过而不会覆盖// 执行阶段VO -&gt; AOVO = &#123; arguments: &#123;...&#125;, foo: 'Hello', bar: &lt;bar reference&gt;, this: Window&#125; 需要结合上面的知识，仔细对比这个例子中变量对象从创建阶段到执行阶段的变化，如果你已经理解了，说明变量对象相关的东西都已经难不倒你了。 全局上下文的变量对象以浏览器为例，全局对象为window。 全局上下文有个特殊的地方，它的变量对象，就是window对象。而这个特殊，在this指向上也同样适用，this也是指向window。 1234567// 以浏览器中为例，全局对象为window// 全局上下文windowEC = &#123; VO: Window, scopeChain: &#123;&#125;, this: Window&#125; 除此之外，全局上下文的生命周期，与程序额生命周期一致，只要程序运行不结束。比如关闭浏览器窗口，全局上下文就会一直存在，其它所有的上下文环境，都能直接访问全局上下文的属性。]]></content>
  </entry>
  <entry>
    <title><![CDATA[执行上下文图解]]></title>
    <url>%2F2019%2F09%2F01%2F%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%9B%BE%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[在JavaScript学习初期或者面试的时候常常会遇到考核变量提升的思考题。先来一个简单的。 12console.log(a); // 这里会打印出什么？var a = 20; 暂时先不管这个例子，我们先引入一个JavaScript中最基础，但同时也是最重要的一个概念：执行上下文（Execution Context）。 每当控制器转到可执行代码的时候，会进入一个执行上下文。执行上下文可以被理解为当前代码的环境，他会形成一个作用域。JavaScript中的运行环境大概包括三种情况。 全局环境：JavaScript代码运行起来会首先进入该环境； 函数环境：当函数被调用执行时，会进入当前函数中执行代码； eval(不建议使用)； 因此一个JavaScript程序，在它的执行过程中会产生多个执行上下文，JavaScript引擎会以栈的方式来处理它们，这个栈我们称其为函数调用栈（call stack）。栈底永远都是全局上下文，而栈顶就是当前正在执行的上下文。 当代码在执行过程中，遇到以上三个情况，都会生成一个执行上下文，放入栈中，而处于栈顶的上下文执行完毕后，会自动出栈。为了更加清晰的理解这个过程，根据下面的例子，结合图示给大家展示。 执行上下文可以被理解为函数执行的环境，每一个函数执行时，都会给对应的函数创建这样一个执行环境。 123456789101112131415var color = 'blue';function changeColor() &#123; var anotherColor = 'red'; function swapColors() &#123; var tempColor = anotherColor; anotherColor = color; color = tempColor; &#125; swapColors();&#125;changeColor(); 我们可以用ECStack来表示处理执行上下文组的栈。第一步，首先是全局上下文入栈。 全局上下文入栈之后，其中的可执行代码开始执行，直到遇到changeColor()，这一句激活函数changeColor()创建它自己的执行上下文，因此第二部就是changeColor()的执行上下文入栈。 changeColor()的上下文入栈之后，控制器开始执行其中的可执行代码，遇到swapColors()之后又激活了一个执行上下文。因此第三步是swapColors()的执行上下文入栈。 在swapColors()的可执行代码中，再没有遇到其他能生成执行上下文的情况，因此这段代码顺利执行完毕，swapColors()的上下文从栈中弹出。 swapColors的执行上下文弹出之后，继续执行changeColor的可执行代码，也没有再遇到其他执行上下文，顺利执行完毕之后弹出。这样，ECStack中就只身下全局上下文了。 全局上下文在浏览器窗口关闭后出栈。 注意：函数中，遇到return能直接终止可执行代码的执行，因此会直接将当前上下文弹出栈。 详细了解了这个过程，我们就可以对执行上下文总结一些结论了。 单线程 同步执行，只有栈顶的上下文处于执行中，其它上下文需要等待； 全局上下文只有唯一的一个，它在浏览器关闭时出栈。 函数的执行上下文没有限制； 每次某个函数被调用，就会有个新的执行上下文为其创建，即使是调用的自身函数，也是如此； 为了巩固一下执行上下文的理解，我们再来绘制一个例子的演变过程，这是一个简单的闭包问题。 123456789function f1()&#123; var n=999; function f2()&#123; alert(n); &#125; return f2;&#125;var result=f1();result(); // 999 因为f1中的函数f2在f1的可执行代码中，并没有被调用执行，因此执行f1时，f2不会创建新的上下文，而直到result执行时，才创建了一个新的。具体演变过程如下。]]></content>
  </entry>
  <entry>
    <title><![CDATA[内存空间详细图解]]></title>
    <url>%2F2019%2F08%2F31%2F%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E8%AF%A6%E7%BB%86%E5%9B%BE%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[因为JavaScript具有自动垃圾回收机制，所以对前端开发来说，内存空间并不是一个经常被提及的概念。但想要对JS理解更加深刻，就必须对内存空间有一个清晰的认知。 在学习内存空间之前，我们需要对这三种数据结构有个直观的认知，堆（heap）、栈（stack）和队列（queue）。 栈（Stack）与C/C++不同，JavaScript中没有严格意义上区分栈内存与堆内存。因此我们可以简单粗暴的理解为JavaScript的所有数据都保持在堆内存中。但是在某些场景，我们依然需要基于堆栈数据结构的思维来实现一些功能，比如JavaScript的执行上下文。执行上下文的执行顺序借用了栈的存取方式，因此了解栈数据结构的原理与特点是十分重要。 我们可以通过类比乒乓球盒子来分析栈的存取方式，如下图： 这种乒乓球的存放方式与栈中存取数据的方式如出一辙。处于盒子中最顶层的乒乓球5，它一定是最后被放进去的，但是最先被使用的。而我们想要使用底层的乒乓球1，就必须将上面的4个乒乓球取出来，让乒乓球1处于盒子顶层。这就是栈空间先进后出，后进先出的特点。 堆（heap）堆是一种树状结构，它的存取数据的方式与书架取书是十分相似的。 书虽然也整齐的存放在书架上，但是我们只要知道书的名字，我们就可以很方便的取出我们想要的书，而不用像从乒乓球盒子里取乒乓一样，非得将上面的所有乒乓球拿出来才能取到中间的某一个乒乓球。好比在JSON格式的数据中，我们存储的key-value是可以无序的，因为顺序的不同并不影响我们的使用，我们只需要关心书的名字。 队列（queue）在JavaScript中理解队列的目的主要是为了清晰的明白事件循环（Event Loop）的机制。 队列是一种先进先出（FIFO）的数据结构。正如排队过安检一样，排在队伍前面的人一定是最先过安检的。用下面的图示可以清晰显示队列的存取过程。 变量对象与基础数据类型JavaScript的执行上下文生成之后，会创建一个叫做变量对象的特殊对象，JavaScript的基础数据类型往往都会保存在变量对象中。 严格意义上说，变量对象也是存放于堆内存中，但是由于变量对象的特殊职能，我们在理解时仍需要将其与对内存区分开来。 基础数据类型都是一些简单的数据段，JavaScript中有6中基础数据类型，分别是ndefined、Null、Boolean、Number、String、Symbol。基础数据类型都是按值访问，因为我们可以直接操作保存在变量中的实际值。 引用数据类型与堆内存与其他语言不同，JavaScript的引用类型比如数组Array，它们的值的大小时不固定的。引用数据类型的值时保存至堆内存中的对象。JavaScript不允许直接访问堆内存中的位置。因此我们不能直接操作对象的堆内存空间。在操作对象时，实际上时在操作对象的引用而不是实际的对象。因此，引用类型的值都是按引用访问的。这里的引用，我们可以理解为保存在变量对象中的一个地址，该地址与堆内存的实际值相关联。 为了更好的搞懂变量对象与堆内存，我们可以结合以下例子与图解进行理解。 123456var a1 = 0; // 变量对象var a2 = 'this is string'; // 变量对象var a3 = null; // 变量对象var b = &#123; m: 20 &#125;; // 变量b存在于变量对象中，&#123;m: 20&#125; 作为对象存在于堆内存中var c = [1, 2, 3]; // 变量c存在于变量对象中，[1, 2, 3] 作为对象存在于堆内存中 因此当我们要访问堆内存中的引用数据类型时，实际上我们首先时从变量对象中获取该对象的地址引用，再从堆内存中取得我们需要的数据。 理解了JavaScript的内存空间，我们就可以借助内存空间的特性来验证一下引用类型的一些特点。 在前端面试中我们常常会遇到这样一个类似的题目 123456// demo01.jsvar a = 20;var b = a;b = 30;// 这时a的值是多少？ 123456// demo02.jsvar m = &#123; a: 10, b: 20 &#125;var n = m;n.a = 15;// 这时m.a的值是多少 在变量对象中的数据发生复制行为时，系统会自动为新的变量分配一个新值。var b = a执行之后，a与b虽然值都等于20，但是他们其实已经是相互独立互不影响的值了。具体如图。所以我们修改了b的值以后，a的值并不会发生变化。 在demo02中，我们通过var n = m执行一次复制引用类型的操作。引用类型的复制同样也会为新的变量自动分配一个新的值保存在变量对象中，但不同的是，这个新的值，仅仅只是引用类型的一个地址指针。当地址指针相同时，尽管他们相互独立，但是在变量对象中访问到的具体对象实际上是同一个。如图所示。 因此当我改变n时，m也发生了变化。这就是引用类型的特性. 通过内存的角度来理解，是不是感觉要轻松很多？除此之外，我们还可以以此为基础，一步一步的理解JavaScript的执行上下文，作用域链，闭包，原型链等重要概念。 内存空间管理因为JavaScript具有自动垃圾收集机制，所以我们在开发时不需要关心内存的使用问题，内存的分配与回收都完全实现了自动管理。 JavaScript的内存生命周期 1231. 分配你所需要的内存2. 使用分配到的内存（读、写）3. 不需要时将其释放、归还 为了便于理解，我们使用一个简单的例子来解释这个周期。 123var a = 20; // 在内存中给数值变量分配空间alert(a + 100); // 使用内存a = null; // 使用完毕之后，释放内存空间 第一步和第二步我们都很好理解，JavaScript在定义变量时就完成了内存分配。第三步释放内存空间则是我们需要重点理解的一个点。 JavaScript有自动垃圾收集机制，那么这个自动垃圾收集机制的原理是什么呢？其实很简单，就是找出那些不再继续使用的值，然后释放其占用的内存。垃圾收集器会每隔固定的时间段就执行一次释放操作。 在JavaScript中，最常用的是通过标记清除的算法来找到哪些对象是不再继续使用的，因此a = null其实仅仅只是做了一个释放引用的操作，让 a 原本对应的值失去引用，脱离执行环境，这个值会在下一次垃圾收集器执行操作时被找到并释放。而在适当的时候解除引用，是为页面获得更好性能的一个重要方式。 在局部作用域中，当函数执行完毕，局部变量也就没有存在的必要了，因此垃圾收集器很快做出判断回收。但全局变量什么时候需要自动释放内存空间就很难判断，因此在我们的开发中，需要尽量避免使用全局变量。]]></content>
  </entry>
  <entry>
    <title><![CDATA[手写实现call()、apply()、bind()]]></title>
    <url>%2F2019%2F08%2F31%2F%E6%89%8B%E5%86%99%E5%AE%9E%E7%8E%B0call()%E3%80%81apply()%E3%80%81bind()%2F</url>
    <content type="text"><![CDATA[apply()和call()这两个方法的用途都是在特定的作用域中调用函数，实际上等于设置函数体内this对象的值。bind()方法会创建一个函数的实例，其this值会被绑定到传来的参数。总的来说是用来改变函数运行时this的指向。 call() 用法 call方法将需要参数按顺序传递。 12345678function sum(num1, num2)&#123; return num1 + num2;&#125;function callSum(num1, num2)&#123; return sum.call(this, num1, num2);&#125;alert(callSum(10,10)); //20 实现原理 1234567891011Function.prototype.call2 = function (context) &#123; context = context || window context.fn = this var args = []; for(var i = 1, len = arguments.length; i &lt; len; i++) &#123; args.push('arguments[' + i + ']'); &#125; var result = eval('context.fn(' + args +')'); delete context.fn return result; &#125; apply() 用法 apply()方法接收两个参数：一个是在其中运行函数的作用域，另一个是参数数组，可以是Array的实例，也可以是arguments对象。 1234567891011121314function sum(num1, num2)&#123; return num1 + num2;&#125;function callSum1(num1, num2)&#123; return sum.apply(this, arguments);&#125;function callSum2(num1, num2)&#123; return sum.apply(this, [num1, num2]);&#125;alert(callSum1(10,10)); //20alert(callSum2(10,10)); //20 其中this是你想指定的上下文，它可以是任何一个JavaScript对象（JavaScript中一切皆对象）。apply()和call()的用法，接收参数的方式不一样，使用call()和apply()来扩充作用域的最大好处，就是对象不需要与方法有任何耦合关系，如果你传的 context 就 null 或者 undefined，那么 window 对象就是默认的 context（严格模式下默认 context 是 undefined)。 实现原理 12345678910111213141516171819Function.prototype.apply = function (context, arr) &#123; context = Object(context) || window; context.fn = this; var result; if (!arr) &#123; result = context.fn(); &#125; else &#123; var args = []; for (var i = 0, len = arr.length; i &lt; len; i++) &#123; args.push('arr[' + i + ']'); &#125; result = eval('context.fn(' + args + ')') &#125; delete context.fn return result; &#125; bind() 用法 bind()用法：第一个参数是this的指向，从第二个参数开始接收的参数列表 12345678910111213window.color = "red";var o = &#123; color: "blue" &#125;;function sayColor()&#123; alert(this.color);&#125;var objectSayColor = sayColor.bind(o);objectSayColor(); //blue 实现原理 1234567891011121314151617181920212223Function.prototype.bind = function (oThis) &#123; if (typeof this !== "function") &#123; throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable"); &#125; var aArgs = Array.prototype.slice.call(arguments, 1), fToBind = this, fNOP = function () &#123;&#125;, fBound = function () &#123; // 当作为构造函数时，this 指向实例，此时结果为 true，将绑定函数的 this 指向该实例，可以让实例获得来自绑定函数的值 // 以上面的是 demo 为例，如果改成 `this instanceof fBound ? null : context`，实例只是一个空对象，将 null 改成 this ，实例会具有 habit 属性 // 当作为普通函数时，this 指向 window，此时结果为 false，将绑定函数的 this 指向 context return fToBind.apply( this instanceof fNOP &amp;&amp; oThis ? this : oThis || window, aArgs.concat(Array.prototype.slice.call(arguments)) ); &#125;; fNOP.prototype = this.prototype; fBound.prototype = new fNOP(); return fBound;&#125;; 总结call、apply和bind函数存在的区别： bind()不会立即执行，而是返回一个改变了上下文this的函数，便于稍后调用； apply，call则是立即调用； call比apply的性能要好，平常可以多用call。call传入参数的格式正式内部所需要的格式； 需要注意的一点的是： 在ES6的箭头函数下，call和apply将失效，对于箭头函数来说，函数内部的this对象，就是定义时所在的对象； 箭头函数不可以当作构造函数，也就是说不可以使用new关键字，否则会抛出一个错误。 箭头函数不可以使用arguments对象，该对象在函数中不存在；]]></content>
  </entry>
  <entry>
    <title><![CDATA[JavaScript之工厂模式]]></title>
    <url>%2F2019%2F08%2F31%2FJavaScript%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[工厂模式类似现实生活种的工厂可以产生大量相似的商品，去做同样的事情，实现相同的效果； 简单的工厂模型可以理解为解决多个相似的问题，这也是它的优点。相关代码如下： 1234567891011121314151617181920212223242526function CreatePerson(name,age,sex) &#123; var obj = new Object(); obj.name = name; obj.age = age; obj.sex = sex; obj.sayName = function()&#123; return this.name; &#125; return obj;&#125;var p1 = CreatePerson("longen",'28','男');var p2 = CreatePerson("tugenhua",'27','女');console.log(p1.name); // longenconsole.log(p1.age); // 28console.log(p1.sex); // 男console.log(p1.sayName()); // longenconsole.log(p2.name); // tugenhuaconsole.log(p2.age); // 27console.log(p2.sex); // 女console.log(p2.sayName()); // tugenhua// 返回都是object 无法识别对象的类型 不知道他们是哪个对象的实列console.log(typeof p1); // objectconsole.log(typeof p2); // objectconsole.log(p1 instanceof Object); // true 函数CreatePerson接收三个参数name、age和sex，在无数次的调用下，这个函数都会返回包含这三个属性和一个sayName方法的对象。 工厂模式是为了解决多个类似对象声明的问题，也是为了解决实例化对象产生重复的问题。 优点：能解决多个相似的问题。 缺点：无法识别对象的类型。 复杂的工厂模式：将其成员对象的实例化推迟到子类中，子类可以重写父类接口方法以便创建的时候指定自己的对象类型。 父类只对创建过程中的一般性问题进行处理，这些处理会被子类继承，子类之间是相互独立的，具体的业务逻辑会放在子类中进行编写。 父类就变成了一个抽象类，但是符类可以执行子类中相同类似的方法，具体的业务逻辑需要放在子类中去实现。比如我现在开了几个自行车店，那么每个店都有几种型号的自行车出售。我们现在来使用工厂模式来编写这些代码。 父类的构造函数： 12345678910111213141516171819202122// 定义自行车的构造函数var BicycleShop = function()&#123;&#125;;BicycleShop.prototype = &#123; constructor: BicycleShop, /* * 买自行车这个方法 * @param &#123;model&#125; 自行车型号 */ sellBicycle: function(model)&#123; var bicycle = this.createBicycle(mode); // 执行A业务逻辑 bicycle.A(); // 执行B业务逻辑 bicycle.B(); return bicycle; &#125;, createBicycle: function(model)&#123; throw new Error(&quot;父类是抽象类不能直接调用，需要子类重写该方法&quot;); &#125;&#125;; 上面是定义一个自行车抽象类来编写工厂模式的实列，定义了createBicycle这个方法，但是如果直接实例化父类，调用父类中的这个createBicycle 方法,会抛出一个error，因为父类是一个抽象类，他不能被实列化，只能通过子类来实现这个方法，实现自己的业务逻辑，下面我们来定义子类，我们学会如何使用工厂模式重新编写这个方法，首先我们需要继承父类中的成员，然后编写子类 ;如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// 定义自行车的构造函数var BicycleShop = function(name)&#123; this.name = name; this.method = function()&#123; return this.name; &#125;&#125;;BicycleShop.prototype = &#123; constructor: BicycleShop, /* * 买自行车这个方法 * @param &#123;model&#125; 自行车型号 */ sellBicycle: function(model)&#123; var bicycle = this.createBicycle(model); // 执行A业务逻辑 bicycle.A(); // 执行B业务逻辑 bicycle.B(); return bicycle; &#125;, createBicycle: function(model)&#123; throw new Error("父类是抽象类不能直接调用，需要子类重写该方法"); &#125; &#125;; // 实现原型继承 function extend(Sub,Sup) &#123; //Sub表示子类，Sup表示超类 // 首先定义一个空函数 var F = function()&#123;&#125;; // 设置空函数的原型为超类的原型 F.prototype = Sup.prototype; // 实例化空函数，并把超类原型引用传递给子类 Sub.prototype = new F(); // 重置子类原型的构造器为子类自身 Sub.prototype.constructor = Sub; // 在子类中保存超类的原型,避免子类与超类耦合 Sub.sup = Sup.prototype; if(Sup.prototype.constructor === Object.prototype.constructor) &#123; // 检测超类原型的构造器是否为原型自身 Sup.prototype.constructor = Sup; &#125; &#125; var BicycleChild = function(name)&#123; this.name = name;// 继承构造函数父类中的属性和方法 BicycleShop.call(this,name); &#125;; // 子类继承父类原型方法 extend(BicycleChild,BicycleShop);// BicycleChild 子类重写父类的方法BicycleChild.prototype.createBicycle = function()&#123; var A = function()&#123; console.log("执行A业务操作"); &#125;; var B = function()&#123; console.log("执行B业务操作"); &#125;; return &#123; A: A, B: B &#125;&#125;var childClass = new BicycleChild("龙恩");console.log(childClass); 实例化子类，然后打印出该实例： 上面只是”龙恩”自行车这么一个型号的，如果需要生成其他型号的自行车的话，可以编写其他子类，工厂模式最重要的优点是：可以实现一些相同的方法，这些相同的方法我们可以放在父类中编写代码，那么需要实现具体的业务逻辑，那么可以放在子类中重写该父类的方法，去实现自己的业务逻辑；使用专业术语来讲的话有 2点：第一：弱化对象间的耦合，防止代码的重复。在一个方法中进行类的实例化，可以消除重复性的代码。第二：重复性的代码可以放在父类去编写，子类继承于父类的所有成员属性和方法，子类只专注于实现自己的业务逻辑。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Base64的原理与实现]]></title>
    <url>%2F2019%2F08%2F30%2FBase64%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[我们知道在计算机中一个字节有256种组合，对应的就是ASCII码。而ASCII码的128~255之间的值属于不可见字符。有些网络传送渠道并不支持所有的字节，例如传统的邮件只支持可见字符的传送，而ASCII码的控制字符就不能通过邮件传送。图片二进制流的每一个字节也都不可能都是可见字符，因此它们也不能传送。对此最好的办法就是在不改变传统协议的情况下，做一种拓展方案来支持二进制文件的传送，将不可见的字符用可见字符来表示。Base64编码应运而生。 Base64编码原理Base64编码是基于64个可见字符“A-Z、a-z、0-9、+、/”的编码方式，因为Base64的码表只有64个字符，想要完全表达这些字符，只需要6bit即可（2的6次方为64）。 Base64编码本质上是一种将二进制数据转成文本数据的方案。对于非二进制数据，是先将其转换成二进制形式，，然后每连续6bit计算其十进制值，根据该值在码表上找到对应的字符，最后得到一个文本字符串。基本规则如下： 标准Base64只有64个可见字符（A-Z、a-z、0-9、+、/）以及用作后缀等号； Base64是将3个字节变成4个可见字符； 严格来说Base64不能算是一种加密，只能说是编码转换。 Base64应用 实现简单的数据加密，使用户一眼望去看不出真实数据内容，Base64算法的复杂程度较低，而效率就较高些。 Base64编码的主要的作用不在于安全性，而是让内容能在各个网关间无错的传输，这才是Base64编码的核心作用。]]></content>
  </entry>
  <entry>
    <title><![CDATA[HTTP常见的状态码]]></title>
    <url>%2F2019%2F08%2F30%2FHTTP%E5%B8%B8%E8%A7%81%E7%9A%84%E7%8A%B6%E6%80%81%E7%A0%81%2F</url>
    <content type="text"><![CDATA[状态码的职责是当客户端向服务器发送请求时，描述返回的请求结果。借助状态码，用户可以知道服务端时正常处理了请求还是出现了错误。 状态码的类别： 123 类别 原因短语 1XX Informational (信息性状态码) 接受的请求正在处理 2XX Success (成功状态码) 请求正常处理完毕 3XX Redirection (重定向状态码) 需要进行附加操作以完成请求 4XX Client Error (客户端错误状态码) 客户端请求出错 5XX Server Error (服务器错误状态码) 服务器处理请求出错 1XX——表明请求正在被处理 100 Continue：客户端应继续其请求。 101 Switching Protocols：服务器根据客户端请求切换协议。 2XX——表明请求被正常处理了 200 OK：请求已正常处理。 201 Created：成功请求并创建了新的资源。 202 Accepted：已经接收请求，但未处理完成。 203 Non-Authoritative Information：请求成功，但返回的meta信息不在原始的服务器，而是一个副本。 204 No Content：请求处理成功，但没有任何资源可以返回给客户端。 205 Reset Content：服务器处理成功，用户终端应重置文档视图。 206 Partial Content：服务器成功处理了部分GET请求。 3XX——表明要完成请求，需要进一步操作 300 Multiple Choices ：针对请求，服务器可执行多种操作。服务器可根据请求者选择一项操作。或提供操作列表供请求者选择。 301 Moved Permanently：请求的资源已被永远的移动到新URL，返回信息会包括新的URI，浏览器会自动定向到新URI。 302 Found：与301类似，但是资源只是临时被移动，客户端应继续使用原URI。 303 See Other：查看其他地址。 304 Not Modified：所请求的资源未修改，服务器返回此状态码，不会返回任何资源。 305 Use Proxy：所请求的资源必须通过代理访问。 307 Temporary Redirect：临时重定向，与302类似，使用FET请求重定向。 4XX——表明请求出错 400 Bad Request：客户端请求的语法错误，服务器无法理解。 401 Unauthorized：请求要求用户的身份认证。 403 Forbidden：服务器理解请求客户端的请求，但是拒绝执行此请求。 404 Not Found：服务器无法根据客户端的请求找到资源。 405 Method Not Allowed：客户端请求中的方法被禁止。 406 Not Acceptable：服务器无法根据客户端请求的内容特性完成请求。 407 Proxy Authentication Required：请求要求代理的身份认证，与401类似。但请求者应当使用代理进行授权。 408 Request Time-out：服务器等待客户端发送的请求时间过长，超时。 409 Conflict：服务器完成客户端的PUT请求时可能返回此代码，服务器处理请求时发送了冲突。 410 Cone：客户端请求的资源已经不存在。 411 Length Required：服务器无法处理客户端发送的不带Content-Length的请求信息。 412 Precondition Failed：客户端请求信息的先决条件错误。 413 Request Entity Too Large：由于请求的实体过大，服务器无法处理，因此拒绝请求。 414 Request-URI Too Large：请求的URI过长，服务器无法处理。 415 Unsupported Media Type：服务器无法处理请求附带的媒体格式。 416 Requested range not satisfiable：客户端请求的范围无效。 417 Expectation Failed：服务器无法满足Expect的请求头信息。 5XX——表明服务器处理请求错误 500 Internal Server Error：服务器内部错误，无法完成请求。 501 Not Implemented：服务器不支持请求的功能，无法完成请求。 502 Bad Gateway：作为网关或者代理工作的服务器尝试执行请求时，从远处服务器接收到了一个无效的响应。 503 Service Unavailable：由于超载或系统维护，服务器暂时的无法处理客户端的请求。 504 Gateway Time-out：充当网关或者代理的服务器未及时从远端服务器获取请求。 505 HTTP Version not supported：服务器不支持请求的HTTP协议的版本，无法完成处理。]]></content>
  </entry>
  <entry>
    <title><![CDATA[常见六大Web安全按攻防解析]]></title>
    <url>%2F2019%2F08%2F29%2F%E5%B8%B8%E8%A7%81%E5%85%AD%E5%A4%A7Web%E5%AE%89%E5%85%A8%E6%8C%89%E6%94%BB%E9%98%B2%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[在互联网时代，数据安全与个人隐私受到了前所未有的挑战，各种新奇的攻击技术层出不穷。如何才能更好地保护我们的数据？ XSSXSS（Cross-Site Scripting），跨站脚本攻击，因为缩写和CSS重叠，所有只能叫XSS。跨站脚本攻击时指通过存在安全漏洞的Web网站注册用户的浏览器内运行非法的HTML标签或JavaScript进行的一种攻击。 跨站脚本攻击有可能造成以下影响： 利用脚本输入表单骗取用户个人信息； 利用脚本窃取用户的Cookie值，被害者在不知情的情况下，帮助攻击者发送恶意请求； 显示伪造的文章或图片； XSS的原理是恶意攻击者往Web页面里插入恶意可执行网页脚本代码，当用户浏览该页之时，嵌入其中Web里面的脚本代码会被执行，从而可以达到攻击者盗取用户信息或其他侵犯用户安全隐私的目的。 XSS的攻击方式千变万化，但还是可以大致细分为几种类型。 非持久型XSS（反射型XSS） 非持久型XSS漏洞，一般是通过给别人发送带有恶意脚本代码参数的URL，当URL地址被打开时，特有的恶意代码参数被HTML解析、执行。 举个例子，比如页面中包含以下代码： 12345678910&lt;select&gt; &lt;script&gt; document.write('' + '&lt;option value=1&gt;' + location.href.substring(location.href.indexOf('default=') + 8) + '&lt;/option&gt;' ); document.write('&lt;option value=2&gt;English&lt;/option&gt;'); &lt;/script&gt;&lt;/select&gt; 攻击者可以直接通过 URL (类似：https://xxx.com/xxx?default=&lt;script&gt;alert(document.cookie)&lt;/script&gt;) 注入可执行的脚本代码。不过一些浏览器如Chrome其内置了一些XSS过滤器，可以防止大部分反射型XSS攻击。 非持久型 XSS 漏洞攻击有以下几点特征： 即时性，不经过服务器存储，直接通过HTTP的GET和POST请求就能完成一次攻击，拿到用户隐私数据； 攻击者需要诱骗点击，必须要通过用户点击链接才能发起； 反馈率低，所以较难发现和响应修复； 盗取用户敏感保密信息； 为了防止出现非持久型XSS漏洞，需要确保这么几件事情： Web页面渲染的所以内容或者渲染的数据都必须来自服务端； 尽量不要从URL、document.referrer、document.forms 等这种 DOM API 中获取数据直接渲染； 尽量不要使用 eval, new Function()，document.write()，document.writeln()，window.setInterval()，window.setTimeout()，innerHTML，document.createElement() 等可执行字符串的方法。 如果做不到以上几点，也必须对涉及 DOM 渲染的方法传入的字符串参数做 escape 转义。 前端渲染的时候对任何的字段都需要做 escape 转义编码。 持久型XSS（存储型XSS） 持久型 XSS 漏洞，一般存在于 Form 表单提交等交互功能，如文章留言，提交文本信息等，黑客利用的 XSS 漏洞，将内容经正常功能提交进入数据库持久保存，当前端页面获得后端从数据库中读出的注入代码时，恰好将其渲染执行。 举个例子，对于评论功能来说，就得防范持久型XSS攻击，因为我可以在评论中输入以下内容。 主要注入页面方式和非持久型XSS漏洞类似，只不过持久型的不是来源于URL、referrer、forms等，而是来源于后端从数据库中读取来的数据。持久型XSS攻击不需要诱骗点击，黑客只需要在提交表单的地方完成注入即可，但是这种XSS攻击的成本相对还是很高。 攻击成功需要同时满足以下几个条件： POST请求提交表单后端没有做转义直接入库； 后端从数据库中取出数据没有做转义直接输出给前端； 前端拿到后端数据没做转义直接渲染成DOM； 持久型XSS有以下几个特点： 持久型，植入在数据库中； 盗取用户敏感私密信息； 危害面广； 如何防御 对于XSS攻击来说，通常有两者方式可以用来防御。 （1）CSP CSP本质上就是建立白名单，开发者明确告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截时由浏览器自己实现的。我们可以通过这种方式来尽量减少XSS攻击。 通常可以通过两种方式来开启CSP： 设置HTTP Header中的Content-Security-Policy； 设置meta标签的方式； 这里以设置HTTP Header来举例： 只允许加载本站资源 1Content-Security-Policy: default-src 'self' 只允许加载HTTPS协议图片 1Content-Security-Policy: img-src https://* 允许加载任何来源框架 1Content-Security-Policy: child-src 'none' 如需了解更多属性，请参考Content-Security-Policy文档 对于这种方式来说，只能开发者配置了正确的规则，那么即使网站存在漏洞，攻击者也不能执行它的攻击代码，并且CSP的兼容性也不错。 （2）转义字符 用户的输入永远不可信任的，最普遍的做法就是转义输入输出的内容，对于引号、尖括号、斜杠进行转义。 12345678910function escape(str) &#123; str = str.replace(/&amp;/g, '&amp;amp;') str = str.replace(/&lt;/g, '&amp;lt;') str = str.replace(/&gt;/g, '&amp;gt;') str = str.replace(/"/g, '&amp;quto;') str = str.replace(/'/g, '&amp;#39;') str = str.replace(/`/g, '&amp;#96;') str = str.replace(/\//g, '&amp;#x2F;') return str&#125; 但是对于显示富文本来说，显然不通过上面的办法来转义所以字符，因为这样会把需要的格式也过滤掉。对于这种情况，通常采用白名单过滤的办法，当然也可以通过黑名单过滤，但是考虑到需要过滤的标签和标签属性实在太多，更加推荐使用白名单的方式。 1234const xss = require('xss')let html = xss('&lt;h1 id="title"&gt;XSS Demo&lt;/h1&gt;&lt;script&gt;alert("xss");&lt;/script&gt;')// -&gt; &lt;h1&gt;XSS Demo&lt;/h1&gt;&amp;lt;script&amp;gt;alert("xss");&amp;lt;/script&amp;gt;console.log(html) （3）HttpOnly Cookie 这是预防XSS攻击窃取用户Cookie最有效的防御手段。Web应用程序在设置Cookie时，将其属性设为HttpOnly，就可以避免该网页的Cookie被客户端被恶意JavaScript窃取，保护用户Cookie信息。 CSRFCSRF（Cross Site Request Forgery），即跨站请求伪造，是一种常见的Web攻击，它利用用户已登录的身份，在用户毫不知情的情况下，以用户的命运完成非法操作。 CSRF攻击的原理 下面先介绍一下CSRF攻击的原理： 完成CSRF攻击必须要有三个条件： 用户已经登录了站点A，并在本地记录了Cookie； 在用户没有登出站点A的情况下（也就是Cookie生效的情况下），访问了恶意攻击者提供的引诱危险站点B（B站点要求访问站点A）； 站点A没有做任何CSRF防御； 我们来看一个例子：当我们登入转账页面后，突然眼前一亮惊现”XXX隐私照片，不看后悔一辈子”的链接，耐不住内心躁动，立马点击了该危险的网站（页面代码如下图所示），但当这页面一加载，便会执行submitForm这个方法来提交转账请求，从而将10块转给黑客。 如何防御 防范CSRF攻击可以遵循以下几种规则： Get请求不对数据进行修改； 不让第三方网站访问用户Cookie 阻止第三方网站请求接口 请求时附带验证信息，比如验证码或者Token （1）SameSite 可以对Cookie设置SameSite属性，该属性表示Cookie不随着跨域请求发送，可以很大程度减少CSRF的攻击，但是该属性目前并不是所有浏览器都兼容。 （2）Referer Check HTTP Referer是header的一部分，当浏览器向Web服务器发送请求时，一般会带上Referer信息告诉服务器是从哪个页面的链接过来的，服务器借此可以获得一些信息用于处理。可以通过检测请求的来源来防御CSRF攻击。正常请求的referer具有一定规律，如在提交表单的referer必定实在该页面发送的请求。所以通过检查http header referer的值是不是这个页面，来判断是不是CSRF攻击。 但当某些情况下如此从https跳转到http，浏览器处于安全考虑，不会发送referer，服务器就无法进行check了。若与该网站同域的其他网站有XSS漏洞，那么攻击者可以在其他网站注入恶意脚本，受害者进入了此类同域的网址，也会遭受攻击。处于以上原因，无法完全依赖Referer Check作为防御CSRF的主要手段。但是可以通过Referer Check来监控CSRF攻击的发生。 （3）Anti CSRF Token 目前比较完善的解决方案是加入Anti-CSRF-Token。即发送请求时在HTTP请求中以参数的形式加入一个随机产生的Token，并在服务器建立一个拦截器来验证这个Token。服务器读取浏览器当前域Cookie值，会进行校验该请求当中的Token和Cookie当中的Token值是否都存在且相等，才认为这是合法的请求。否则认为这次请求是违法的，拒绝该次服务。 这种方法相比Referer检查要安全很多，token可以在用户登陆后产生并放于session或cookie中，然后在每次请求时服务器把token从session或cookie中拿出，与本次请求中的token 进行比对。由于token的存在，攻击者无法再构造出一个完整的URL实施CSRF攻击。但在处理多个页面共存问题时，当某个页面消耗掉token后，其他页面的表单保存的还是被消耗掉的那个token，其他页面的表单提交时会出现token错误。 （4）验证码 应用程序和用户进行交互过程中，特别是账户交易这种核心步骤，强制用户输入验证码，才能完成最终请求。在通常情况下，验证码够很好地遏制CSRF攻击。但增加验证码降低了用户的体验，网站不能给所有的操作都加上验证码。所以只能将验证码作为一种辅助手段，在关键业务点设置验证码。 点击劫持点击劫持是一种视觉欺骗的攻击手段。攻击者将需要攻击的网站通过 iframe 嵌套的方式嵌入自己的网页中，并将 iframe 设置为透明，在页面中透出一个按钮诱导用户点击。 特点 隐蔽性较高，骗取用户操作； “UI-覆盖攻击”； 利用iframe或者其它标签的属性； 点击劫持的原理 用户在登录A网站的系统后，被攻击者诱惑打开第三方网站，而第三方网站通过iframe引入了A网站的页面内容，用户在第三方网站中点击某个按钮（被装饰的按钮），实际上是点击了A网站的按钮。接下来我们举个例子：我在有空发布了很多视频，想让更多的人关注它，就可以通过点击劫持来实现。 123456789101112131415161718192021222324iframe &#123;width: 1440px;height: 900px;position: absolute;top: -0px;left: -0px;z-index: 2;-moz-opacity: 0;opacity: 0;filter: alpha(opacity=0);&#125;button &#123;position: absolute;top: 270px;left: 1150px;z-index: 1;width: 90px;height:40px;&#125;&lt;/style&gt;......&lt;button&gt;点击脱衣&lt;/button&gt;&lt;img src="http://pic1.win4000.com/wallpaper/2018-03-19/5aaf2bf0122d2.jpg"&gt;&lt;iframe src="http://i.youku.com/u/UMjA0NTg4Njcy" scrolling="no"&gt;&lt;/iframe&gt; 从上图可知，攻击者通过图片作为页面背景，隐藏了用户操作的真实界面，当你按耐不住好奇点击按钮以后，真正的点击的其实是隐藏的那个页面的订阅按钮，然后就会在你不知情的情况下订阅了。 如何防御 （1）X-FRAME-OPTIONS X-FRAME-OPTIONS是一个HTTP响应头，在现代浏览器有一个很好的支持。这个HTTP响应头就是为了防御用iframe嵌套的点击劫持攻击。 该响应头有三个值可选，分别是： DENY，表示页面不允许通过 iframe 的方式展示 SAMEORIGIN，表示页面可以在相同域名下通过 iframe 的方式展示 ALLOW-FROM，表示页面可以在指定来源的 iframe 中展示 （2）JavaScript防御 对于某些远古浏览器来说，并不能支持上面的这种方式，那我们只有通过 JS 的方式来防御点击劫持了。 1234567891011121314151617&lt;head&gt; &lt;style id="click-jack"&gt; html &#123; display: none !important; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; if (self == top) &#123; var style = document.getElementById('click-jack') document.body.removeChild(style) &#125; else &#123; top.location = self.location &#125; &lt;/script&gt;&lt;/body&gt; 以上代码的作用就是当通过 iframe 的方式加载页面时，攻击者的网页直接不显示所有内容了。 URL跳转漏洞定义：借助未验证的URL跳转，将应用程序引导到不安全的第三方区域，从而导致的安全问题。 URL跳转漏洞原理 黑客利用URL跳转漏洞来诱导安全意识低的用户点击，导致用户信息泄露或者资金的流失。其原理是黑客构建恶意链接（链接需要进行伪装，尽可能迷惑），发在QQ群或者浏览量多的贴吧/论坛中，安全意识低的用户点击后，经过服务器或者浏览器解析后，跳到恶意的网站中。 诸如伪装成像如下的网址，你是否能够识别出来是恶意网址呢？ 123http://gate.baidu.com/index?act=go&amp;url=http://t.cn/RVTatrdhttp://qt.qq.com/safecheck.html?flag=1&amp;url=http://t.cn/RVTatrdhttp://tieba.baidu.com/f/user/passport?jumpUrl=http://t.cn/RVTatrd 实现方式： Header跳转 JavaScript跳转； meta标签跳转； 这里我们举个Header跳转实现： 1234&lt;?php$url=$_GET['jumpto'];header("Location: $url");?&gt; 1http://www.wooyun.org/login.php?jumpto=http://www.evil.com 这里用户会认为www.wooyun.org都是可信的，但点击上述链接将导致用户最终访问www.evil.com这个恶意网址。 如何防御 （1）referer的限制 如果确定传递URL参数进入的来源，我们可以通过该方式实现安全限制，保证该URL的有效性，避免恶意用户自己生成跳转链接。 （2）加入有效性验证Token 我们保证所有生成的链接都是来自于我们可信域的，通过在生成的链接里加入用户不可控的Token对生成的链接进行校验，可以避免用户生成自己的恶意链接从而被利用，但是如果功能本身要求比较开发，可能导致有一定的限制。 SQL注入SQL注入是一种常见的Web安全漏洞，攻击者利用这个漏洞，可以访问或修改数据，或者利用潜在的数据库漏洞进行攻击。 SQL注入的原理 我们先举个万能钥匙的例子来说明其原理： 12345&lt;form action="/login" method="POST"&gt; &lt;p&gt;Username: &lt;input type="text" name="username" /&gt;&lt;/p&gt; &lt;p&gt;Password: &lt;input type="password" name="password" /&gt;&lt;/p&gt; &lt;p&gt;&lt;input type="submit" value="登陆" /&gt;&lt;/p&gt;&lt;/form&gt; 后端的SQL语句可能是如下这样的： 1234567let querySQL = ` SELECT * FROM user WHERE username='$&#123;username&#125;' AND psw='$&#123;password&#125;'`;// 接下来就是执行 sql 语句... 这是我们经常见到的登录页面，但如果有一个恶意攻击者输入的用户名是 admin&#39; --，密码随意输入，就可以直接登入系统了。why! —-这就是SQL注入。 我们之前预想的SQL 语句是: 1SELECT * FROM user WHERE username='admin' AND psw='password' 但是恶意攻击者用奇怪用户名将你的 SQL 语句变成了如下形式： 1SELECT * FROM user WHERE username='admin' --' AND psw='xxxx' 在 SQL 中,&#39; --是闭合和注释的意思，– 是注释后面的内容的意思，所以查询语句就变成了： 1SELECT * FROM user WHERE username='admin' 所谓的万能密码的本质，就是SQL注入的一种利用方式 一次SQL注入的过程包括以下几个过程 获取用户请求参数； 拼接到代码当中； SQL语句按照我们构造参数的语义执行成功； SQL注入的必备条件：1. 可以控制输入的数据。2. 服务器要执行的代码拼接了控制的数据 我们会发现SQL注入流程中与正常请求服务器类似，只是黑客控制了数据，构造了SQL查询，而正常的请求不会SQL查询这一步，SQL注入的本质:数据和代码未分离，即数据当做了代码来执行。 危害 获取数据库信息 管理员后台用户名和密码 获取其他数据库敏感信息：用户名、密码、手机号码、身份证、银行卡信息…… 整个数据库：脱库 获取服务器权限 植入WebShell，获取服务器后面 读取服务器敏感文件 如何防御 严格限制Web应用的数据库的操作权限，给此用户提供仅仅能够满足其工作的最低权限，从而最大限度的减少注入攻击对数据库的危害； 后端代码检查输入的数据是否符合预期，严格限制变量的类型，例如使用正则表达式进行一些匹配处理； 对进行数据库的特殊字符（’，”，\，&lt;，&gt;，&amp;，*，; 等）进行转义处理，或编码转换。基本上所有的后端语言都有对字符串进行转义处理的方法，比如lodash 的 lodash._escapehtmlchar 库。 所有的查询语句建议使用数据库提供的参数化查询接口，参数化的语句使用参数而不是将用户输入变量嵌入到SQL语句中，即不要直接拼接SQL语句。例如Node.js中的mysqljs库的query方法中的？占位参数。 OS命令注入攻击OS命令注入和SQL注入差不多，只不过SQL注入是针对数据库的，而OS命令注入是针对操作系统的。OS命令注入攻击指通过Web应用，执行非法的操作系统命令达到攻击的目的。只要在能调用Shell函数的地方久有存在被攻击的风险。倘若调用Shell存在疏漏，就可以执行插入的非法命令。 命令注入攻击可以向Shell发送命令，让Windows或Linux操作系统的命令行启动程序，也就是说，通过命令注入攻击可执行操作系统上安装着的各种程序。 原理 黑客构造命令提交给Web应用程序，Web应用程序提取黑客构造的命令，拼接到被执行的命令中，因黑客注入的命令打破了原有命令结构，导致Web应用执行了额外的命令，最后Web应用程序将执行的结果输出到响应页面中。 我们通过一个例子来说明其原理，假如需要实现一个需求：用户提交一些内容到服务器，然后在服务器执行一些系统命令去返回一个结果给用户。 1234// 以 Node.js 为例，假如在接口中需要从 github 下载用户指定的 repoconst exec = require('mz/child_process').exec;let params = &#123;/* 用户输入的参数 */&#125;;exec(`git clone $&#123;params.repo&#125; /some/path`); 如果 params.repo 传入的是 https://github.com/admin/admin.github.io.git 确实能从指定的 git repo 上下载到想要的代码。 但是如果 params.repo 传入的是 https://github.com/xx/xx.git &amp;&amp; rm -rf /* &amp;&amp; 恰好你的服务是用 root 权限起的就糟糕了。 如何防御 后端对前端提交内容进行规则限制（比如正则表达式）； 在调用系统命令前对所有传入参数进行命令行参数转义过滤； 不要直接拼接命令语句，借助一些工具做拼接、转义预处理，例如 Node.js 的 shell-escape npm包；]]></content>
  </entry>
  <entry>
    <title><![CDATA[HTTPS工作原理]]></title>
    <url>%2F2019%2F08%2F27%2FHTTPS%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[近几年，互联网发送着翻天覆地的变化，尤其是我们一直习以为常的HTTP协议，在逐渐的被HTTPS协议所取代，在浏览器、搜索引擎、CA机构、大型互联网企业的共同促进下，互联网迎来了“HTTPS加密时代”，HTTPS将在未来的几年内全面取代HTTP成为传输协议的主流。 什么是HTTPSHTTPS是在HTTP上建立SSL加密层，并对传输数据进行加密，是HTTP协议的完全版。现在它被广泛用于万维网上安全敏感的通讯，例如交易支付方面。 HTTPS主要作用是： 对数据进行加密，并建立一个信息安全通道，来保证传输过程中的数据安全。 对网站服务器进行真实身份认证。 我们经常会在Web的登录页面和购物结算界面等使用HTTPS通信。使用HTTPS通信时，不再用http://，而是改用https://。另外，当浏览器访问HTTPS通信有效的Web网站时，浏览器的地址栏内会出现一个带锁的标志。对HTTPS的显示方式会因浏览器的不同而有所改变。 为什么需要HTTPS在HTTP协议中有可能存在信息窃取或身份伪装等安全问题。使用HTTPS通信机制可以有效地防止这些问题，接下来，我们先来了解下HTTP协议存在的哪些问题： 通信使用明文（不加密），内容可能被窃取。 由于HTTP本身不具备加密的功能，所以也无法做到对通信整体（使用HTTP协议通信的请求和响应的内容）进行加密，即，HTTP报文使用明文（指未经过加密的报文）方式发送。 HTTP明文协议的缺陷是导致数据泄露、数据篡改、流量劫持、钓鱼攻击等安全问题的重要原因。HTTP协议无法加密数据，所以通信数据都在网络中明文“裸奔”。通过网络的嗅探设备及一些技术手段，就可还原HTTP保温内容。 无法证明报文的完整性，所以可能遭篡改。 所谓完整性是指信息的准备度。若无法证明其完整性，通常也就意味着无法判断信息是否准确。由于HTTP协议无法证明 通信的报文完整性，因此，在请求或响应送出之后直到对方接收之前的这段时间内，即使请求或响应的内容遭到篡改，也没有办法获悉。换句话说，没有任何办法确认，发送的请求/响应和接收到的请求/响应是前后相同的。 不验证通信方的身份，因此有可能遭遇伪装。 HTTP协议中的请求和响应不会对通信方进行确认。在HTTP协议通信时，由于不存在确认通信方的处理步骤，任何人都可以发送请求。另外，服务器只要接收到请求，不管对方是谁都会返回一个响应（但也仅源于发送端的IP地址和端口号没有被Web服务器限定限制访问的前提下） 反观HTTPS协议，它比HTTP协议相比多了以下优势（下文会详细介绍）： 数据隐私性：内容经过对称加密，每个连接生成一个唯一的加密密钥。 数据完整性：内容传输经过完整性校验。 身份认证：第三方无法伪造服务器（客户端）身份。 HTTPS如何解决HTTP上述问题HTTPS并非时应用层的一种新协议。只是HTTP通信接口部分使用SSL和TLS协议代替而已。 通常，HTTP直接和TCP通信。当使用SSL时，则演变成先和SSL通信，再由SSL和TCP通信了。简言之，所谓HTTPS，其实就是身披SSL协议这层外壳的HTTP。 在采用SSL后，HTTP就拥有了HTTPS的加密、证书和完整性保护这些功能。也就是说HTTP加上加密处理和认证以及完整性保护后就是HTTPS。 HTTPS协议的主要功能基本都依赖于TLS/SSL协议，TLS/SSL的功能实现主要依赖于三类基本算法：散列函数、对此加密和非对称加密，其利用非对称加密实现身份认证和密钥协商，对称加密算法采用协商的密钥对数据加密，基于散列函数验证信息的完整性。 解决内容可能被窃听的问题——加密 对称加密 这种方式加密和解密同用一个密钥。加密和解密都会用到密钥。没有密钥就无法对密码解密，反过来说，任何人只要持有密钥就能解密了。 以对称加密方式加密时必须将密钥也发给对方。可究竟怎样才能完全地转交？在互联网上转发密钥时，如果通信被监听那么密钥就可会落人攻击者之手，同时也就失去了加密的意义。另外还得设法安全地保管接收到的密钥。 非对称加密 公开密钥加密使用一对非对称的密钥。一把叫做私有密钥，另一把叫做公开密钥。顾名思义，私有密钥不能让其他任何人知道，而公开密钥则可以随意发布，任何人都可以获得。 使用公开密钥加密方式，发送密文的一方使用对方的公开密钥进行加密处理，对方收到被加密的信息后，再使用自己的私有密钥进行解密。利用 这种方式，不需要发送用来解密的私有密钥，也不必担心密钥被攻击者窃听而盗走。 非对称加密的特点是信息传输一对多，服务器只需要维持一个私钥就能够和多个客户端加密通信。 这种方式有以下缺点： 公钥是公开的，所以针对私钥加密的信息，黑客截获后可以使用公钥进行解密，获取其中的内容； 公钥并不包含服务器的信息，使用非对称加密算法无法确保服务器身份的合法性，存在中间人攻击的风险，服务器发送给客户端的公钥可能在传送过程中被中间人截获并篡改； 使用非对称加密在数据加密解密过程需要消耗一定时间，降低了数据传输效率； 对称加密+非对称加密(HTTPS采用这种方式) 使用对称密钥的好处是解密的效率比较快，使用非对称密钥的好处是可以使得传输的内容不能被破解，因为就算你拦截到了数据，但是没有对应的私钥，也是不能破解内容的。就比如说你抢到了一个保险柜，但是没有保险柜的钥匙也不能打开保险柜。那我们就将对称加密与非对称加密结合起来,充分利用两者各自的优势，在交换密钥环节使用非对称加密方式，之后的建立通信交换报文阶段则使用对称加密方式。 具体做法是：发送密文的一方使用对方的公钥进行加密处理“对称的密钥”，然后对方用自己的私钥解密拿到“对称的密钥”，这样可以确保交换的密钥是安全的前提下，使用对称加密方式进行通信。所以，HTTPS采用对称加密和非对称加密两者并用的混合加密机制。 解决报文可能遭篡改问题——数字签名 网络传输过程中需要经过很多中间节点，虽然数据无法被解密，但可能被篡改，那如何校验数据的完整性呢？——校验数字签名 数字签名有两种功效： 能确定消息确定是由发送方签名并发出来的，因为别人假冒不了发送方的签名； 数字签名能确定消息的完整性，证明数据是否未被篡改； 数字签名如何生成： 将一段文本先用Hash函数生成消息摘要，然后用发送者的私钥加密生成数字签名，与原文一起传送给接收者。接下来就是接收者校验数字签名的流程了。 接收者只有用发送者的公钥才能解密被加密的摘要信息，然后用Hash函数对收到的原文产生一个摘要信息，与上一步得到的摘要信息对比。如果相同，则说明收到的信息是完整的，在传输过程中没有被修改，否则说明信息被修改过，因此数字签名能检验信息的完整性。 假设消息传递在Kobe，James两人之间发生。James将消息连同数字签名一起发送给Kobe，Kobe接收到消息后，通过校验数字签名，就可以验证接收到的消息就是James发送的。当然，这个过程的前提是Kobe知道James的公钥。问题的关键的是，和消息本身一样，公钥不能在不安全的网络中直接发送给Kobe,或者说拿到的公钥如何证明是James的。 此时就需要引入了证书颁发机构（Certificate Authority，简称CA），CA数量并不多，Kobe客户端内置了所有受信任CA的证书。CA对James的公钥（和其他信息）数字签名后生成证书。 解决通信方身份可能被伪装的问题——数字证书 数字证书认证机构处于客户端与服务器双方都可信赖的第三方机构的立场上。 我们来介绍一下数字证书认证机构的业务流程 服务器的运营人员向第三方机构CA提交公钥、组织信息、个人信息(域名)等信息并申请认证; CA通过线上、线下等多种手段验证申请者提供信息的真实性，如组织是否存在、企业是否合法，是否拥有域名的所有权等; 如信息审核通过，CA会向申请者签发认证文件-证书。证书包含以下信息：申请者公钥、申请者的组织信息和个人信息、签发机构 CA的信息、有效时间、证书序列号等信息的明文，同时包含一个签名。 其中签名的产生算法：首先，使用散列函数计算公开的明文信息的信息摘要，然后，采用 CA的私钥对信息摘要进行加密，密文即签名; 客户端 Client 向服务器 Server 发出请求时，Server 返回证书文件; 客户端 Client 读取证书中的相关的明文信息，采用相同的散列函数计算得到信息摘要，然后，利用对应 CA的公钥解密签名数据，对比证书的信息摘要，如果一致，则可以确认证书的合法性，即服务器的公开密钥是值得信赖的。 客户端还会验证证书相关的域名信息、有效时间等信息; 客户端会内置信任CA的证书信息(包含公钥)，如果CA不被信任，则找不到对应 CA的证书，证书也会被判定非法。 HTTPS工作流程 Client发起一个HTTPS（比如https://juejin.im/user/5a9a9cdcf265da238b7d771c）的请求，根据RFC2818的规定，Client知道需要连接Server的443（默认）端口。 Server把事先配置好的公钥证书（public key certificate）返回给客户端。 Client验证公钥证书：比如是否在有效期间，证书的用途是不是匹配Client请求的站点，是不是在CRL吊销列表里面，它的上一级证书是否有效，这是一个递归的过程，直到验证到根证书（操作系统内置的Root证书或者Client内置的Root证书）。如果验证通过则继续，不通过则显示警告信息。 CLient使用伪随机数生成器生成加密所使用的对称密钥，然后用证书的公钥加密这个对称密钥，发给Server。 Server使用自己的私钥解密这个消息，得到对称密钥。至此，Client和Server双方都持有了相同的对称密钥。 Server使用对称密钥加密“明文内容A”，发送给Client。 Client使用对称密钥解密相应的密文，得到“明文内容A”。 Client再次发起HTTPS的请求，使用对称密钥加密请求的“明文内容B”，然后Server使用对称密钥解密密文，得到“明文内容B”。 HTTP与HTTPS的区别 HTTP是明文传输协议，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输，身份认证的网络协议，比HTTP协议安全。 关于安全性，用最简单的比喻形容两者的关系就是卡车运货，HTTP下的运货车是敞篷的，货物都是暴露的。而HTTPS则是封闭集装箱车，安全性自然提升不少。 HTTPS比HTTP更加安全，对搜索引擎更友好，利于SEO,谷歌、百度优先索引HTTPS网页; HTTPS需要用到SSL证书，而HTTP不用; HTTPS标准端口443，HTTP标准端口80; HTTPS基于传输层，HTTP基于应用层; HTTPS在浏览器显示绿色安全锁，HTTP没有显示; 为何不所有的网站都使用HTTPS既然HTTPS那么安全可靠，那为何所有的Web网站都使用HTTPS？ 首先，很多人还是会觉得HTTPS实施有门槛，这个门槛在于需要权威CA颁发的SSL证书。从证书的选择、购买到部署，传统的模式下都会比较耗时耗力。 其次，HTTPS普遍认为性能消耗要大于HTTP，因为与纯文本通信相比，加密通信会消耗更多的CPU及内存资源。如果每次通信都加密，会消耗相当多的资源，平摊到一台计算机上时，能够处理的请求数量必定也会随之减少。但事实并非如此，用户可以通过性能优化、把证书部署在SLB或CDN，来解决此问题。举个实际的例子，“双十一”期间，全站HTTPS的淘宝、天猫依然保证了网站和移动端的访问、浏览、交易等操作的顺畅、平滑。通过测试发现，经过优化后的许多页面性能与HTTP持平甚至还有小幅提升，因此HTTPS经过优化之后其实并不慢。 除此之外，想要节约购买证书的开销也是原因之一。要进行HTTPS通信，证书是必不可少的。而使用的证书必须向认证机构（CA）购买。 最后是安全意识。相比国内，国外互联网行业的安全意识和技术应用相对成熟，HTTPS部署趋势是由社会、企业、政府共同去推动的。]]></content>
  </entry>
  <entry>
    <title><![CDATA[九种跨域方式实现原理]]></title>
    <url>%2F2019%2F08%2F27%2F%E4%B9%9D%E7%A7%8D%E8%B7%A8%E5%9F%9F%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[前后端数据交互经常会碰到请求跨域，什么是跨域，以及有哪几种跨域方式，这是本文要探讨的内容。 什么是跨域 什么是同源策略及其限制内容 同源策略是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS，CSRF等攻击。所谓同源是指“协议+域名+端口”三者相同，即便两个不同的域名指向同一个ip地址，也非同源。 同源策略限制内容有： Cookie、LocalStorage、IndexedDB等存储性内容 DOM节点 AJAX请求发送后，结果被浏览器拦截了 但是有三个标签是允许跨域加载资源： &lt;img scr=XXX&gt; &lt;link href=XXX&gt; &lt;script src=XXX&gt; 常见跨域场景 当协议、子域名、主域名、端口号中有任意一个不相同时，都算作不同域。不同域之间相互请求资源，就算作“跨域”。常见跨域场景如下图所示： 特别说明两点： 第一：如果时协议和端口造成的跨域问题，“前台”时无能为力的 第二：在跨域问题上，仅仅是通过“URL的首部”来识别而不会根据域名对应的IP地址是否相同来判断。“URL的首部”可以理解为“协议，域名和端口必须匹配”。 这里你或许有个疑问：请求跨域了，那请求到底发出去没有？ 跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了。你可能会疑问明明通过表单的方式可以发送跨域请求，为什么Ajax就不会？因为归根结底，跨域是为了阻止用户读取到另一个域名下的内容，Ajax可以获取响应，浏览器认为这不安全，所以拦截了响应。但是表单并不会获取新的内容，所以可以发起跨域请求。同时也说明了跨域并不能完全阻止CSRF，因为请求毕竟是发出去了。 跨域解决方案 jsonp JSONP原理 利用&lt;script&gt;标签没有跨域限制的漏洞，网页可以得到从其他来源动态产生JSON数据。JSONP请求一定需要对方的服务器做支持才可以。 JSONP和AJAX对比 JSONP和AJAX相同，都是客户端向服务器端发送请求，从服务器端获取数据的方式。但AJAX属于同源策略，JSONP属于非同源策略（跨域请求）。 JSONP的优缺点 JSONP优点是简单兼容性好，可用于解决主流浏览器的跨域s数据访问的问题。缺点是仅支持get方法具有局限性，不安全可能会遭受XSS攻击。 JSONP的实现流程 声明一个回调函数，其函数名（如show）当做参数值，要传递给跨域请求数据的服务器，函数形参为要获取目标数据（服务器返回的data） 创建一个&lt;script&gt;标签，把哪个跨域的API数据接口地址，赋值给script的src，还要在这个地址中向服务器传递该函数名（可以通过问好传参：?callback=show）。 服务器接收到请求后，需要进行特殊的处理：把传递进来的函数名和它需要给你的数据拼接成一个字符串，例如：传递进来的函数名是show，它准备好的数据是show(‘我不爱你’)。 最后服务器把准备的数据通过HTTP协议返回给客户端，客户端再调用执行之前按声明的会点函数（show）,对返回的数据进行操作。 在开发中可能会遇到多个JSONP请求的回电函数名是相同的，这时候就需要自己封装一个JSONP函数。 123456789101112131415161718192021222324// index.htmlfunction jsonp(&#123; url, params, callback &#125;) &#123; return new Promise((resolve, reject) =&gt; &#123; let script = document.createElement('script') window[callback] = function(data) &#123; resolve(data) document.body.removeChild(script) &#125; params = &#123; ...params, callback &#125; // wd=b&amp;callback=show let arrs = [] for (let key in params) &#123; arrs.push(`$&#123;key&#125;=$&#123;params[key]&#125;`) &#125; script.src = `$&#123;url&#125;?$&#123;arrs.join('&amp;')&#125;` document.body.appendChild(script) &#125;)&#125;jsonp(&#123; url: 'http://localhost:3000/say', params: &#123; wd: 'Iloveyou' &#125;, callback: 'show'&#125;).then(data =&gt; &#123; console.log(data)&#125;) 上面这段代码相当于向http://localhost:3000/say?wd=Iloveyou&amp;callback=show这个地址请求数据，然后后台返回show(&#39;我不爱你&#39;)，最后会运行show()这个函数，打印出’我不爱你’。 jQuery的hsonp形式 JSONP都是GET和异步请求的，不存在其他的请求方式和同步请求，且jQuery默认就会给JSONP的请求清除缓存。 123456789$.ajax(&#123; url:"http://crossdomain.com/jsonServerResponse", dataType:"jsonp", type:"get",//可以省略 jsonpCallback:"show",//-&gt;自定义传递给服务器的函数名，而不是使用jQuery自动生成的，可省略 jsonp:"callback",//-&gt;把传递函数名的那个形参callback，可省略 success:function (data)&#123; console.log(data);&#125;&#125;); CORS CORS需要浏览器和后端同时支持。IE８和９需要通过XDomainRequest来实现。 浏览器会自动进行CORS通信，实现CORS通信的关键是后端，只要后端实现了CORS，就实现了跨域。 服务器设置Access-Control-Allow-Origin就可以开启CORS。该属性表示哪些域名可以访问资源，如果设置通配符则表示所以网站都可以访问资源。 虽然设置CORS和前端没什么关系，但是通过这种方式解决跨域问题的话，胡在发送请求时出现两种情况，分别为简单请求和复杂请求。 简单请求 只要同时满足以下两大条件，就属于简单请求 条件1：使用下列方法之一： GET HEAD POST 条件2：Content-Type的值仅限于下列三者之一： text/plain multipart/form-data application/x-www-form-urlencoded 请求中的任意XMLHttpRequestUpload对象均没有注册任何事件监听器； XMLHttpRequestUpload 对象可以使用 XMLHttpRequest.upload 属性访问。 复杂请求 不符合以上条件的请求就肯定是复杂请求了，复杂请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为“预检”请求，该请求是option方法的，通过该请求来知道服务端是否允许跨域请求。 我们用PUT向后台请求时，属于复杂请求，后台需做如下配置： 12345678910111213// 允许哪个方法访问我res.setHeader('Access-Control-Allow-Methods', 'PUT')// 预检的存活时间res.setHeader('Access-Control-Max-Age', 6)// OPTIONS请求不做任何处理if (req.method === 'OPTIONS') &#123; res.end() &#125;// 定义后台返回的内容app.put('/getData', function(req, res) &#123; console.log(req.headers) res.end('我不爱你')&#125;) 接下来我们看一下完整复杂请求的例子，并且介绍CORS请求相关的字段 12345678910111213141516// index.htmllet xhr = new XMLHttpRequest()document.cookie = 'name=xiamen' // cookie不能跨域xhr.withCredentials = true // 前端设置是否带cookiexhr.open('PUT', 'http://localhost:4000/getData', true)xhr.setRequestHeader('name', 'xiamen')xhr.onreadystatechange = function() &#123; if (xhr.readyState === 4) &#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status === 304) &#123; console.log(xhr.response) //得到响应头，后台需设置Access-Control-Expose-Headers console.log(xhr.getResponseHeader('name')) &#125; &#125;&#125;xhr.send() 12345//server1.jslet express = require('express');let app = express();app.use(express.static(__dirname));app.listen(3000); 123456789101112131415161718192021222324252627282930313233343536//server2.jslet express = require('express')let app = express()let whitList = ['http://localhost:3000'] //设置白名单app.use(function(req, res, next) &#123; let origin = req.headers.origin if (whitList.includes(origin)) &#123; // 设置哪个源可以访问我 res.setHeader('Access-Control-Allow-Origin', origin) // 允许携带哪个头访问我 res.setHeader('Access-Control-Allow-Headers', 'name') // 允许哪个方法访问我 res.setHeader('Access-Control-Allow-Methods', 'PUT') // 允许携带cookie res.setHeader('Access-Control-Allow-Credentials', true) // 预检的存活时间 res.setHeader('Access-Control-Max-Age', 6) // 允许返回的头 res.setHeader('Access-Control-Expose-Headers', 'name') if (req.method === 'OPTIONS') &#123; res.end() // OPTIONS请求不做任何处理 &#125; &#125; next()&#125;)app.put('/getData', function(req, res) &#123; console.log(req.headers) res.setHeader('name', 'jw') //返回一个响应头，后台需设置 res.end('我不爱你')&#125;)app.get('/getData', function(req, res) &#123; console.log(req.headers) res.end('我不爱你')&#125;)app.use(express.static(__dirname))app.listen(4000) 上述代码由http://localhost:3000/index.html向http://localhost:4000/跨域请求，正如我们上面所说的，后端是实现 CORS 通信的关键。 postMessage postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题： 页面和其打开的新窗口的数据传递 多窗口之间消息传递 页面与嵌套的iframe消息传递 上面三个场景的跨域数据传递 postMessage()方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递。 otherWindows.oistMessage(message, targetOrigin, [transfer]); message: 将要发送到其他 window的数据。 targetOrigin:通过窗口的origin属性来指定哪些窗口能接收到消息事件，其值可以是字符串”*”（表示无限制）或者一个URI。在发送消息的时候，如果目标窗口的协议、主机地址或端口这三者的任意一项不匹配targetOrigin提供的值，那么消息就不会被发送；只有三者完全匹配，消息才会被发送。 transfer(可选)：是一串和message 同时传递的 Transferable 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。 接下来我们看个例子： http://localhost:3000/a.html页面向http://localhost:4000/b.html传递“我爱你”,然后后者传回”我不爱你”。 123456789101112// a.html &lt;iframe src="http://localhost:4000/b.html" frameborder="0" id="frame" onload="load()"&gt;&lt;/iframe&gt; //等它加载完触发一个事件 //内嵌在http://localhost:3000/a.html &lt;script&gt; function load() &#123; let frame = document.getElementById('frame') frame.contentWindow.postMessage('我爱你', 'http://localhost:4000') //发送数据 window.onmessage = function(e) &#123; //接受返回数据 console.log(e.data) //我不爱你 &#125; &#125; &lt;/script&gt; 12345// b.html window.onmessage = function(e) &#123; console.log(e.data) //我爱你 e.source.postMessage('我不爱你', e.origin) &#125; WebSocket WebSocket是HTML5的一个持久化的协议，它实现了浏览器与服务器的全双工通信，同时也是跨域的一种解决方案。WebSocket和HTTP都是应用层协议，都基于TCP协议。但是WebSocket是一种双向通信协议，在建立连接之后，WebSocket的server与client都能主动向对方发送或接收数据。同时，WebSocket在建立连接时需要HTTP协议，连接建立好了之后client与server之间的双向通信就与HTTP无关了。 原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好地封装了WebSocket接口，提供了更简单、灵活的接口，也对不支持WebSocket的浏览器提供向下兼容。 我们先来看个例子：本地文件socket.html向localhost:3000发生数据和接受数据 12345678910// socket.html&lt;script&gt; let socket = new WebSocket('ws://localhost:3000'); socket.onopen = function () &#123; socket.send('我爱你');//向服务器发送数据 &#125; socket.onmessage = function (e) &#123; console.log(e.data);//接收服务器返回的数据 &#125;&lt;/script&gt; 1234567891011// server.jslet express = require('express');let app = express();let WebSocket = require('ws');//记得安装wslet wss = new WebSocket.Server(&#123;port:3000&#125;);wss.on('connection',function(ws) &#123; ws.on('message', function (data) &#123; console.log(data); ws.send('我不爱你') &#125;);&#125;) Node中间件代理（两次跨域） 实现原理：同源策略是浏览器需要遵循的标准，而如果是服务器向服务器请求就无需遵循同源策略。代理服务器，需要做以下几个步骤： 接收客户端请求。 将请求转发给服务器 拿到服务器响应数据。 将响应数据转发给客户端 我们先来看个例子：本地文件index.html文件，通过代理服务器http://localhost:3000向目标服务器http://localhost:4000请求数据。 12345678910111213141516// index.html(http://127.0.0.1:5500) &lt;script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"&gt;&lt;/script&gt; &lt;script&gt; $.ajax(&#123; url: 'http://localhost:3000', type: 'post', data: &#123; name: 'xiamen', password: '123456' &#125;, contentType: 'application/json;charset=utf-8', success: function(result) &#123; console.log(result) // &#123;"title":"fontend","password":"123456"&#125; &#125;, error: function(msg) &#123; console.log(msg) &#125; &#125;) &lt;/script&gt; 1234567891011121314151617181920212223242526272829303132333435363738// server1.js 代理服务器(http://localhost:3000)const http = require('http')// 第一步：接受客户端请求const server = http.createServer((request, response) =&gt; &#123; // 代理服务器，直接和浏览器直接交互，需要设置CORS 的首部字段 response.writeHead(200, &#123; 'Access-Control-Allow-Origin': '*', 'Access-Control-Allow-Methods': '*', 'Access-Control-Allow-Headers': 'Content-Type' &#125;) // 第二步：将请求转发给服务器 const proxyRequest = http .request( &#123; host: '127.0.0.1', port: 4000, url: '/', method: request.method, headers: request.headers &#125;, serverResponse =&gt; &#123; // 第三步：收到服务器的响应 var body = '' serverResponse.on('data', chunk =&gt; &#123; body += chunk &#125;) serverResponse.on('end', () =&gt; &#123; console.log('The data is ' + body) // 第四步：将响应结果转发给浏览器 response.end(body) &#125;) &#125; ) .end()&#125;)server.listen(3000, () =&gt; &#123; console.log('The proxyServer is running at http://localhost:3000')&#125;) 1234567891011// server2.js(http://localhost:4000)const http = require('http')const data = &#123; title: 'fontend', password: '123456' &#125;const server = http.createServer((request, response) =&gt; &#123; if (request.url === '/') &#123; response.end(JSON.stringify(data)) &#125;&#125;)server.listen(4000, () =&gt; &#123; console.log('The server is running at http://localhost:4000')&#125;) 上述代码经过两次跨域，值得注意的是浏览器向代理服务器发送请求，也遵循同源策略，最后在index.html文件打印出{&quot;title&quot;:&quot;fontend&quot;,&quot;password&quot;:&quot;123456&quot;} nginx反向代理 实现原理类似于Node中间件代理，需要你搭建一个中转nginx服务器，用于转发请求。 使用nginx反向代理实现跨域，是最简单的跨域方式。只需要修改nginx的配置即可解决跨域问题，支持所有浏览器，支持session，不需要修改任何代码，并且不会影响服务器性能。 实现思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。 先下载nginx，然后将nginx目录下的nginx.com修改如下： 1234567891011121314// proxy服务器server &#123; listen 81; server_name www.domain1.com; location / &#123; proxy_pass http://www.domain2.com:8080; #反向代理 proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名 index index.html index.htm; # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用 add_header Access-Control-Allow-Origin http://www.domain1.com; #当前端只跨域不带cookie时，可为* add_header Access-Control-Allow-Credentials true; &#125;&#125; 最后通过命令行nginx-sreload启动nginx 1234567// index.htmlvar xhr = new XMLHttpRequest();// 前端开关：浏览器是否读写cookiexhr.withCredentials = true;// 访问nginx中的代理服务器xhr.open('get', 'http://www.domain1.com:81/?user=admin', true);xhr.send(); 123456789101112131415// server.jsvar http = require('http');var server = http.createServer();var qs = require('querystring');server.on('request', function(req, res) &#123; var params = qs.parse(req.url.substring(2)); // 向前台写cookie res.writeHead(200, &#123; 'Set-Cookie': 'l=a123456;Path=/;Domain=www.domain2.com;HttpOnly' // HttpOnly:脚本无法读取 &#125;); res.write(JSON.stringify(params)); res.end();&#125;);server.listen('8080');console.log('Server is running at port 8080...'); window.name + iframewindow.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。 其中a.html和b.html是同域的，都是http://localhost:3000;而c.html是http://localhost:4000 12345678910111213141516&lt;iframe src="http://localhost:4000/c.html" frameborder="0" onload="load()" id="iframe"&gt;&lt;/iframe&gt; &lt;script&gt; let first = true // onload事件会触发2次，第1次加载跨域页，并留存数据于window.name function load() &#123; if(first)&#123; // 第1次onload(跨域页)成功后，切换到同域代理页面 let iframe = document.getElementById('iframe'); iframe.src = 'http://localhost:3000/b.html'; first = false; &#125;else&#123; // 第2次onload(同域b.html页)成功后，读取同域window.name中数据 console.log(iframe.contentWindow.name); &#125; &#125; &lt;/script&gt; b.html为中间代理页，与a.html同域，内容为空。 1234// c.html(http://localhost:4000/c.html) &lt;script&gt; window.name = '我不爱你' &lt;/script&gt; 总结：通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。 location.hash + iframe实现原理： a.html欲与c.html跨域相互通信，通过中间页b.html来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。 具体实现步骤：一开始a.html给c.html传一个hash值，然后c.html收到hash值后，再把hash值传递给b.html，最后b.html将结果放到a.html的hash值中。 同样的，a.html和b.html是同域的，都是http://localhost:3000;而c.html是http://localhost:4000 1234567// a.html &lt;iframe src="http://localhost:4000/c.html#iloveyou"&gt;&lt;/iframe&gt; &lt;script&gt; window.onhashchange = function () &#123; //检测hash的变化 console.log(location.hash); &#125; &lt;/script&gt; 12345// b.html &lt;script&gt; window.parent.parent.location.hash = location.hash //b.html将结果放到a.html的hash值中，b.html可通过parent.parent访问a.html页面 &lt;/script&gt; 12345// c.htmlconsole.log(location.hash); let iframe = document.createElement('iframe'); iframe.src = 'http://localhost:3000/b.html#idontloveyou'; document.body.appendChild(iframe); document.domain + iframe该方式只能用于二级域名相同的情况下，比如 a.test.com 和 b.test.com 适用于该方式。 只需要给页面添加 document.domain =&#39;test.com&#39; 表示二级域名都相同就可以实现跨域。 实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。 我们看个例子：页面a.zf1.cn:3000/a.html获取页面b.zf1.cn:3000/b.html中a的值 1234567891011// a.html&lt;body&gt; helloa &lt;iframe src="http://b.zf1.cn:3000/b.html" frameborder="0" onload="load()" id="frame"&gt;&lt;/iframe&gt; &lt;script&gt; document.domain = 'zf1.cn' function load() &#123; console.log(frame.contentWindow.a); &#125; &lt;/script&gt;&lt;/body&gt; 12345678// b.html&lt;body&gt; hellob &lt;script&gt; document.domain = 'zf1.cn' var a = 100; &lt;/script&gt;&lt;/body&gt;总结 CORS支持所有类型的HTTP请求，是跨域HTTP请求的根本解决方案 JSONP只支持GET请求，JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。 不管是Node中间件代理还是nginx反向代理，主要是通过同源策略对服务器不加限制。 日常工作中，用得比较多的跨域方案是cors和nginx反向代理]]></content>
  </entry>
  <entry>
    <title><![CDATA[浏览器渲染原理]]></title>
    <url>%2F2019%2F08%2F21%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[浏览器的内核是指支持浏览器运行的最核心的程序，分为两个部分的，一是渲染引擎，二是JS引擎。渲染引擎在不同的浏览器中也不是都相同的。目前市面上常见的柳然其内核可以分为这四种：Trident（IE）、Gecko（Firefox)、Blink（Chrome、Opera）、Webkit（Safari）。这里面大家最耳熟能详的应该是Webkit内核了，Webkit内核时当下浏览器最好的内核。 本文我就以Webkit为例，对现代浏览器的渲染过程进行一个深度的剖析。 页面加载过程在介绍浏览器渲染过程之前，我们简明扼要介绍下页面的加载过程，有助于更好理解后续渲染过程。 要点如下： 浏览器根据 DNS 服务器得到域名的 IP 地址。 向这个 IP 的机器发送 HTTP 请求 服务器收到、处理并返回 HTTP 请求 浏览器得到返回内容例如在浏览器输入https://juejin.im/timeline，然后经过 DNS 解析，juejin.im对应的 IP 是36.248.217.149（不同时间、地点对应的 IP 可能会不同）。然后浏览器向该 IP 发送 HTTP 请求。 服务端接收到 HTTP 请求，然后经过计算（向不同的用户推送不同的内容），返回 HTTP 请求，返回的内容如下：其实就是一堆 HMTL 格式的字符串，因为只有 HTML 格式浏览器才能正确解析，这是 W3C 标准的要求。接下来就是浏览器的渲染过程。 浏览器渲染过程 浏览器渲染过程大体分为如下三部分： 浏览器会解析三个东西： 一是HTML/SVG/XHTML，HTML字符串描述了一个页面的结构，浏览器会把HTML结构字符串解析转换DOM树形结构。 二是CSS，解析CSS会产生CSS规则树，它和DOM结构比较像。 三是Javascript脚本，等到Javascript 脚本文件加载后， 通过 DOM API 和 CSSOM API 来操作 DOM Tree 和 CSS Rule Tree。 解析完成后，浏览器引擎会通过DOM Tree和CSS Rule Tree来构造Rendering Tree。 Render Tree渲染树并不等同于DOM树，渲染树只会包括需要显示的节点和这些节点的样式信息。 CSS的Rule Tree主要是为了完成匹配并把CSS Rule附加上Rendering Tree上的每个ELement（也就是每个Frame）。 然后，计算每个Frame的位置，这又叫layout和reflow的过程 最好通过调用操作系统Native GUI的API绘制 接下来我们针对这其中所经历的重要步骤详细阐述 构建DOM浏览器会遵守一套步骤将HTML文件转换为DOM树。宏观上，可以分为几个步骤： 浏览器从磁盘或网络读取HTML的原始字节，并根据文件的指定编码（例如UTF-8）将它们转换成字符串。 在网络中传输的内容其实都是0与1这些字节数据，当浏览器接收到这些字节数据以后，它会将这些字节数据转换字符串，也就是我们写的代码。 将字符串转换Token，例如：、等。Token中会标识出当前Token是“开始标签”或是“结束标签”亦或是“文本”等信息。L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"log":false}); 这时候你一定会有疑问，节点与节点之间的关系如何维护？ 事实上，这就是Token要标识“起始标签”和“结束标签”等标识的作用。例如“title”Token的起始标签和结束标签之间的节点肯定是属于“head”的子节点 上图给出了节点之间的关系，例如：“Hello”Token位于“title”开始标签与“title”结束标签之间，表明“Hello”Token是“title”Token的子节点。同理“title”Token是“head”Token的子节点。 生成节点对象并构建DOM 事实上，构建DOM的过程中，不是等所有Token都转换完成后再去生成节点对象，而是一边生成Token一边消耗Token来生成节点对象。换句话说，每个Token被生成后，会立刻消耗这个Token创建出节点对象。注意：带有结束标签标识的Token不会创建节点对象。 接下来我们举个例子，假设有段HTML文本： 1234567891011&lt;html&gt;&lt;head&gt; &lt;title&gt;Web page parsing&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;h1&gt;Web page parsing&lt;/h1&gt; &lt;p&gt;This is an example Web page.&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 上面这段HTML会解析成这样： 构建CSSOMDOM会捕获页面的内容，但浏览器还需要知道页面如何展示，所以需要构建CSSOM。 构建CSSOM的过程与构建DOM的过程非常相似，当浏览器接收到一段CSS，浏览器首先要做的是识别出Token，然后构建节点并生成CSSOM。 在这一过程中，浏览器会确定下每一个节点的样式到底是什么，并且这一过程其实是很消耗资源的。因为样式你可以自行设置给某个节点，也可以通过继承获得。在这一过程中，浏览器得递归 CSSOM 树，然后确定具体的元素到底是什么样式。 注意：CSS匹配HTML元素是一个相当复杂和有性能问题的事情。所以，DOM树要小，CSS尽量用id和class，千万不要过渡层叠下去。 构架渲染树当我们生成 DOM 树和 CSSOM 树以后，就需要将这两棵树组合为渲染树。 在这一过程中，不是简单的将两者合并就行了。渲染树只会包括需要显示的节点和这些节点的样式信息，如果某个节点是 display: none 的，那么就不会在渲染树中显示。 我们或许有个疑惑：浏览器如果渲染过程中遇到JS文件怎么处理？ 渲染过程中，如果遇到&lt;script&gt;就停止渲染，执行 JS 代码。因为浏览器有GUI渲染线程与JS引擎线程，为了防止渲染出现不可预期的结果，这两个线程是互斥的关系。JavaScript的加载、解析与执行会阻塞DOM的构建，也就是说，在构建DOM时，HTML解析器若遇到了JavaScript，那么它会暂停构建DOM，将控制权移交给JavaScript引擎，等JavaScript引擎运行完毕，浏览器再从中断的地方恢复DOM构建。 也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。当然在当下，并不是说 script 标签必须放在底部，因为你可以给 script 标签添加 defer 或者 async 属性（下文会介绍这两者的区别）。 JS文件不只是阻塞DOM的构建，它会导致CSSOM也阻塞DOM的构建。 原本DOM和CSSOM的构建是互不影响，井水不犯河水，但是一旦引入了JavaScript，CSSOM也开始阻塞DOM的构建，只有CSSOM构建完毕后，DOM再恢复DOM构建。 这是什么情况？ 这是因为JavaScript不只是可以改DOM，它还可以更改样式，也就是它可以更改CSSOM。因为不完整的CSSOM是无法使用的，如果JavaScript想访问CSSOM并更改它，那么在执行JavaScript时，必须要能拿到完整的CSSOM。所以就导致了一个现象，如果浏览器尚未完成CSSOM的下载和构建，而我们却想在此时运行脚本，那么浏览器将延迟脚本执行和DOM构建，直至其完成CSSOM的下载和构建。也就是说，在这种情况下，浏览器会先下载和构建CSSOM，然后再执行JavaScript，最后在继续构建DOM。 布局与绘制当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动重排”。 布局流程的输出是一个“盒模型”，它会精确地捕获每个元素在视口内的确切位置和尺寸，所有相对测量值都将转换为屏幕上的绝对像素。 布局完成后，浏览器会立即发出“Paint Setup”和“Paint”事件，将渲染树转换成屏幕上的像素。 以上我们详细介绍了浏览器工作流程中的重要步骤，接下来我们讨论几个相关的问题： 几点补充说明 async和defer的作用是什么？有什么区别? 接下来我们对比下 defer 和 async 属性的区别： 其中蓝色线代表JavaScript加载；红色线代表JavaScript执行；绿色线代表 HTML 解析。 1）情况1&lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt;没有 defer 或 async，浏览器会立即加载并执行指定的脚本，也就是说不等待后续载入的文档元素，读到就加载并执行。 2）情况2&lt;script async src=&quot;script.js&quot;&gt;&lt;/script&gt; (异步下载)async 属性表示异步执行引入的 JavaScript，与 defer 的区别在于，如果已经加载好，就会开始执行——无论此刻是 HTML 解析阶段还是 DOMContentLoaded 触发之后。需要注意的是，这种方式加载的 JavaScript 依然会阻塞 load 事件。换句话说，async-script 可能在 DOMContentLoaded 触发之前或之后执行，但一定在 load 触发之前执行。 3）情况3 &lt;script defer src=&quot;script.js&quot;&gt;&lt;/script&gt;(延迟执行)defer 属性表示延迟执行引入的 JavaScript，即这段 JavaScript 加载时 HTML 并未停止解析，这两个过程是并行的。整个 document 解析完毕且 defer-script 也加载完成之后（这两件事情的顺序无关），会执行所有由 defer-script 加载的 JavaScript 代码，然后触发 DOMContentLoaded 事件。 defer 与相比普通 script，有两点区别：载入 JavaScript 文件时不阻塞 HTML 的解析，执行阶段被放到 HTML 标签解析完成之后。在加载多个JS脚本的时候，async是无顺序的加载，而defer是有顺序的加载。 为什么操作 DOM 慢 把 DOM 和 JavaScript 各自想象成一个岛屿，它们之间用收费桥梁连接。——《高性能 JavaScript》 JS 是很快的，在 JS 中修改 DOM 对象也是很快的。在JS的世界里，一切是简单的、迅速的。但 DOM 操作并非 JS 一个人的独舞，而是两个模块之间的协作。 因为 DOM 是属于渲染引擎中的东西，而 JS 又是 JS 引擎中的东西。当我们用 JS 去操作 DOM 时，本质上是 JS 引擎和渲染引擎之间进行了“跨界交流”。这个“跨界交流”的实现并不简单，它依赖了桥接接口作为“桥梁”（如下图）。 过“桥”要收费——这个开销本身就是不可忽略的。我们每操作一次 DOM（不管是为了修改还是仅仅为了访问其值），都要过一次“桥”。过“桥”的次数一多，就会产生比较明显的性能问题。因此“减少 DOM 操作”的建议，并非空穴来风。 你真的了解回流和重绘吗 渲染的流程基本上是这样（如下图黄色的四个步骤）：1.计算CSS样式 2.构建Render Tree 3.Layout – 定位坐标和大小 4.正式开画 注意：上图流程中有很多连接线，这表示了Javascript动态修改了DOM属性或是CSS属性会导致重新Layout，但有些改变不会重新Layout，就是上图中那些指到天上的箭头，比如修改后的CSS rule没有被匹配到元素。 这里重要要说两个概念，一个是Reflow，另一个是Repaint 重绘：当我们对 DOM 的修改导致了样式的变化、却并未影响其几何属性（比如修改了颜色或背景色）时，浏览器不需重新计算元素的几何属性、直接为该元素绘制新的样式（跳过了上图所示的回流环节）。 回流：当我们对 DOM 的修改引发了 DOM 几何尺寸的变化（比如修改元素的宽、高或隐藏元素等）时，浏览器需要重新计算元素的几何属性（其他元素的几何属性和位置也会因此受到影响），然后再将计算的结果绘制出来。这个过程就是回流（也叫重排） 我们知道，当网页生成的时候，至少会渲染一次。在用户访问的过程中，还会不断重新渲染。重新渲染会重复回流+重绘或者只有重绘。回流必定会发生重绘，重绘不一定会引发回流。重绘和回流会在我们设置节点样式时频繁出现，同时也会很大程度上影响性能。回流所需的成本比重绘高的多，改变父节点里的子节点很可能会导致父节点的一系列回流。 1）常见引起回流属性和方法任何会改变元素几何信息(元素的位置和尺寸大小)的操作，都会触发回流， 添加或者删除可见的DOM元素； 元素尺寸改变——边距、填充、边框、宽度和高度 内容变化，比如用户在input框中输入文字 浏览器窗口尺寸改变——resize事件发生时 计算 offsetWidth 和 offsetHeight 属性 设置 style 属性的值 2）常见引起重绘属性和方法 3）如何减少回流、重绘 使用 transform 替代 top 使用 visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回流（改变了布局） 不要把节点的属性值放在一个循环里当成循环里的变量。 1234for(let i = 0; i &lt; 1000; i++) &#123; // 获取 offsetTop 会导致回流，因为需要去获取正确的值 console.log(document.querySelector(&apos;.test&apos;).style.offsetTop)&#125; 不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局 动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 requestAnimationFrame CSS 选择符从右往左匹配查找，避免节点层级过多 将频繁重绘或者回流的节点设置为图层，图层能够阻止该节点的渲染行为影响别的节点。比如对于 video 标签来说，浏览器会自动将该节点变为图层。 性能优化策略基于上面介绍的浏览器渲染原理，DOM 和 CSSOM 结构构建顺序，初始化可以对页面渲染做些优化，提升页面性能。 JS优化： 1&lt;script&gt; 标签加上 defer属性 和 async属性 用于在不阻塞页面文档解析的前提下，控制脚本的下载和执行。 defer属性： 用于开启新的线程下载脚本文件，并使脚本在文档解析完成后执行。 async属性： HTML5新增属性，用于异步下载脚本文件，下载完毕立即解释执行代码。 CSS优化： &lt;link&gt; 标签的 rel属性 中的属性值设置为 preload 能够让你在你的HTML页面中可以指明哪些资源是在页面加载完成后即刻需要的,最优的配置加载顺序，提高渲染性能 总结综上所述，我们得出这样的结论： 浏览器工作流程：构建DOM -&gt; 构建CSSOM -&gt; 构建渲染树 -&gt; 布局 -&gt; 绘制。 CSSOM会阻塞渲染，只有当CSSOM构建完毕后才会进入下一个阶段构建渲染树。 通常情况下DOM和CSSOM是并行构建的，但是当浏览器遇到一个不带defer或async属性的script标签时，DOM构建将暂停，如果此时又恰巧浏览器尚未完成CSSOM的下载和构建，由于JavaScript可以修改CSSOM，所以需要等CSSOM构建完毕后再执行JS，最后才重新DOM构建。]]></content>
  </entry>
  <entry>
    <title><![CDATA[从URL输入到页面展现]]></title>
    <url>%2F2019%2F08%2F19%2F%E4%BB%8EURL%E8%BE%93%E5%85%A5%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[在浏览器中输入URL到整个页面显示在用户面前时这个过程中到底发生了什么？经历怎样的一个过程？ 总体来说分为以下几个过程： DNS解析：将域名分析成IP地址 TCP连接：TCP三次握手 发生HTTP请求 服务器处理请求并返回HTTP报文 浏览器解析渲染页面 断开连接：TCP四次握手 URL到底是啥URL（Uniform Resource Locator），统一资源定位符，用来定位互联网资源，俗称网址。 1scheme://host.domain:port/path/filename 各部分解释如下： scheme - 定义因特网服务的类型。常见的协议有http、https、ftp和file，其中最常见的类型是http，而https则是进行加密的网络传输。 host - 定义域主机(http的默认主机是www)。 domain - 定义因特网域名，比如w3school.com.cn。 port - 定义主机上的端口号（http的默认端口是80）。 path - 定义服务器上的路径（如果省略，则文档必须位于网站的根目录中）。 filename - 定义文档/资源的名称。 域名解析（DNS）在浏览器输入网址后，首先要经过域名解析，因为浏览器并不能直接通过域名找到对应的服务器，而是要通过IP地址。大家这里或许会有个疑问——计算机既可以被赋予IP地址，又可以被赋予主机名和域名。那怎么不一开始就赋予个 IP 地址？这样就可以省去解析麻烦。我们先来了解下什么是 IP 地址。 IP地址 IP地址是指互联网协议地址，是IP Address的缩写。IP地址是IP协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。IP地址是一个32位的二进制数，比如127.0.0.1为本机地址。 什么是域名解析 DNS协议提供通过域名查找IP地址，或逆向从IP地址反查找域名的服务。DNS是一个网络服务器，我们的域名解析简单来说就是在DNS上记录一条信息记录。 1例如 baidu.com 220.114.23.56（服务器外网IP地址）80（服务器端口号） 浏览器如何通过域名去查询URL对应的IP呢 浏览器缓存：浏览器会按照一定的频率缓存DNS记录。 操作系统缓存：如果浏览器缓存中找不到需要的DNS记录，那就去操作系统中找。 路由缓存：路由器也是有DNS缓存的。 ISP的DNS服务器：ISP是互联网服务提供商（Internet Service Provider）的简称，ISP有专门的DNS服务器应对DNS查询请求。 根服务器：ISP的DNS服务器还找不到的话，它就会向根服务器发出请求，进行递归查询（DNS 服务器先问根域名服务器.com 域名服务器的 IP 地址，然后再问.baidu 域名服务器，依次类推）。 小结 浏览器通过向 DNS 服务器发送域名，DNS 服务器查询到与域名相对应的 IP 地址，然后返回给浏览器，浏览器再将 IP 地址打在协议上，同时请求参数也会在协议搭载，然后一并发送给对应的服务器。接下来介绍向服务器发送 HTTP 请求阶段，HTTP 请求分为三个部分：TCP 三次握手、http 请求响应信息、关闭 TCP 连接。 TCP三次握手在客户端发送数据之前会发起 TCP 三次握手用以同步客户端和服务端的序列号和确认号，并交换 TCP 窗口大小信息。 TCP三次握手的过程如下： 客户端发送一个带SYN，Seq=X的数据包到服务器端口（第一次握手，由浏览器发起，告诉服务器我要发送请求了）。 服务器发回一个带 SYN=1， ACK=X+1， Seq=Y 的响应包以示传达确认信息（第二次握手，由服务器发起，告诉浏览器我准备接受了，你赶紧发送吧）。 客户端再回传一个带 ACK=Y+1， Seq=Z 的数据包，代表“握手结束”（第三次握手，由浏览器发送，告诉服务器，我马上就发了，准备接受吧）。 为什么需要三次握手 谢希仁著《计算机网络》中讲“三次握手”的目的是“为了防止已失效的连接请求报文段突然又传送到服务器端，因而产生错误”。 发送HTTP请求TCP三次握手结束后，开始发送HTTP请求报文。 请求报文由请求行（request line）、请求头（header）、空行、请求体四个部分组成，如下图所示： 请求行包含请求方法、URL、协议版本 请求方法包含8种：GET、POST、PUT、DELETE、PATCH、HEAD、OPTIONS、TRACE。 URL即请求地址，由&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;&lt;参数&gt;组成 协议版本即http版本号 1POST /chapter17/user.html HTTP/1.1 以上代码中“POST”代表请求方法，“/chapter17/user.html”表示 URL，“HTTP/1.1”代表协议和协议的版本。现在比较流行的是 Http1.1 版本。 请求头包含请求的附加信息，由关键字/值对组成，每行一对，关键字和值由英文冒号“:”分割。 请求头部通知服务器有关客户端请求的信息。它包含许多有关的客户端环境和请求正文的有用信息。其中比如：Host，表示主机名，虚拟主机；Connection，HTTP/1.1增加的，使用keep-alive，即持续连接，一个链接可以发送多个请求；User-Agent，请求发送者，兼容性以及定制化需求。 请求体，可以承载多个请求参数的数据，包含回车符、换行符和请求数据，并不是所有请求都具有请求数据。 1name=tom&amp;password=1234&amp;realName=tomson 上面代码，承载着 name、password、realName 三个请求参数。 服务器处理请求并返回HTTP报文 服务器 服务器是网络环境中的高性能计算机，它侦听网络上的其他计算机（客户机）提交的服务请求，并提供相应的服务，比如网页服务、文件下载服务、邮件服务、视频服务。而客户端主要的功能是浏览网页、看视频、听音乐等等，两者截然不同。 每台服务器上都会安装处理请求的应用——web server。常见的 web server 产品有 apache、nginx、IIS 或 Lighttpd 等。web server 担任管控的角色，对于不同用户发送的请求，会结合配置文件，把不同请求委托给服务器上处理相应请求的程序进行处理（例如 CGI 脚本，JSP 脚本，servlets，ASP 脚本，服务器端 JavaScript，或者一些其它的服务器端技术等），然后返回后台程序处理产生的结果作为响应。 2.MVC 后台处理阶段 后台开发现在有很多框架，但大部分都还是按照 MVC 设计模式进行搭建的。 MVC 是一个设计模式，将应用程序分成三个核心部件：模型（model）– 视图（view）–控制器（controller），它们各自处理自己的任务，实现输入、处理和输出的分离。 3.http 响应报文 响应报文由响应行（request line）、响应头部（header）、响应主体三个部分组成。如下图所示： 响应行包含：协议版本，状态码，状态码描述 状态码规则如下：1xx：指示信息–表示请求已接收，继续处理。2xx：成功–表示请求已被成功接收、理解、接受。3xx：重定向–要完成请求必须进行更进一步的操作。4xx：客户端错误–请求有语法错误或请求无法实现。5xx：服务器端错误–服务器未能实现合法的请求。 响应头部包含响应报文的附加信息，由 名/值 对组成 响应主体包含回车符、换行符和响应返回数据，并不是所有响应报文都有响应数据 浏览器解析渲染页面浏览器拿到响应文本HTML后，接下来介绍下浏览器渲染机制 浏览器解析渲染页面分为以下五个步骤： 根据HTML解析出DOM树 根据CSS解析生成CSS规则树 结合DOM树和CSS规则树，生成渲染树 根据渲染树计算每一个节点的信息 根据计算好的信息绘制页面 根据HTML解析DOM树 根据HTML的内容，将标签按照结构解析成为DOM树，DOM树解析的过程是一个深度优先遍历，即先构建当前节点的所有子节点，再构建下一个兄弟节点。 再读取HTML文档，构建DOM树的过程中，若遇到script标签则DOM树的构建会暂停，直到脚本执行完毕。 根据CSS解析生成CSS规则树 解析CSS规则树时js执行将暂停，直到CSS规则树就绪 浏览器在CSS规则树生成之前不会进行渲染 结合DOM树和CSS规则树，生成渲染树 DOM 树和 CSS 规则树全部准备好了以后，浏览器才会开始构建渲染树。 精简 CSS 并可以加快 CSS 规则树的构建，从而加快页面相应速度。 根据渲染树计算每一个节点的信息（布局） 布局：通过渲染树中渲染对象的信息，计算出每一个渲染对象的位置和尺寸 回流：在布局完成后，发现了某个部分发生了变化影响了布局，那就需要倒回去重新渲染 根据计算好的信息绘制页面 绘制阶段，系统会遍历呈现树，并调用呈现器的“paint”方法，将呈现器的内容显示在屏幕上。 重绘：某个元素的背景颜色，文字颜色等，不影响元素周围或内部布局的属性，将只会引起浏览器的重绘。 回流：某个元素的尺寸发生了变化，则需重新计算渲染树，重新渲染。 断开连接当数据传送完毕，需要断开 tcp 连接，此时发起 tcp 四次挥手 发起方向被动方发送报文，Fin、Ack、Seq，表示已经没有数据传输了。并进入 FIN_WAIT_1 状态。(第一次挥手：由浏览器发起的，发送给服务器，我请求报文发送完了，你准备关闭吧) 被动方发送报文，Ack、Seq，表示同意关闭请求。此时主机发起方进入 FIN_WAIT_2 状态。(第二次挥手：由服务器发起的，告诉浏览器，我请求报文接受完了，我准备关闭了，你也准备吧) 被动方向发起方发送报文段，Fin、Ack、Seq，请求关闭连接。并进入 LAST_ACK 状态。(第三次挥手：由服务器发起，告诉浏览器，我响应报文发送完了，你准备关闭吧) 发起方向被动方发送报文段，Ack、Seq。然后进入等待 TIME_WAIT 状态。被动方收到发起方的报文段以后关闭连接。发起方等待一定时间未收到回复，则正常关闭。(第四次挥手：由浏览器发起，告诉服务器，我响应报文接受完了，我准备关闭了，你也准备吧)]]></content>
  </entry>
  <entry>
    <title><![CDATA[如何居中一个元素]]></title>
    <url>%2F2019%2F08%2F18%2F%E5%A6%82%E4%BD%95%E5%B1%85%E4%B8%AD%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[水平居中行内元素水平居中利用text-align:center可以实现在块级元素内部的行内元素水平居中。此方法对inline、inline-block、inline-table和inline-flex元素水平居中都有效。 123.parent&#123;//在父容器设置 text-align:center; &#125; 此外，如果块级元素内部包着也是一个块级元素，我们可以先将其有块级元素改变为行内块元素，再通过设置行内块元素居中以达到水平居中。 1234567891011&lt;div class="parent"&gt; &lt;div class="child"&gt;Demo&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .parent&#123; text-align:center; &#125; .child &#123; display: inline-block; &#125;&lt;/style&gt; 块级元素的水平居中这种情形可以有多种实现方式，下面我们详细介绍： 将该块级元素左右外边距margin-left和margin-right设置为auto 1234.child&#123; width: 100px;//确保该块级元素定宽 margin:0 auto;&#125; 使用table+margin 先将子元素设置为块级表格来显示（类似），再将其设置水平居中。display:table在表现上类似block元素，但是宽度为内容宽。 123456789&lt;div class="parent"&gt; &lt;div class="child"&gt;Demo&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .child &#123; display: table; margin: 0 auto; &#125;&lt;/style&gt; 使用absolute+transform 先将父元素设置为相对定位，再将子元素设置为绝对定位，向右移动子元素，移动距离为父容器的一半，最后通过向左移动子元素的一半宽度以达到水平居中。 12345678910111213&lt;div class="parent"&gt; &lt;div class="child"&gt;Demo&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .child &#123; position:absolute; left:50%; transform:translateX(-50%); &#125; .parent &#123; position:relative; &#125;&lt;/style&gt; 不过transform属于css3内容，兼容性存在一定问题，高版本浏览器需要添加一些前缀。 使用flex+justify-content 通过CSS3中的布局利器flex中的justify-content属性来达到水平居中。 123456789&lt;div class="parent"&gt; &lt;div class="child"&gt;Demo&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .parent &#123; display: flex; justify-content:center; &#125;&lt;/style&gt; 使用flex-margin 通过flex将父容器设置为flex布局，再设置子元素居中。 1234567891011&lt;div class="parent"&gt; &lt;div class="child"&gt;Demo&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .parent &#123; display: flex; &#125; .child &#123; margin:0 auto; &#125;&lt;/style&gt; 多块级元素水平居中 利用flex布局 利用弹性布局(flex)，实现水平居中，其中justify-content用于设置弹性盒子元素在主轴(默认横轴)方向上的对齐方式，本例中设置子元素水平居中显示。 1234 #container &#123; display: flex; justify-content: center;&#125; 利用inline-block 将要水平排列的块级元素设为display:inline-block，然后在父级元素上设置text-align:center，达到与上面的行内元素的水平居中一样的效果。 123456.container &#123; text-align: center;&#125;.inline-block &#123; display: inline-block;&#125; 浮动元素水平居中 定宽的浮动元素，通过子元素设置relative+负margin 12345678.child &#123; position:relative; left:50%; margin-left:-250px;&#125;&lt;div class="parent"&gt; &lt;span class="child" style="float: left;width: 500px;"&gt;我是要居中的浮动元素&lt;/span&gt;&lt;/div&gt; 不定宽的浮动元素，父子容器都用相对定位 1234567891011121314&lt;div class="box"&gt; &lt;p&gt;我是浮动的&lt;/p&gt; &lt;p&gt;我也是居中的&lt;/p&gt;&lt;/div&gt;.box&#123; float:left; position:relative; left:50%;&#125;p&#123; float:left; position:relative; right:50%;&#125; 通用办法flex布局 利用弹性布局(flex)的justify-content属性，实现水平居中。 1234567891011.parent &#123; display:flex; justify-content:center;&#125;.chlid&#123; float: left; width: 200px;//有无宽度不影响居中&#125;&lt;div class="parent"&gt; &lt;span class="chlid"&gt;我是要居中的浮动元素&lt;/span&gt;&lt;/div&gt; 绝对定位元素水平居中 这种方式非常独特，通过子元素绝对定位，外加margin:0 auto来实现 123456789101112131415&lt;div class="parent"&gt; &lt;div class="child"&gt;让绝对定位的元素水平居中对齐。&lt;/div&gt;&lt;/div&gt; .parent&#123; position:relative; &#125; .child&#123; position: absolute; /*绝对定位*/ width: 200px; height:100px; background: yellow; margin: 0 auto; /*水平居中*/ left: 0; /*此处不能省略，且为0*/ right: 0;/*此处不能省略，且为0*/ &#125; 垂直居中单行内联元素垂直居中12345678910&lt;div id="box"&gt; &lt;span&gt;单行内联元素垂直居中。&lt;/span&gt;。&lt;/div&gt;&lt;style&gt; #box &#123; height: 120px; line-height: 120px; border: 2px dashed #f69c55; &#125;&lt;/style&gt; 多行内联元素垂直居中 利用flex布局 利用flex布局实现垂直居中，其中flex-direction:column定义主轴为纵向。这种方式在较老的浏览器存在兼容性问题。 1234567891011121314&lt;div class="parent"&gt; &lt;p&gt;Dance like nobody is watching, code like everybody is. Dance like nobody is watching, code like everybody is. Dance like nobody is watching, code like everybody is.&lt;/p&gt;&lt;/div&gt;&lt;style&gt; .parent &#123; height: 140px; display: flex; flex-direction: column; justify-content: center; border: 2px dashed #f69c55; &#125;&lt;/style&gt; 块级元素垂直居中 使用absolute+负margin(已知高度宽度) 通过绝对定位元素距离顶部50%，并设置margin-top向上偏移元素高度的一半，就可以实现了。 123456789101112&lt;div class="parent"&gt; &lt;div class="child"&gt;固定高度的块级元素垂直居中。&lt;/div&gt;&lt;/div&gt;.parent &#123; position: relative;&#125;.child &#123; position: absolute; top: 50%; height: 100px; margin-top: -50px;&#125; 使用absolute+tranform 当垂直居中的元素的高度和宽度未知时，可以借助CSS3的transform属性向Y轴反向偏移50%的方法实现垂直居中。但是部分浏览器存在兼容性的问题 1234567891011&lt;div class="parent"&gt; &lt;div class="child"&gt;未知高度的块级元素垂直居中。&lt;/div&gt;&lt;/div&gt;.parent &#123; position: relative;&#125;.child &#123; position: absolute; top: 50%; transform: translateY(-50%);&#125; 使用flex+align-items 通过设置flex布局中的属性align-items，使子元素垂直居中。 1234567&lt;div class="parent"&gt; &lt;div class="child"&gt;未知高度的块级元素垂直居中。&lt;/div&gt;&lt;/div&gt;.parent &#123; display:flex; align-items:center;&#125; 使用table-cell+vertical-align 通过将父元素转化为一个表格单元格显示（类似 和 ），再通过设置 vertical-align属性，使表格单元格内容垂直居中。 123456789&lt;div class="parent"&gt; &lt;div class="child"&gt;Demo&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .parent &#123; display: table-cell; vertical-align: middle; &#125;&lt;/style&gt; 水平垂直居中绝对定位与负边距实现(已知高度宽度) 这种方式需要知道被垂直居中元素的高和宽，才能计算出margin值，兼容所有浏览器 12345678910// css部分 #container &#123; position: relative; &#125; #center &#123; position: absolute; top: 50%; left: 50%; margin: -50px 0 0 -50px; &#125; 123456// html部分(这部分不做变化,下面例子直接共用)&lt;body&gt; &lt;div id='container'&gt; &lt;div id='center' style="width: 100px;height: 100px;background-color: #666"&gt;center&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;绝对定位与matgin：auto(已知高度宽度)这种方式无序知道被垂直居中元素的高和宽，但不能兼容低版本的IE浏览器 ​123456789101112#container &#123; position: relative; height:100px;//必须有个高度 &#125;#center &#123; position: absolute; top: 0; left: 0; right: 0; bottom: 0; margin: auto;//注意此处的写法 &#125; 绝对定位+CSS3(未知元素的高宽)利用CSS3的transform，可以轻松的在未知元素的高度的情况下实现元素的垂直居中。 123456789#container &#123; position: relative; &#125;#center &#123; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); &#125; flex布局利用flex布局，其中justify-content用于设置或检索弹性盒子元素在主轴(横轴)方向上的对齐方式，而align-items属性定义flex子项在容器的当前行的侧轴(纵轴)方向上的对齐方式。不兼容低版本的IE浏览器。 123456#container &#123;//直接在父容器设置即可 height: 100vh;//必须有高度 display: flex; justify-content: center; align-items: center; &#125; flex/grid与margin：auto(最简单写法)容器元素设为flex布局或是grid布局，子元素只要写margin：auto即可，不能兼容低版本的IE浏览器 1234567#container &#123; height: 100vh;//必须有高度 display: grid; &#125; #center &#123; margin: auto; &#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[懒加载和预加载]]></title>
    <url>%2F2019%2F08%2F16%2F%E6%87%92%E5%8A%A0%E8%BD%BD%E5%92%8C%E9%A2%84%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[懒加载什么是懒加载懒加载也叫延迟加载，指的是在长网页中延迟加载图像，是一种很好优化网页性能的方式。 用户滚动到他们之前，可视区域外的图像不会加载。这与图像预加载相反，在长网页上使用延迟加载将使网页加载更快。在某些情况下，它还可以帮助减少服务器负载。常适用图片很多，页面很长的电商网站场景中。 为什么要用懒加载 能提升用户的体验，不妨设想下，用户打开想手机淘宝长页面的时候，如果页面上所有的图片都需要加载，由于图片数目较大，等待时间很长，用户难免会心生抱怨，这就严重影响用户体验。 减少无效资源的加载，这样能明显减少服务器的压力和流量，也能够减少浏览器的负担。 防止并发加载的资源过多会阻塞js的加载，影响网站的正常使用。 懒加载的原理首先将页面上的图片的src属性设为空字符串，而图片的真实路径则设置在data-original属性中，当页面滚动的时候需要去监听scroll事件，在scrool事件的回调中，判断我们的懒加载的图片是否进入可视区域，如果图片在可视区内将图片的src属性设置为data-original的值，这样就可以实现延迟加载。 懒加载实现步骤12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Lazyload&lt;/title&gt; &lt;style&gt; .image-item &#123; display: block; margin-bottom: 50px; height: 200px;//一定记得设置图片高度 &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;img src="" class="image-item" lazyload="true" data-original="images/1.png"/&gt;&lt;img src="" class="image-item" lazyload="true" data-original="images/2.png"/&gt;&lt;img src="" class="image-item" lazyload="true" data-original="images/3.png"/&gt;&lt;img src="" class="image-item" lazyload="true" data-original="images/4.png"/&gt;&lt;img src="" class="image-item" lazyload="true" data-original="images/5.png"/&gt;&lt;img src="" class="image-item" lazyload="true" data-original="images/6.png"/&gt;&lt;img src="" class="image-item" lazyload="true" data-original="images/7.png"/&gt;&lt;img src="" class="image-item" lazyload="true" data-original="images/8.png"/&gt;&lt;img src="" class="image-item" lazyload="true" data-original="images/9.png"/&gt;&lt;img src="" class="image-item" lazyload="true" data-original="images/10.png"/&gt;&lt;img src="" class="image-item" lazyload="true" data-original="images/11.png"/&gt;&lt;img src="" class="image-item" lazyload="true" data-original="images/12.png"/&gt;&lt;script&gt;var viewHeight =document.documentElement.clientHeight//获取可视区高度function lazyload()&#123; var eles=document.querySelectorAll（'img[data-original][lazyload]'）Array.prototype.forEach.call(eles,function(item,index)&#123;var rectif(item.dataset.original==="") returnrect=item.getBoundingClientRect()// 用于获得页面中某个元素的左，上，右和下分别相对浏览器视窗的位置if(rect.bottom&gt;=0 &amp;&amp; rect.top &lt; viewHeight)&#123;!function()&#123; var img=new Image() img.src=item.dataset.original img.onload=function()&#123; item.src=img.src &#125;item.removeAttribute（"data-original"）//移除属性，下次不再遍历item.removeAttribute（"lazyload"） &#125;() &#125; &#125;)&#125;lazyload()//刚开始还没滚动屏幕时，要先触发一次函数，初始化首页的页面图片document.addEventListener（"scroll"，lazyload)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 预加载什么是预加载资源预加载是另一个性能优化技术，我们可以使用该技术来预先告知浏览器某些资源可能会被使用到。预加载简单来说就是将所有所需的资源提取请求到本地，这样后面在需要用时就直接从缓存取资源。 为什么要用预加载在网页全部加载之前，对一些主要内容进行加载，以提供给用户更好的体验，减少等待的时间。否则，如果一个页面的内容过于庞大，没有使用预加载技术的页面就会长时间的展现为一片空白，直到所有内容加载完毕。 实现预加载的几种办法 使用HTML标签 1&lt;img src="http://pic26.nipic.com/20121213/6168183 0044449030002.jpg" style="display:none"/&gt; 使用Image对象 1&lt;script src="./myPreload.js"&gt;&lt;/script&gt; 123//myPreload.js文件var image= new Image()image.src="http://pic26.nipic.com/20121213/6168183 004444903000 2.jpg" 使用XMLHttpReq对象，虽然存在跨域问题，但会精细控制预加载过程 123456789101112131415161718var xmlhttprequest = new XMLHttpRequest()xmlhttprequest.onreadystatechange = callbackxmlhttprequest.onprogress = progressCallbackxmlhttprequest.open("GET", "http://image.baidu.com/mouse,jpg", true)xmlhttprequest.send()function callback() &#123; if(xmlhttprequest.readyState==4&amp;&amp; xmlhttprequest.status==200)&#123; var responseText=xmlhttprequest.responseText &#125;else&#123; console.log("Request was unsuccessful:"+xmlhttprequest.status) &#125;&#125;function progressCallback(e) &#123; e= e || event if(e.lengthComputable) &#123; console.log("Received"+e.loaded+"of"+e.total+"bytes") &#125;&#125; 使用PreloadJS库 PreloadJS提供了一种预加载内容的一致方式，以便在HTML应用程序中使用。预加载可以使用HTML标签以及XHR来完成。默认情况下，PreloadJS会尝试使用XHR加载内容，因为它提供对进度和完成事件的更好支持，但是由于跨域问题，使用基于标记的加载可能更好。 1234567891011//使用preload.jsvar queue=new createjs.LoadQueue();//默认是xhr对象，如果是new createjs.LoadQueue(false)是指使用HTML标签，可以跨域queue.on("complete",handleComplete,this);queue.loadManifest([&#123;id:"myImage",src:"http://pic26.nipic.com/20121213/6168183 0044449030002.jpg"&#125;,&#123;id："myImage2"，src:"http://pic9.nipic.com/20100814/2839526 1931471581702.jpg"&#125;]);function handleComplete()&#123; var image=queue.getResuLt("myImage"); document.body.appendChild(image);&#125; 懒加载和预加载的对比两者都是提高页面性能有效的办法，两者主要区别是一个提前加载，一个是延迟甚至不加载。懒加载对服务器端有一定的缓解压力作用，预加载则会增加服务器前端压力。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Markdown语法]]></title>
    <url>%2F2019%2F07%2F09%2FMarkdown%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[标题在想要设置为标题的文字面前加#来表示，一个#是一级标题，两个#是二级标题以此类推。支持六级标题。 注：标准语法一般在#后跟一个空格再写文。 示例： 123456# 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题###### 这是六级标题 效果如下： 字体斜体要倾斜的文字左右分别用一个*号抱起来 加粗要加粗的文字左右分别用两个*号抱起来 斜体加粗要倾斜和加粗的文字左右分别用三个*号包起来 删除线要加删除线的文字左右分别用两个~号包起来 示例： 1234*这是倾斜的文字***这是加粗的文字*****这是斜体加粗的文字***~~这是加删除线的文字~~ 效果如下： 这是倾斜的文字这是加粗的文字这是斜体加粗的文字这是加删除线的文字 引用在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt; 示例： 123&gt;这是引用的内容&gt;&gt;这是引用的内容&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容 效果如下： 这是引用的内容 这是引用的内容 这是引用的内容 分割线三个或三个以上的-或者*都可以。示例： 1234-------******* 效果如下： 可以看到，显示效果都是一样的。 图片语法： 123![图片alt](图片位置 "图片titlle")图片alt就是显示在图片下面的文字，相当于对图片内容的解释。图片titile是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加 示例： 12![blockchain](https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=702257389,1274025419&amp;fm=27&amp;gp=0.jpg "区块链") 效果如下： ![blockchain](https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=702257389,1274025419&amp;fm=27&amp;gp=0.jpg “区块链”) 超链接语法： 12[超链接](超链接地址 "超链接title")title 可加不可加 示例： 12[简书](http://jianshu.com)[百度](http://baidu.com) 效果如下： 简书百度 列表无序列表语法： 无序列表用-、+、*任何一种都可以。 12345- 列表内容+ 列表内容* 列表内容注意： - + * 跟内容之间都要有一个空格 效果如下： 列表内容 列表内容 列表内容 有序列表语法：数字加点 123451. 列表内容2. 列表内容3. 列表内容注意： 序号跟内容之间要有空格 效果如下： 列表内容 列表内容 列表内容 列表嵌套上一级与下一级之间桥三个空格即可 一级无序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 一级无序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 一级无序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 表格语法： 1234567891011表头|表头|表头---| :--: |---:内容|内容|内容内容|内容|内容第二行分割表头和内容。- 有一个就行，为了对齐，就多加了几个文字默认居左-两边加：表示文字居中-右边加：表示文字居右注意：原生的语法两边都要用 示例： 姓名 技能 排行 刘备 哭 大哥 关羽 打 二哥 张飞 骂 三弟 代码语法：单行代码： 代码之间分别用一个反引号抱起来 1`代码内容` 代码块： 代码之间分别用三个反引号包起来，且两边的反引号单独占一行。 12345(```)代码...代码...代码...(```) 注意： 为了防止转义，前后三个反引号处加了小括号，实际是没有的。 示例： 单行代码 1`create database hero;` 代码块： 123456(```) function fun()&#123; echo "这是一句非常牛逼的代码"; &#125; fun();(```) 效果如下： 单行代码 create database hero; 代码块： 1234function fun()&#123; echo "这是一句非常牛逼的代码";&#125;fun(); 流程图123456789(```)flowst=&gt;start: 开始op=&gt;operation: My Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op&amp;(```) 注意： 为了防止转义，前后三个反引号处加了小括号，实际是没有的。 效果如下： ```st=>start: 开始 op=>operation: My Operation cond=>condition: Yes or No? e=>end st->op->cond cond(yes)->e cond(no)->op &{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12} var code = document.getElementById("flowchart-0-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value)); var diagram = flowchart.parse(code); diagram.drawSVG("flowchart-0", options);]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
  </entry>
</search>
