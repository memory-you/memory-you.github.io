<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[图解作用域链与闭包]]></title>
    <url>%2F2019%2F09%2F01%2F%E5%9B%BE%E8%A7%A3%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E4%B8%8E%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[初学JavaScript的时候，我在学习闭包上，走了很多弯路。而这次重新回过头来对基础知识进行梳理，要讲清楚闭包，也是一个非常大的挑战。 作用域与作用域链作用域 在JavaScript中，我们可以将作用域定义为一套规则，这套规则用来管理引擎如何在当前作用域以及嵌套的子作用域中根据标识符进行变量查询。 JavaScript中只有全局作用域与函数作用域（因为eval我们平时开发中几乎不会用到它，这里不讨论）。 作用域与执行上下文是完全不同的两个概念。 JavaScript代码的整个执行过程，分为两个阶段，代码编译阶段与代码执行阶段。编译阶段有编译器完成，将代码翻译成可执行代码，这个阶段作用域规则会确定。执行阶段由引擎完成，主要任务是执行可执行代码，执行上下文在这个阶段创建。 作用域链 回顾之前我们分析的执行上下文的生命周期，如下图。 我们直到函数在调用激活时，会创建对应的执行上下文，在执行上下文生成的过程中，变量对象、作用域链和this的值会分别被去顶。 作用域链，是由当前环境与上层环境的一系列变量对象组成，它保证了当前执行环境对符合访问权限的变量和函数的有序访问。 为了帮助大家理解作用域链。我们结合一个例子，以及相应的图示来说明。 1234567891011121314var a = 20;function test() &#123; var b = a + 10; function innerTest() &#123; var c = 10; return b + c; &#125; return innerTest();&#125;test(); 在上面的列子中，全局、函数test、函数innerTest的执行上下文先后创建，我们设定它们的变量对象分别为VO(global),VO(test)和VO(innerTest)。而innerTest的作用域链则包含了这三个变量对象，所以innerTest的执行上下文可如下表示。 1234innerTestEC = &#123; VO: &#123;...&#125;, // 变量对象 scopeChain: [VO(innerTest), VO(test), VO(global)], // 作用域链&#125; 我们可以直接用一个数组来表示作用域链，数组的第一项scopeChain[0]为作用域链的最前端，而数组的最后一项，为作用域链的最末端，所有的最末端都为全局变量对象。 哼多人会误解为当前作用域与上层作用域为包含关系，但其实并不是。而是以最前端为起点，最末端为终点的单方向通道。 注意：因为变量对象在执行上下文进入执行阶段时，变成了活动对象，所以用AO表示。 闭包对于那些有一点 JavaScript 使用经验但从未真正理解闭包概念的人来说，理解闭包可以看作是某种意义上的重生，突破闭包的瓶颈可以使你功力大增。 闭包是一种特殊的对象。 它由两部分组成，执行上下文（代号A），以及在该上下文中创建的函数（代号B）。 当B执行时，如果访问了A中变量对象的值，那么闭包就产生了。 在大多数理解中，包括许多书中，文章里都以函数B的名字代指这里产生的闭包。而在chrome中，则以执行上下文A的函数名代指闭包。 因此我们只需要知道，一个闭包对象，由A、B共同组成，在以后的篇幅中，我将以chrome的标准来称呼。 1234567891011121314// demo01function foo() &#123; var a = 20; var b = 30; function bar() &#123; return a + b; &#125; return bar;&#125;var bar = foo();bar(); 上面的例子，首先有执行上下文foo，在foo中定义了函数bar，而通过对外返回bar的方式让bar得以执行。当bar执行时，访问了foo内部的变量a，b。因此这个时候闭包产生。 我们知道，函数的执行上下文，在执行完毕之后也就是生命周期结束，该函数的执行上下文就会失去引用。其占用的内存空间很快就会被垃圾回收器释放。可是闭包的存在，会阻止这一过程。 先来一个简单的例子。 123456789101112131415var fn = null;function foo() &#123; var a = 2; function innnerFoo() &#123; console.log(a); &#125; fn = innnerFoo; // 将 innnerFoo的引用，赋值给全局变量中的fn&#125;function bar() &#123; fn(); // 此处的保留的innerFoo的引用&#125;foo();bar(); // 2 在上面的例子中，foo()执行完毕之后，按照常理、其执行环境生命周期结束，所占内存被垃圾收集器释放，但是通过fn = innerFoo，函数innerFoo的引用被保留了下来，复制给了全局变量fn。这个行为，导致了foo的变量对象，也被保留了下来。于是，函数fn在函数bar内部执行时，依然可以访问这个被保留下来的变量对象。所以此刻仍然能够访问到变量a的值。 这样，我们就可以称为foo为闭包。 下面展示闭包foo的作用域链。 我们可以在chrome浏览器的开发者工具中查看这段代码运行时产生的函数调用栈与作用域链的生成情况。 在上面的图上，红色箭头所指的正是闭包。其中Call Stack为当前的函数调用栈，Scope为当前正在被执行的函数的作用域链，Local为当前的局部变量。 所以通过闭包，我们可以在其他的执行上下文中访问函数的内部变量。比如上面例子中。我们在函数bar的执行环境中访问到了函数foo的变量a。个人认为，从应用层面，这是闭包的重要特性。利用这个特性，我们可以实现很多有意思的东西。 不过读者朋友们需要注意的是，虽然例子中的闭包被保存在了全局变量中，但是闭包的作用域链并不会发生任何改变。在闭包中，能访问到的变量，仍然是作用域链上能够查询到的变量。 对上面的例子稍作修改，如果我们在函数bar中声明一个变量c，并在闭包fn中试图访问该变量，运行结果会抛出错误。 1234567891011121314151617var fn = null;function foo() &#123; var a = 2; function innnerFoo() &#123; console.log(c); // 在这里，试图访问函数bar中的c变量，会抛出错误 console.log(a); &#125; fn = innnerFoo; // 将 innnerFoo的引用，赋值给全局变量中的fn&#125;function bar() &#123; var c = 100; fn(); // 此处的保留的innerFoo的引用&#125;foo();bar(); 闭包的应用场景 除了面试，在实践中，闭包有两个非常重要的应用场景。分别是模块化与柯里化。 柯里化 在函数式编程中，利用闭包能够实现很多炫酷的功能，柯里化便是其中很重要的一种。 模块 在我看来，模块是闭包最强大的一个应用场景。如果你是初学者，对于模块的了解可以暂时不用放在心上，因为理解模块需要更多的基础知识。但是如果你已经有了很多JavaScript的使用经验，在彻底了解了闭包之后，不妨借助本文介绍的作用域链与闭包的思路，重新理一理关于模块的知识。这对于我们理解各种各样的设计模式具有莫大的帮助。 123456789101112131415(function () &#123; var a = 10; var b = 20; function add(num1, num2) &#123; var num1 = !!num1 ? num1 : a; var num2 = !!num2 ? num2 : b; return num1 + num2; &#125; window.add = add;&#125;)();add(10, 20); 在上面的例子中，我使用函数自执行的方式，创建了一个模块。add是模块对外暴露的一个公共方法。而变量a，b被作为私有变量。在面向对象的开发中，我们常常需要考虑是将变量作为私有变量，还是放在构造函数中的this中，因此理解闭包，以及原型链是一个非常重要的事情。模块十分重要，因此我会在以后的文章专门介绍，这里就暂时不多说啦。 为了验证自己有没有搞懂作用域链与闭包，这里留下一个经典的思考题，常常也会在面试中被问到。 利用闭包，修改下面的代码，让循环输出的结果依次为1， 2， 3， 4， 5 12345for (var i=1; i&lt;=5; i++) &#123; setTimeout( function timer() &#123; console.log(i); &#125;, i*1000 );&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[变量对象图解]]></title>
    <url>%2F2019%2F09%2F01%2F%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1%E5%9B%BE%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[在JavaScript中，我们肯定不可避免需要声明变量和函数，可是JS解析器是如何找到这些变量的呢？我们还得对执行上下文有个更进一步的了解。 一个执行上下文的什么周期分为两个阶段： 创建阶段：在这个阶段中，执行上下文会分别创建变量对象，建立作用域链，以及确定this的指向。 代码执行阶段：创建完成之后，就会开始执行代码。这个时候，会完成变量赋值，函数引用，以及执行其他代码。 从这里我们就可以看出详细了解执行上下文几位重要，，因为其中涉及到了变量对象，作用域链，this等很多人没弄明白，但是却极为重要的概念。它关系到我们能不能真正理解JavaScript。 变量对象（Variable Object）变量对象的创建，依次经历了一下几个过程。 建立arguments对象，检查当前上下文的参数，建立该对象下的属性与属性值。 建立当前上下文的函数声明，也就是使用function关键字声明的函数。在变量对象中以函数名建立一个属性，属性值为指向该函数所在内存地址的引用。如果函数名的属性已经存在，那么该属性将会被新的引用所覆盖。 检查当前上下文中的变量声明，每找到一个变量声明，就在变量对象中以变量名建立一个属性，属性值为undefined。如果该变量名的属性已经存在，为了防止同名的函数被修改为undefined，则会直接跳过，原属性不会被修改。 许多读者在阅读到这的时候会因为下面的这样场景对于“跳过”一词产生疑问。既然变量声明的foo遇到函数声明的foo会跳过，可是为什么最后foo的输出结果仍然是被覆盖了？ 1234function foo() &#123; console.log('function foo') &#125;var foo = 20;console.log(foo); // 20 其实只是大家在阅读的时候不够仔细，因为上面的三条规则仅仅适用于变量对象的创建过程。也就是执行上下文的创建过程。而foo = 20是在执行上下文的执行过程中运行的，输出结果自然会是20。对比下例。 1234567891011121314console.log(foo); // function foofunction foo() &#123; console.log('function foo') &#125;var foo = 20;// 上栗的执行顺序为// 首先将所有函数声明放入变量对象中function foo() &#123; console.log('function foo') &#125;// 其次将所有变量声明放入变量对象中，但是因为foo已经存在同名函数，因此此时会跳过undefined的赋值// var foo = undefined;// 然后开始执行阶段代码的执行console.log(foo); // function foofoo = 20; 根据这个规则，理解变量提升就变得十分简单了。在很多文章中虽然提到了变量提升，但是具体是怎么回事还真的很多人都说不出来，以后在面试中用变量对象的创建过程跟面试官解释变量提升，保证瞬间提升逼格。 在上面的规则中，function声明会比var声明优先级更高一点。 123456789101112// demo01function test() &#123; console.log(a); console.log(foo()); var a = 1; function foo() &#123; return 2; &#125;&#125;test(); 在上例中，我们直接从test()的执行上下文开始理解。全局作用域中运行test()时，test()的执行上下文开始创建。为了便于理解，我们用如下形式来表示。 123456789101112131415// 创建过程testEC = &#123; // 变量对象 VO: &#123;&#125;, scopeChain: &#123;&#125;&#125;// 因为本文暂时不详细解释作用域链，所以把变量对象专门提出来说明// VO 为 Variable Object的缩写，即变量对象VO = &#123; arguments: &#123;...&#125;, //注：在浏览器的展示中，函数的参数可能并不是放在arguments对象中，这里为了方便理解，我做了这样的处理 foo: &lt;foo reference&gt; // 表示foo的地址引用 a: undefined&#125; 未进入执行阶段之前，变量对象中的属性都不能访问！但是进入执行阶段之后，变量对象转变为了活动对象，里面的属性都能被访问了，然后开始进行执行阶段的操作。 如果在面试的时候被问到变量对象和活动对象有什么区别，就可以自如应答了。它们其实就是同一个对象，只是处于执行上下文的不同生命周期。不过只有处于函数调用栈栈顶的执行上下文的变量对象，才会变成活动对象。 12345678// 执行阶段VO -&gt; AO // Active ObjectAO = &#123; arguments: &#123;...&#125;, foo: &lt;foo reference&gt;, a: 1, this: Window&#125; 因此，上面的例子demo1，执行顺序就变成了这样 1234567891011function test() &#123; function foo() &#123; return 2; &#125; var a; console.log(a); console.log(foo()); a = 1;&#125;test(); 再来一个例子，巩固一下我们的理解。 1234567891011121314151617181920212223242526272829303132// demo2function test() &#123; console.log(foo); console.log(bar); var foo = 'Hello'; console.log(foo); var bar = function () &#123; return 'world'; &#125; function foo() &#123; return 'hello'; &#125;&#125;test();// 创建阶段VO = &#123; arguments: &#123;...&#125;, foo: &lt;foo reference&gt;, bar: undefined&#125;// 这里有一个需要注意的地方，因为var声明的变量当遇到同名的属性时，会跳过而不会覆盖// 执行阶段VO -&gt; AOVO = &#123; arguments: &#123;...&#125;, foo: 'Hello', bar: &lt;bar reference&gt;, this: Window&#125; 需要结合上面的知识，仔细对比这个例子中变量对象从创建阶段到执行阶段的变化，如果你已经理解了，说明变量对象相关的东西都已经难不倒你了。 全局上下文的变量对象以浏览器为例，全局对象为window。 全局上下文有个特殊的地方，它的变量对象，就是window对象。而这个特殊，在this指向上也同样适用，this也是指向window。 1234567// 以浏览器中为例，全局对象为window// 全局上下文windowEC = &#123; VO: Window, scopeChain: &#123;&#125;, this: Window&#125; 除此之外，全局上下文的生命周期，与程序额生命周期一致，只要程序运行不结束。比如关闭浏览器窗口，全局上下文就会一直存在，其它所有的上下文环境，都能直接访问全局上下文的属性。]]></content>
  </entry>
  <entry>
    <title><![CDATA[执行上下文图解]]></title>
    <url>%2F2019%2F09%2F01%2F%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%9B%BE%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[在JavaScript学习初期或者面试的时候常常会遇到考核变量提升的思考题。先来一个简单的。 12console.log(a); // 这里会打印出什么？var a = 20; 暂时先不管这个例子，我们先引入一个JavaScript中最基础，但同时也是最重要的一个概念：执行上下文（Execution Context）。 每当控制器转到可执行代码的时候，会进入一个执行上下文。执行上下文可以被理解为当前代码的环境，他会形成一个作用域。JavaScript中的运行环境大概包括三种情况。 全局环境：JavaScript代码运行起来会首先进入该环境； 函数环境：当函数被调用执行时，会进入当前函数中执行代码； eval(不建议使用)； 因此一个JavaScript程序，在它的执行过程中会产生多个执行上下文，JavaScript引擎会以栈的方式来处理它们，这个栈我们称其为函数调用栈（call stack）。栈底永远都是全局上下文，而栈顶就是当前正在执行的上下文。 当代码在执行过程中，遇到以上三个情况，都会生成一个执行上下文，放入栈中，而处于栈顶的上下文执行完毕后，会自动出栈。为了更加清晰的理解这个过程，根据下面的例子，结合图示给大家展示。 执行上下文可以被理解为函数执行的环境，每一个函数执行时，都会给对应的函数创建这样一个执行环境。 123456789101112131415var color = 'blue';function changeColor() &#123; var anotherColor = 'red'; function swapColors() &#123; var tempColor = anotherColor; anotherColor = color; color = tempColor; &#125; swapColors();&#125;changeColor(); 我们可以用ECStack来表示处理执行上下文组的栈。第一步，首先是全局上下文入栈。 全局上下文入栈之后，其中的可执行代码开始执行，直到遇到changeColor()，这一句激活函数changeColor()创建它自己的执行上下文，因此第二部就是changeColor()的执行上下文入栈。 changeColor()的上下文入栈之后，控制器开始执行其中的可执行代码，遇到swapColors()之后又激活了一个执行上下文。因此第三步是swapColors()的执行上下文入栈。 在swapColors()的可执行代码中，再没有遇到其他能生成执行上下文的情况，因此这段代码顺利执行完毕，swapColors()的上下文从栈中弹出。 swapColors的执行上下文弹出之后，继续执行changeColor的可执行代码，也没有再遇到其他执行上下文，顺利执行完毕之后弹出。这样，ECStack中就只身下全局上下文了。 全局上下文在浏览器窗口关闭后出栈。 注意：函数中，遇到return能直接终止可执行代码的执行，因此会直接将当前上下文弹出栈。 详细了解了这个过程，我们就可以对执行上下文总结一些结论了。 单线程 同步执行，只有栈顶的上下文处于执行中，其它上下文需要等待； 全局上下文只有唯一的一个，它在浏览器关闭时出栈。 函数的执行上下文没有限制； 每次某个函数被调用，就会有个新的执行上下文为其创建，即使是调用的自身函数，也是如此； 为了巩固一下执行上下文的理解，我们再来绘制一个例子的演变过程，这是一个简单的闭包问题。 123456789function f1()&#123; var n=999; function f2()&#123; alert(n); &#125; return f2;&#125;var result=f1();result(); // 999 因为f1中的函数f2在f1的可执行代码中，并没有被调用执行，因此执行f1时，f2不会创建新的上下文，而直到result执行时，才创建了一个新的。具体演变过程如下。]]></content>
  </entry>
  <entry>
    <title><![CDATA[内存空间详细图解]]></title>
    <url>%2F2019%2F08%2F31%2F%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E8%AF%A6%E7%BB%86%E5%9B%BE%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[因为JavaScript具有自动垃圾回收机制，所以对前端开发来说，内存空间并不是一个经常被提及的概念。但想要对JS理解更加深刻，就必须对内存空间有一个清晰的认知。 在学习内存空间之前，我们需要对这三种数据结构有个直观的认知，堆（heap）、栈（stack）和队列（queue）。 栈（Stack）与C/C++不同，JavaScript中没有严格意义上区分栈内存与堆内存。因此我们可以简单粗暴的理解为JavaScript的所有数据都保持在堆内存中。但是在某些场景，我们依然需要基于堆栈数据结构的思维来实现一些功能，比如JavaScript的执行上下文。执行上下文的执行顺序借用了栈的存取方式，因此了解栈数据结构的原理与特点是十分重要。 我们可以通过类比乒乓球盒子来分析栈的存取方式，如下图： 这种乒乓球的存放方式与栈中存取数据的方式如出一辙。处于盒子中最顶层的乒乓球5，它一定是最后被放进去的，但是最先被使用的。而我们想要使用底层的乒乓球1，就必须将上面的4个乒乓球取出来，让乒乓球1处于盒子顶层。这就是栈空间先进后出，后进先出的特点。 堆（heap）堆是一种树状结构，它的存取数据的方式与书架取书是十分相似的。 书虽然也整齐的存放在书架上，但是我们只要知道书的名字，我们就可以很方便的取出我们想要的书，而不用像从乒乓球盒子里取乒乓一样，非得将上面的所有乒乓球拿出来才能取到中间的某一个乒乓球。好比在JSON格式的数据中，我们存储的key-value是可以无序的，因为顺序的不同并不影响我们的使用，我们只需要关心书的名字。 队列（queue）在JavaScript中理解队列的目的主要是为了清晰的明白事件循环（Event Loop）的机制。 队列是一种先进先出（FIFO）的数据结构。正如排队过安检一样，排在队伍前面的人一定是最先过安检的。用下面的图示可以清晰显示队列的存取过程。 变量对象与基础数据类型JavaScript的执行上下文生成之后，会创建一个叫做变量对象的特殊对象，JavaScript的基础数据类型往往都会保存在变量对象中。 严格意义上说，变量对象也是存放于堆内存中，但是由于变量对象的特殊职能，我们在理解时仍需要将其与对内存区分开来。 基础数据类型都是一些简单的数据段，JavaScript中有6中基础数据类型，分别是ndefined、Null、Boolean、Number、String、Symbol。基础数据类型都是按值访问，因为我们可以直接操作保存在变量中的实际值。 引用数据类型与堆内存与其他语言不同，JavaScript的引用类型比如数组Array，它们的值的大小时不固定的。引用数据类型的值时保存至堆内存中的对象。JavaScript不允许直接访问堆内存中的位置。因此我们不能直接操作对象的堆内存空间。在操作对象时，实际上时在操作对象的引用而不是实际的对象。因此，引用类型的值都是按引用访问的。这里的引用，我们可以理解为保存在变量对象中的一个地址，该地址与堆内存的实际值相关联。 为了更好的搞懂变量对象与堆内存，我们可以结合以下例子与图解进行理解。 123456var a1 = 0; // 变量对象var a2 = 'this is string'; // 变量对象var a3 = null; // 变量对象var b = &#123; m: 20 &#125;; // 变量b存在于变量对象中，&#123;m: 20&#125; 作为对象存在于堆内存中var c = [1, 2, 3]; // 变量c存在于变量对象中，[1, 2, 3] 作为对象存在于堆内存中 因此当我们要访问堆内存中的引用数据类型时，实际上我们首先时从变量对象中获取该对象的地址引用，再从堆内存中取得我们需要的数据。 理解了JavaScript的内存空间，我们就可以借助内存空间的特性来验证一下引用类型的一些特点。 在前端面试中我们常常会遇到这样一个类似的题目 123456// demo01.jsvar a = 20;var b = a;b = 30;// 这时a的值是多少？ 123456// demo02.jsvar m = &#123; a: 10, b: 20 &#125;var n = m;n.a = 15;// 这时m.a的值是多少 在变量对象中的数据发生复制行为时，系统会自动为新的变量分配一个新值。var b = a执行之后，a与b虽然值都等于20，但是他们其实已经是相互独立互不影响的值了。具体如图。所以我们修改了b的值以后，a的值并不会发生变化。 在demo02中，我们通过var n = m执行一次复制引用类型的操作。引用类型的复制同样也会为新的变量自动分配一个新的值保存在变量对象中，但不同的是，这个新的值，仅仅只是引用类型的一个地址指针。当地址指针相同时，尽管他们相互独立，但是在变量对象中访问到的具体对象实际上是同一个。如图所示。 因此当我改变n时，m也发生了变化。这就是引用类型的特性. 通过内存的角度来理解，是不是感觉要轻松很多？除此之外，我们还可以以此为基础，一步一步的理解JavaScript的执行上下文，作用域链，闭包，原型链等重要概念。 内存空间管理因为JavaScript具有自动垃圾收集机制，所以我们在开发时不需要关心内存的使用问题，内存的分配与回收都完全实现了自动管理。 JavaScript的内存生命周期 1231. 分配你所需要的内存2. 使用分配到的内存（读、写）3. 不需要时将其释放、归还 为了便于理解，我们使用一个简单的例子来解释这个周期。 123var a = 20; // 在内存中给数值变量分配空间alert(a + 100); // 使用内存a = null; // 使用完毕之后，释放内存空间 第一步和第二步我们都很好理解，JavaScript在定义变量时就完成了内存分配。第三步释放内存空间则是我们需要重点理解的一个点。 JavaScript有自动垃圾收集机制，那么这个自动垃圾收集机制的原理是什么呢？其实很简单，就是找出那些不再继续使用的值，然后释放其占用的内存。垃圾收集器会每隔固定的时间段就执行一次释放操作。 在JavaScript中，最常用的是通过标记清除的算法来找到哪些对象是不再继续使用的，因此a = null其实仅仅只是做了一个释放引用的操作，让 a 原本对应的值失去引用，脱离执行环境，这个值会在下一次垃圾收集器执行操作时被找到并释放。而在适当的时候解除引用，是为页面获得更好性能的一个重要方式。 在局部作用域中，当函数执行完毕，局部变量也就没有存在的必要了，因此垃圾收集器很快做出判断回收。但全局变量什么时候需要自动释放内存空间就很难判断，因此在我们的开发中，需要尽量避免使用全局变量。]]></content>
  </entry>
  <entry>
    <title><![CDATA[手写实现call()、apply()、bind()]]></title>
    <url>%2F2019%2F08%2F31%2F%E6%89%8B%E5%86%99%E5%AE%9E%E7%8E%B0call()%E3%80%81apply()%E3%80%81bind()%2F</url>
    <content type="text"><![CDATA[apply()和call()这两个方法的用途都是在特定的作用域中调用函数，实际上等于设置函数体内this对象的值。bind()方法会创建一个函数的实例，其this值会被绑定到传来的参数。总的来说是用来改变函数运行时this的指向。 call() 用法 call方法将需要参数按顺序传递。 12345678function sum(num1, num2)&#123; return num1 + num2;&#125;function callSum(num1, num2)&#123; return sum.call(this, num1, num2);&#125;alert(callSum(10,10)); //20 实现原理 1234567891011Function.prototype.call2 = function (context) &#123; context = context || window context.fn = this var args = []; for(var i = 1, len = arguments.length; i &lt; len; i++) &#123; args.push('arguments[' + i + ']'); &#125; var result = eval('context.fn(' + args +')'); delete context.fn return result; &#125; apply() 用法 apply()方法接收两个参数：一个是在其中运行函数的作用域，另一个是参数数组，可以是Array的实例，也可以是arguments对象。 1234567891011121314function sum(num1, num2)&#123; return num1 + num2;&#125;function callSum1(num1, num2)&#123; return sum.apply(this, arguments);&#125;function callSum2(num1, num2)&#123; return sum.apply(this, [num1, num2]);&#125;alert(callSum1(10,10)); //20alert(callSum2(10,10)); //20 其中this是你想指定的上下文，它可以是任何一个JavaScript对象（JavaScript中一切皆对象）。apply()和call()的用法，接收参数的方式不一样，使用call()和apply()来扩充作用域的最大好处，就是对象不需要与方法有任何耦合关系，如果你传的 context 就 null 或者 undefined，那么 window 对象就是默认的 context（严格模式下默认 context 是 undefined)。 实现原理 12345678910111213141516171819Function.prototype.apply = function (context, arr) &#123; context = Object(context) || window; context.fn = this; var result; if (!arr) &#123; result = context.fn(); &#125; else &#123; var args = []; for (var i = 0, len = arr.length; i &lt; len; i++) &#123; args.push('arr[' + i + ']'); &#125; result = eval('context.fn(' + args + ')') &#125; delete context.fn return result; &#125; bind() 用法 bind()用法：第一个参数是this的指向，从第二个参数开始接收的参数列表 12345678910111213window.color = "red";var o = &#123; color: "blue" &#125;;function sayColor()&#123; alert(this.color);&#125;var objectSayColor = sayColor.bind(o);objectSayColor(); //blue 实现原理 1234567891011121314151617181920212223Function.prototype.bind = function (oThis) &#123; if (typeof this !== "function") &#123; throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable"); &#125; var aArgs = Array.prototype.slice.call(arguments, 1), fToBind = this, fNOP = function () &#123;&#125;, fBound = function () &#123; // 当作为构造函数时，this 指向实例，此时结果为 true，将绑定函数的 this 指向该实例，可以让实例获得来自绑定函数的值 // 以上面的是 demo 为例，如果改成 `this instanceof fBound ? null : context`，实例只是一个空对象，将 null 改成 this ，实例会具有 habit 属性 // 当作为普通函数时，this 指向 window，此时结果为 false，将绑定函数的 this 指向 context return fToBind.apply( this instanceof fNOP &amp;&amp; oThis ? this : oThis || window, aArgs.concat(Array.prototype.slice.call(arguments)) ); &#125;; fNOP.prototype = this.prototype; fBound.prototype = new fNOP(); return fBound;&#125;; 总结call、apply和bind函数存在的区别： bind()不会立即执行，而是返回一个改变了上下文this的函数，便于稍后调用； apply，call则是立即调用； call比apply的性能要好，平常可以多用call。call传入参数的格式正式内部所需要的格式； 需要注意的一点的是： 在ES6的箭头函数下，call和apply将失效，对于箭头函数来说，函数内部的this对象，就是定义时所在的对象； 箭头函数不可以当作构造函数，也就是说不可以使用new关键字，否则会抛出一个错误。 箭头函数不可以使用arguments对象，该对象在函数中不存在；]]></content>
  </entry>
  <entry>
    <title><![CDATA[JavaScript之工厂模式]]></title>
    <url>%2F2019%2F08%2F31%2FJavaScript%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[工厂模式类似现实生活种的工厂可以产生大量相似的商品，去做同样的事情，实现相同的效果； 简单的工厂模型可以理解为解决多个相似的问题，这也是它的优点。相关代码如下： 1234567891011121314151617181920212223242526function CreatePerson(name,age,sex) &#123; var obj = new Object(); obj.name = name; obj.age = age; obj.sex = sex; obj.sayName = function()&#123; return this.name; &#125; return obj;&#125;var p1 = CreatePerson("longen",'28','男');var p2 = CreatePerson("tugenhua",'27','女');console.log(p1.name); // longenconsole.log(p1.age); // 28console.log(p1.sex); // 男console.log(p1.sayName()); // longenconsole.log(p2.name); // tugenhuaconsole.log(p2.age); // 27console.log(p2.sex); // 女console.log(p2.sayName()); // tugenhua// 返回都是object 无法识别对象的类型 不知道他们是哪个对象的实列console.log(typeof p1); // objectconsole.log(typeof p2); // objectconsole.log(p1 instanceof Object); // true 函数CreatePerson接收三个参数name、age和sex，在无数次的调用下，这个函数都会返回包含这三个属性和一个sayName方法的对象。 工厂模式是为了解决多个类似对象声明的问题，也是为了解决实例化对象产生重复的问题。 优点：能解决多个相似的问题。 缺点：无法识别对象的类型。 复杂的工厂模式：将其成员对象的实例化推迟到子类中，子类可以重写父类接口方法以便创建的时候指定自己的对象类型。 父类只对创建过程中的一般性问题进行处理，这些处理会被子类继承，子类之间是相互独立的，具体的业务逻辑会放在子类中进行编写。 父类就变成了一个抽象类，但是符类可以执行子类中相同类似的方法，具体的业务逻辑需要放在子类中去实现。比如我现在开了几个自行车店，那么每个店都有几种型号的自行车出售。我们现在来使用工厂模式来编写这些代码。 父类的构造函数： 12345678910111213141516171819202122// 定义自行车的构造函数var BicycleShop = function()&#123;&#125;;BicycleShop.prototype = &#123; constructor: BicycleShop, /* * 买自行车这个方法 * @param &#123;model&#125; 自行车型号 */ sellBicycle: function(model)&#123; var bicycle = this.createBicycle(mode); // 执行A业务逻辑 bicycle.A(); // 执行B业务逻辑 bicycle.B(); return bicycle; &#125;, createBicycle: function(model)&#123; throw new Error(&quot;父类是抽象类不能直接调用，需要子类重写该方法&quot;); &#125;&#125;; 上面是定义一个自行车抽象类来编写工厂模式的实列，定义了createBicycle这个方法，但是如果直接实例化父类，调用父类中的这个createBicycle 方法,会抛出一个error，因为父类是一个抽象类，他不能被实列化，只能通过子类来实现这个方法，实现自己的业务逻辑，下面我们来定义子类，我们学会如何使用工厂模式重新编写这个方法，首先我们需要继承父类中的成员，然后编写子类 ;如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// 定义自行车的构造函数var BicycleShop = function(name)&#123; this.name = name; this.method = function()&#123; return this.name; &#125;&#125;;BicycleShop.prototype = &#123; constructor: BicycleShop, /* * 买自行车这个方法 * @param &#123;model&#125; 自行车型号 */ sellBicycle: function(model)&#123; var bicycle = this.createBicycle(model); // 执行A业务逻辑 bicycle.A(); // 执行B业务逻辑 bicycle.B(); return bicycle; &#125;, createBicycle: function(model)&#123; throw new Error("父类是抽象类不能直接调用，需要子类重写该方法"); &#125; &#125;; // 实现原型继承 function extend(Sub,Sup) &#123; //Sub表示子类，Sup表示超类 // 首先定义一个空函数 var F = function()&#123;&#125;; // 设置空函数的原型为超类的原型 F.prototype = Sup.prototype; // 实例化空函数，并把超类原型引用传递给子类 Sub.prototype = new F(); // 重置子类原型的构造器为子类自身 Sub.prototype.constructor = Sub; // 在子类中保存超类的原型,避免子类与超类耦合 Sub.sup = Sup.prototype; if(Sup.prototype.constructor === Object.prototype.constructor) &#123; // 检测超类原型的构造器是否为原型自身 Sup.prototype.constructor = Sup; &#125; &#125; var BicycleChild = function(name)&#123; this.name = name;// 继承构造函数父类中的属性和方法 BicycleShop.call(this,name); &#125;; // 子类继承父类原型方法 extend(BicycleChild,BicycleShop);// BicycleChild 子类重写父类的方法BicycleChild.prototype.createBicycle = function()&#123; var A = function()&#123; console.log("执行A业务操作"); &#125;; var B = function()&#123; console.log("执行B业务操作"); &#125;; return &#123; A: A, B: B &#125;&#125;var childClass = new BicycleChild("龙恩");console.log(childClass); 实例化子类，然后打印出该实例： 上面只是”龙恩”自行车这么一个型号的，如果需要生成其他型号的自行车的话，可以编写其他子类，工厂模式最重要的优点是：可以实现一些相同的方法，这些相同的方法我们可以放在父类中编写代码，那么需要实现具体的业务逻辑，那么可以放在子类中重写该父类的方法，去实现自己的业务逻辑；使用专业术语来讲的话有 2点：第一：弱化对象间的耦合，防止代码的重复。在一个方法中进行类的实例化，可以消除重复性的代码。第二：重复性的代码可以放在父类去编写，子类继承于父类的所有成员属性和方法，子类只专注于实现自己的业务逻辑。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Base64的原理与实现]]></title>
    <url>%2F2019%2F08%2F30%2FBase64%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[我们知道在计算机中一个字节有256种组合，对应的就是ASCII码。而ASCII码的128~255之间的值属于不可见字符。有些网络传送渠道并不支持所有的字节，例如传统的邮件只支持可见字符的传送，而ASCII码的控制字符就不能通过邮件传送。图片二进制流的每一个字节也都不可能都是可见字符，因此它们也不能传送。对此最好的办法就是在不改变传统协议的情况下，做一种拓展方案来支持二进制文件的传送，将不可见的字符用可见字符来表示。Base64编码应运而生。 Base64编码原理Base64编码是基于64个可见字符“A-Z、a-z、0-9、+、/”的编码方式，因为Base64的码表只有64个字符，想要完全表达这些字符，只需要6bit即可（2的6次方为64）。 Base64编码本质上是一种将二进制数据转成文本数据的方案。对于非二进制数据，是先将其转换成二进制形式，，然后每连续6bit计算其十进制值，根据该值在码表上找到对应的字符，最后得到一个文本字符串。基本规则如下： 标准Base64只有64个可见字符（A-Z、a-z、0-9、+、/）以及用作后缀等号； Base64是将3个字节变成4个可见字符； 严格来说Base64不能算是一种加密，只能说是编码转换。 Base64应用 实现简单的数据加密，使用户一眼望去看不出真实数据内容，Base64算法的复杂程度较低，而效率就较高些。 Base64编码的主要的作用不在于安全性，而是让内容能在各个网关间无错的传输，这才是Base64编码的核心作用。]]></content>
  </entry>
  <entry>
    <title><![CDATA[HTTP常见的状态码]]></title>
    <url>%2F2019%2F08%2F30%2FHTTP%E5%B8%B8%E8%A7%81%E7%9A%84%E7%8A%B6%E6%80%81%E7%A0%81%2F</url>
    <content type="text"><![CDATA[状态码的职责是当客户端向服务器发送请求时，描述返回的请求结果。借助状态码，用户可以知道服务端时正常处理了请求还是出现了错误。 状态码的类别： 123 类别 原因短语 1XX Informational (信息性状态码) 接受的请求正在处理 2XX Success (成功状态码) 请求正常处理完毕 3XX Redirection (重定向状态码) 需要进行附加操作以完成请求 4XX Client Error (客户端错误状态码) 客户端请求出错 5XX Server Error (服务器错误状态码) 服务器处理请求出错 1XX——表明请求正在被处理 100 Continue：客户端应继续其请求。 101 Switching Protocols：服务器根据客户端请求切换协议。 2XX——表明请求被正常处理了 200 OK：请求已正常处理。 201 Created：成功请求并创建了新的资源。 202 Accepted：已经接收请求，但未处理完成。 203 Non-Authoritative Information：请求成功，但返回的meta信息不在原始的服务器，而是一个副本。 204 No Content：请求处理成功，但没有任何资源可以返回给客户端。 205 Reset Content：服务器处理成功，用户终端应重置文档视图。 206 Partial Content：服务器成功处理了部分GET请求。 3XX——表明要完成请求，需要进一步操作 300 Multiple Choices ：针对请求，服务器可执行多种操作。服务器可根据请求者选择一项操作。或提供操作列表供请求者选择。 301 Moved Permanently：请求的资源已被永远的移动到新URL，返回信息会包括新的URI，浏览器会自动定向到新URI。 302 Found：与301类似，但是资源只是临时被移动，客户端应继续使用原URI。 303 See Other：查看其他地址。 304 Not Modified：所请求的资源未修改，服务器返回此状态码，不会返回任何资源。 305 Use Proxy：所请求的资源必须通过代理访问。 307 Temporary Redirect：临时重定向，与302类似，使用FET请求重定向。 4XX——表明请求出错 400 Bad Request：客户端请求的语法错误，服务器无法理解。 401 Unauthorized：请求要求用户的身份认证。 403 Forbidden：服务器理解请求客户端的请求，但是拒绝执行此请求。 404 Not Found：服务器无法根据客户端的请求找到资源。 405 Method Not Allowed：客户端请求中的方法被禁止。 406 Not Acceptable：服务器无法根据客户端请求的内容特性完成请求。 407 Proxy Authentication Required：请求要求代理的身份认证，与401类似。但请求者应当使用代理进行授权。 408 Request Time-out：服务器等待客户端发送的请求时间过长，超时。 409 Conflict：服务器完成客户端的PUT请求时可能返回此代码，服务器处理请求时发送了冲突。 410 Cone：客户端请求的资源已经不存在。 411 Length Required：服务器无法处理客户端发送的不带Content-Length的请求信息。 412 Precondition Failed：客户端请求信息的先决条件错误。 413 Request Entity Too Large：由于请求的实体过大，服务器无法处理，因此拒绝请求。 414 Request-URI Too Large：请求的URI过长，服务器无法处理。 415 Unsupported Media Type：服务器无法处理请求附带的媒体格式。 416 Requested range not satisfiable：客户端请求的范围无效。 417 Expectation Failed：服务器无法满足Expect的请求头信息。 5XX——表明服务器处理请求错误 500 Internal Server Error：服务器内部错误，无法完成请求。 501 Not Implemented：服务器不支持请求的功能，无法完成请求。 502 Bad Gateway：作为网关或者代理工作的服务器尝试执行请求时，从远处服务器接收到了一个无效的响应。 503 Service Unavailable：由于超载或系统维护，服务器暂时的无法处理客户端的请求。 504 Gateway Time-out：充当网关或者代理的服务器未及时从远端服务器获取请求。 505 HTTP Version not supported：服务器不支持请求的HTTP协议的版本，无法完成处理。]]></content>
  </entry>
  <entry>
    <title><![CDATA[常见六大Web安全按攻防解析]]></title>
    <url>%2F2019%2F08%2F29%2F%E5%B8%B8%E8%A7%81%E5%85%AD%E5%A4%A7Web%E5%AE%89%E5%85%A8%E6%8C%89%E6%94%BB%E9%98%B2%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[在互联网时代，数据安全与个人隐私受到了前所未有的挑战，各种新奇的攻击技术层出不穷。如何才能更好地保护我们的数据？ XSSXSS（Cross-Site Scripting），跨站脚本攻击，因为缩写和CSS重叠，所有只能叫XSS。跨站脚本攻击时指通过存在安全漏洞的Web网站注册用户的浏览器内运行非法的HTML标签或JavaScript进行的一种攻击。 跨站脚本攻击有可能造成以下影响： 利用脚本输入表单骗取用户个人信息； 利用脚本窃取用户的Cookie值，被害者在不知情的情况下，帮助攻击者发送恶意请求； 显示伪造的文章或图片； XSS的原理是恶意攻击者往Web页面里插入恶意可执行网页脚本代码，当用户浏览该页之时，嵌入其中Web里面的脚本代码会被执行，从而可以达到攻击者盗取用户信息或其他侵犯用户安全隐私的目的。 XSS的攻击方式千变万化，但还是可以大致细分为几种类型。 非持久型XSS（反射型XSS） 非持久型XSS漏洞，一般是通过给别人发送带有恶意脚本代码参数的URL，当URL地址被打开时，特有的恶意代码参数被HTML解析、执行。 举个例子，比如页面中包含以下代码： 12345678910&lt;select&gt; &lt;script&gt; document.write('' + '&lt;option value=1&gt;' + location.href.substring(location.href.indexOf('default=') + 8) + '&lt;/option&gt;' ); document.write('&lt;option value=2&gt;English&lt;/option&gt;'); &lt;/script&gt;&lt;/select&gt; 攻击者可以直接通过 URL (类似：https://xxx.com/xxx?default=&lt;script&gt;alert(document.cookie)&lt;/script&gt;) 注入可执行的脚本代码。不过一些浏览器如Chrome其内置了一些XSS过滤器，可以防止大部分反射型XSS攻击。 非持久型 XSS 漏洞攻击有以下几点特征： 即时性，不经过服务器存储，直接通过HTTP的GET和POST请求就能完成一次攻击，拿到用户隐私数据； 攻击者需要诱骗点击，必须要通过用户点击链接才能发起； 反馈率低，所以较难发现和响应修复； 盗取用户敏感保密信息； 为了防止出现非持久型XSS漏洞，需要确保这么几件事情： Web页面渲染的所以内容或者渲染的数据都必须来自服务端； 尽量不要从URL、document.referrer、document.forms 等这种 DOM API 中获取数据直接渲染； 尽量不要使用 eval, new Function()，document.write()，document.writeln()，window.setInterval()，window.setTimeout()，innerHTML，document.createElement() 等可执行字符串的方法。 如果做不到以上几点，也必须对涉及 DOM 渲染的方法传入的字符串参数做 escape 转义。 前端渲染的时候对任何的字段都需要做 escape 转义编码。 持久型XSS（存储型XSS） 持久型 XSS 漏洞，一般存在于 Form 表单提交等交互功能，如文章留言，提交文本信息等，黑客利用的 XSS 漏洞，将内容经正常功能提交进入数据库持久保存，当前端页面获得后端从数据库中读出的注入代码时，恰好将其渲染执行。 举个例子，对于评论功能来说，就得防范持久型XSS攻击，因为我可以在评论中输入以下内容。 主要注入页面方式和非持久型XSS漏洞类似，只不过持久型的不是来源于URL、referrer、forms等，而是来源于后端从数据库中读取来的数据。持久型XSS攻击不需要诱骗点击，黑客只需要在提交表单的地方完成注入即可，但是这种XSS攻击的成本相对还是很高。 攻击成功需要同时满足以下几个条件： POST请求提交表单后端没有做转义直接入库； 后端从数据库中取出数据没有做转义直接输出给前端； 前端拿到后端数据没做转义直接渲染成DOM； 持久型XSS有以下几个特点： 持久型，植入在数据库中； 盗取用户敏感私密信息； 危害面广； 如何防御 对于XSS攻击来说，通常有两者方式可以用来防御。 （1）CSP CSP本质上就是建立白名单，开发者明确告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截时由浏览器自己实现的。我们可以通过这种方式来尽量减少XSS攻击。 通常可以通过两种方式来开启CSP： 设置HTTP Header中的Content-Security-Policy； 设置meta标签的方式； 这里以设置HTTP Header来举例： 只允许加载本站资源 1Content-Security-Policy: default-src 'self' 只允许加载HTTPS协议图片 1Content-Security-Policy: img-src https://* 允许加载任何来源框架 1Content-Security-Policy: child-src 'none' 如需了解更多属性，请参考Content-Security-Policy文档 对于这种方式来说，只能开发者配置了正确的规则，那么即使网站存在漏洞，攻击者也不能执行它的攻击代码，并且CSP的兼容性也不错。 （2）转义字符 用户的输入永远不可信任的，最普遍的做法就是转义输入输出的内容，对于引号、尖括号、斜杠进行转义。 12345678910function escape(str) &#123; str = str.replace(/&amp;/g, '&amp;amp;') str = str.replace(/&lt;/g, '&amp;lt;') str = str.replace(/&gt;/g, '&amp;gt;') str = str.replace(/"/g, '&amp;quto;') str = str.replace(/'/g, '&amp;#39;') str = str.replace(/`/g, '&amp;#96;') str = str.replace(/\//g, '&amp;#x2F;') return str&#125; 但是对于显示富文本来说，显然不通过上面的办法来转义所以字符，因为这样会把需要的格式也过滤掉。对于这种情况，通常采用白名单过滤的办法，当然也可以通过黑名单过滤，但是考虑到需要过滤的标签和标签属性实在太多，更加推荐使用白名单的方式。 1234const xss = require('xss')let html = xss('&lt;h1 id="title"&gt;XSS Demo&lt;/h1&gt;&lt;script&gt;alert("xss");&lt;/script&gt;')// -&gt; &lt;h1&gt;XSS Demo&lt;/h1&gt;&amp;lt;script&amp;gt;alert("xss");&amp;lt;/script&amp;gt;console.log(html) （3）HttpOnly Cookie 这是预防XSS攻击窃取用户Cookie最有效的防御手段。Web应用程序在设置Cookie时，将其属性设为HttpOnly，就可以避免该网页的Cookie被客户端被恶意JavaScript窃取，保护用户Cookie信息。 CSRFCSRF（Cross Site Request Forgery），即跨站请求伪造，是一种常见的Web攻击，它利用用户已登录的身份，在用户毫不知情的情况下，以用户的命运完成非法操作。 CSRF攻击的原理 下面先介绍一下CSRF攻击的原理： 完成CSRF攻击必须要有三个条件： 用户已经登录了站点A，并在本地记录了Cookie； 在用户没有登出站点A的情况下（也就是Cookie生效的情况下），访问了恶意攻击者提供的引诱危险站点B（B站点要求访问站点A）； 站点A没有做任何CSRF防御； 我们来看一个例子：当我们登入转账页面后，突然眼前一亮惊现”XXX隐私照片，不看后悔一辈子”的链接，耐不住内心躁动，立马点击了该危险的网站（页面代码如下图所示），但当这页面一加载，便会执行submitForm这个方法来提交转账请求，从而将10块转给黑客。 如何防御 防范CSRF攻击可以遵循以下几种规则： Get请求不对数据进行修改； 不让第三方网站访问用户Cookie 阻止第三方网站请求接口 请求时附带验证信息，比如验证码或者Token （1）SameSite 可以对Cookie设置SameSite属性，该属性表示Cookie不随着跨域请求发送，可以很大程度减少CSRF的攻击，但是该属性目前并不是所有浏览器都兼容。 （2）Referer Check HTTP Referer是header的一部分，当浏览器向Web服务器发送请求时，一般会带上Referer信息告诉服务器是从哪个页面的链接过来的，服务器借此可以获得一些信息用于处理。可以通过检测请求的来源来防御CSRF攻击。正常请求的referer具有一定规律，如在提交表单的referer必定实在该页面发送的请求。所以通过检查http header referer的值是不是这个页面，来判断是不是CSRF攻击。 但当某些情况下如此从https跳转到http，浏览器处于安全考虑，不会发送referer，服务器就无法进行check了。若与该网站同域的其他网站有XSS漏洞，那么攻击者可以在其他网站注入恶意脚本，受害者进入了此类同域的网址，也会遭受攻击。处于以上原因，无法完全依赖Referer Check作为防御CSRF的主要手段。但是可以通过Referer Check来监控CSRF攻击的发生。 （3）Anti CSRF Token 目前比较完善的解决方案是加入Anti-CSRF-Token。即发送请求时在HTTP请求中以参数的形式加入一个随机产生的Token，并在服务器建立一个拦截器来验证这个Token。服务器读取浏览器当前域Cookie值，会进行校验该请求当中的Token和Cookie当中的Token值是否都存在且相等，才认为这是合法的请求。否则认为这次请求是违法的，拒绝该次服务。 这种方法相比Referer检查要安全很多，token可以在用户登陆后产生并放于session或cookie中，然后在每次请求时服务器把token从session或cookie中拿出，与本次请求中的token 进行比对。由于token的存在，攻击者无法再构造出一个完整的URL实施CSRF攻击。但在处理多个页面共存问题时，当某个页面消耗掉token后，其他页面的表单保存的还是被消耗掉的那个token，其他页面的表单提交时会出现token错误。 （4）验证码 应用程序和用户进行交互过程中，特别是账户交易这种核心步骤，强制用户输入验证码，才能完成最终请求。在通常情况下，验证码够很好地遏制CSRF攻击。但增加验证码降低了用户的体验，网站不能给所有的操作都加上验证码。所以只能将验证码作为一种辅助手段，在关键业务点设置验证码。 点击劫持点击劫持是一种视觉欺骗的攻击手段。攻击者将需要攻击的网站通过 iframe 嵌套的方式嵌入自己的网页中，并将 iframe 设置为透明，在页面中透出一个按钮诱导用户点击。 特点 隐蔽性较高，骗取用户操作； “UI-覆盖攻击”； 利用iframe或者其它标签的属性； 点击劫持的原理 用户在登录A网站的系统后，被攻击者诱惑打开第三方网站，而第三方网站通过iframe引入了A网站的页面内容，用户在第三方网站中点击某个按钮（被装饰的按钮），实际上是点击了A网站的按钮。接下来我们举个例子：我在有空发布了很多视频，想让更多的人关注它，就可以通过点击劫持来实现。 123456789101112131415161718192021222324iframe &#123;width: 1440px;height: 900px;position: absolute;top: -0px;left: -0px;z-index: 2;-moz-opacity: 0;opacity: 0;filter: alpha(opacity=0);&#125;button &#123;position: absolute;top: 270px;left: 1150px;z-index: 1;width: 90px;height:40px;&#125;&lt;/style&gt;......&lt;button&gt;点击脱衣&lt;/button&gt;&lt;img src="http://pic1.win4000.com/wallpaper/2018-03-19/5aaf2bf0122d2.jpg"&gt;&lt;iframe src="http://i.youku.com/u/UMjA0NTg4Njcy" scrolling="no"&gt;&lt;/iframe&gt; 从上图可知，攻击者通过图片作为页面背景，隐藏了用户操作的真实界面，当你按耐不住好奇点击按钮以后，真正的点击的其实是隐藏的那个页面的订阅按钮，然后就会在你不知情的情况下订阅了。 如何防御 （1）X-FRAME-OPTIONS X-FRAME-OPTIONS是一个HTTP响应头，在现代浏览器有一个很好的支持。这个HTTP响应头就是为了防御用iframe嵌套的点击劫持攻击。 该响应头有三个值可选，分别是： DENY，表示页面不允许通过 iframe 的方式展示 SAMEORIGIN，表示页面可以在相同域名下通过 iframe 的方式展示 ALLOW-FROM，表示页面可以在指定来源的 iframe 中展示 （2）JavaScript防御 对于某些远古浏览器来说，并不能支持上面的这种方式，那我们只有通过 JS 的方式来防御点击劫持了。 1234567891011121314151617&lt;head&gt; &lt;style id="click-jack"&gt; html &#123; display: none !important; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; if (self == top) &#123; var style = document.getElementById('click-jack') document.body.removeChild(style) &#125; else &#123; top.location = self.location &#125; &lt;/script&gt;&lt;/body&gt; 以上代码的作用就是当通过 iframe 的方式加载页面时，攻击者的网页直接不显示所有内容了。 URL跳转漏洞定义：借助未验证的URL跳转，将应用程序引导到不安全的第三方区域，从而导致的安全问题。 URL跳转漏洞原理 黑客利用URL跳转漏洞来诱导安全意识低的用户点击，导致用户信息泄露或者资金的流失。其原理是黑客构建恶意链接（链接需要进行伪装，尽可能迷惑），发在QQ群或者浏览量多的贴吧/论坛中，安全意识低的用户点击后，经过服务器或者浏览器解析后，跳到恶意的网站中。 诸如伪装成像如下的网址，你是否能够识别出来是恶意网址呢？ 123http://gate.baidu.com/index?act=go&amp;url=http://t.cn/RVTatrdhttp://qt.qq.com/safecheck.html?flag=1&amp;url=http://t.cn/RVTatrdhttp://tieba.baidu.com/f/user/passport?jumpUrl=http://t.cn/RVTatrd 实现方式： Header跳转 JavaScript跳转； meta标签跳转； 这里我们举个Header跳转实现： 1234&lt;?php$url=$_GET['jumpto'];header("Location: $url");?&gt; 1http://www.wooyun.org/login.php?jumpto=http://www.evil.com 这里用户会认为www.wooyun.org都是可信的，但点击上述链接将导致用户最终访问www.evil.com这个恶意网址。 如何防御 （1）referer的限制 如果确定传递URL参数进入的来源，我们可以通过该方式实现安全限制，保证该URL的有效性，避免恶意用户自己生成跳转链接。 （2）加入有效性验证Token 我们保证所有生成的链接都是来自于我们可信域的，通过在生成的链接里加入用户不可控的Token对生成的链接进行校验，可以避免用户生成自己的恶意链接从而被利用，但是如果功能本身要求比较开发，可能导致有一定的限制。 SQL注入SQL注入是一种常见的Web安全漏洞，攻击者利用这个漏洞，可以访问或修改数据，或者利用潜在的数据库漏洞进行攻击。 SQL注入的原理 我们先举个万能钥匙的例子来说明其原理： 12345&lt;form action="/login" method="POST"&gt; &lt;p&gt;Username: &lt;input type="text" name="username" /&gt;&lt;/p&gt; &lt;p&gt;Password: &lt;input type="password" name="password" /&gt;&lt;/p&gt; &lt;p&gt;&lt;input type="submit" value="登陆" /&gt;&lt;/p&gt;&lt;/form&gt; 后端的SQL语句可能是如下这样的： 1234567let querySQL = ` SELECT * FROM user WHERE username='$&#123;username&#125;' AND psw='$&#123;password&#125;'`;// 接下来就是执行 sql 语句... 这是我们经常见到的登录页面，但如果有一个恶意攻击者输入的用户名是 admin&#39; --，密码随意输入，就可以直接登入系统了。why! —-这就是SQL注入。 我们之前预想的SQL 语句是: 1SELECT * FROM user WHERE username='admin' AND psw='password' 但是恶意攻击者用奇怪用户名将你的 SQL 语句变成了如下形式： 1SELECT * FROM user WHERE username='admin' --' AND psw='xxxx' 在 SQL 中,&#39; --是闭合和注释的意思，– 是注释后面的内容的意思，所以查询语句就变成了： 1SELECT * FROM user WHERE username='admin' 所谓的万能密码的本质，就是SQL注入的一种利用方式 一次SQL注入的过程包括以下几个过程 获取用户请求参数； 拼接到代码当中； SQL语句按照我们构造参数的语义执行成功； SQL注入的必备条件：1. 可以控制输入的数据。2. 服务器要执行的代码拼接了控制的数据 我们会发现SQL注入流程中与正常请求服务器类似，只是黑客控制了数据，构造了SQL查询，而正常的请求不会SQL查询这一步，SQL注入的本质:数据和代码未分离，即数据当做了代码来执行。 危害 获取数据库信息 管理员后台用户名和密码 获取其他数据库敏感信息：用户名、密码、手机号码、身份证、银行卡信息…… 整个数据库：脱库 获取服务器权限 植入WebShell，获取服务器后面 读取服务器敏感文件 如何防御 严格限制Web应用的数据库的操作权限，给此用户提供仅仅能够满足其工作的最低权限，从而最大限度的减少注入攻击对数据库的危害； 后端代码检查输入的数据是否符合预期，严格限制变量的类型，例如使用正则表达式进行一些匹配处理； 对进行数据库的特殊字符（’，”，\，&lt;，&gt;，&amp;，*，; 等）进行转义处理，或编码转换。基本上所有的后端语言都有对字符串进行转义处理的方法，比如lodash 的 lodash._escapehtmlchar 库。 所有的查询语句建议使用数据库提供的参数化查询接口，参数化的语句使用参数而不是将用户输入变量嵌入到SQL语句中，即不要直接拼接SQL语句。例如Node.js中的mysqljs库的query方法中的？占位参数。 OS命令注入攻击OS命令注入和SQL注入差不多，只不过SQL注入是针对数据库的，而OS命令注入是针对操作系统的。OS命令注入攻击指通过Web应用，执行非法的操作系统命令达到攻击的目的。只要在能调用Shell函数的地方久有存在被攻击的风险。倘若调用Shell存在疏漏，就可以执行插入的非法命令。 命令注入攻击可以向Shell发送命令，让Windows或Linux操作系统的命令行启动程序，也就是说，通过命令注入攻击可执行操作系统上安装着的各种程序。 原理 黑客构造命令提交给Web应用程序，Web应用程序提取黑客构造的命令，拼接到被执行的命令中，因黑客注入的命令打破了原有命令结构，导致Web应用执行了额外的命令，最后Web应用程序将执行的结果输出到响应页面中。 我们通过一个例子来说明其原理，假如需要实现一个需求：用户提交一些内容到服务器，然后在服务器执行一些系统命令去返回一个结果给用户。 1234// 以 Node.js 为例，假如在接口中需要从 github 下载用户指定的 repoconst exec = require('mz/child_process').exec;let params = &#123;/* 用户输入的参数 */&#125;;exec(`git clone $&#123;params.repo&#125; /some/path`); 如果 params.repo 传入的是 https://github.com/admin/admin.github.io.git 确实能从指定的 git repo 上下载到想要的代码。 但是如果 params.repo 传入的是 https://github.com/xx/xx.git &amp;&amp; rm -rf /* &amp;&amp; 恰好你的服务是用 root 权限起的就糟糕了。 如何防御 后端对前端提交内容进行规则限制（比如正则表达式）； 在调用系统命令前对所有传入参数进行命令行参数转义过滤； 不要直接拼接命令语句，借助一些工具做拼接、转义预处理，例如 Node.js 的 shell-escape npm包；]]></content>
  </entry>
  <entry>
    <title><![CDATA[HTTPS工作原理]]></title>
    <url>%2F2019%2F08%2F27%2FHTTPS%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[近几年，互联网发送着翻天覆地的变化，尤其是我们一直习以为常的HTTP协议，在逐渐的被HTTPS协议所取代，在浏览器、搜索引擎、CA机构、大型互联网企业的共同促进下，互联网迎来了“HTTPS加密时代”，HTTPS将在未来的几年内全面取代HTTP成为传输协议的主流。 什么是HTTPSHTTPS是在HTTP上建立SSL加密层，并对传输数据进行加密，是HTTP协议的完全版。现在它被广泛用于万维网上安全敏感的通讯，例如交易支付方面。 HTTPS主要作用是： 对数据进行加密，并建立一个信息安全通道，来保证传输过程中的数据安全。 对网站服务器进行真实身份认证。 我们经常会在Web的登录页面和购物结算界面等使用HTTPS通信。使用HTTPS通信时，不再用http://，而是改用https://。另外，当浏览器访问HTTPS通信有效的Web网站时，浏览器的地址栏内会出现一个带锁的标志。对HTTPS的显示方式会因浏览器的不同而有所改变。 为什么需要HTTPS在HTTP协议中有可能存在信息窃取或身份伪装等安全问题。使用HTTPS通信机制可以有效地防止这些问题，接下来，我们先来了解下HTTP协议存在的哪些问题： 通信使用明文（不加密），内容可能被窃取。 由于HTTP本身不具备加密的功能，所以也无法做到对通信整体（使用HTTP协议通信的请求和响应的内容）进行加密，即，HTTP报文使用明文（指未经过加密的报文）方式发送。 HTTP明文协议的缺陷是导致数据泄露、数据篡改、流量劫持、钓鱼攻击等安全问题的重要原因。HTTP协议无法加密数据，所以通信数据都在网络中明文“裸奔”。通过网络的嗅探设备及一些技术手段，就可还原HTTP保温内容。 无法证明报文的完整性，所以可能遭篡改。 所谓完整性是指信息的准备度。若无法证明其完整性，通常也就意味着无法判断信息是否准确。由于HTTP协议无法证明 通信的报文完整性，因此，在请求或响应送出之后直到对方接收之前的这段时间内，即使请求或响应的内容遭到篡改，也没有办法获悉。换句话说，没有任何办法确认，发送的请求/响应和接收到的请求/响应是前后相同的。 不验证通信方的身份，因此有可能遭遇伪装。 HTTP协议中的请求和响应不会对通信方进行确认。在HTTP协议通信时，由于不存在确认通信方的处理步骤，任何人都可以发送请求。另外，服务器只要接收到请求，不管对方是谁都会返回一个响应（但也仅源于发送端的IP地址和端口号没有被Web服务器限定限制访问的前提下） 反观HTTPS协议，它比HTTP协议相比多了以下优势（下文会详细介绍）： 数据隐私性：内容经过对称加密，每个连接生成一个唯一的加密密钥。 数据完整性：内容传输经过完整性校验。 身份认证：第三方无法伪造服务器（客户端）身份。 HTTPS如何解决HTTP上述问题HTTPS并非时应用层的一种新协议。只是HTTP通信接口部分使用SSL和TLS协议代替而已。 通常，HTTP直接和TCP通信。当使用SSL时，则演变成先和SSL通信，再由SSL和TCP通信了。简言之，所谓HTTPS，其实就是身披SSL协议这层外壳的HTTP。 在采用SSL后，HTTP就拥有了HTTPS的加密、证书和完整性保护这些功能。也就是说HTTP加上加密处理和认证以及完整性保护后就是HTTPS。 HTTPS协议的主要功能基本都依赖于TLS/SSL协议，TLS/SSL的功能实现主要依赖于三类基本算法：散列函数、对此加密和非对称加密，其利用非对称加密实现身份认证和密钥协商，对称加密算法采用协商的密钥对数据加密，基于散列函数验证信息的完整性。 解决内容可能被窃听的问题——加密 对称加密 这种方式加密和解密同用一个密钥。加密和解密都会用到密钥。没有密钥就无法对密码解密，反过来说，任何人只要持有密钥就能解密了。 以对称加密方式加密时必须将密钥也发给对方。可究竟怎样才能完全地转交？在互联网上转发密钥时，如果通信被监听那么密钥就可会落人攻击者之手，同时也就失去了加密的意义。另外还得设法安全地保管接收到的密钥。 非对称加密 公开密钥加密使用一对非对称的密钥。一把叫做私有密钥，另一把叫做公开密钥。顾名思义，私有密钥不能让其他任何人知道，而公开密钥则可以随意发布，任何人都可以获得。 使用公开密钥加密方式，发送密文的一方使用对方的公开密钥进行加密处理，对方收到被加密的信息后，再使用自己的私有密钥进行解密。利用 这种方式，不需要发送用来解密的私有密钥，也不必担心密钥被攻击者窃听而盗走。 非对称加密的特点是信息传输一对多，服务器只需要维持一个私钥就能够和多个客户端加密通信。 这种方式有以下缺点： 公钥是公开的，所以针对私钥加密的信息，黑客截获后可以使用公钥进行解密，获取其中的内容； 公钥并不包含服务器的信息，使用非对称加密算法无法确保服务器身份的合法性，存在中间人攻击的风险，服务器发送给客户端的公钥可能在传送过程中被中间人截获并篡改； 使用非对称加密在数据加密解密过程需要消耗一定时间，降低了数据传输效率； 对称加密+非对称加密(HTTPS采用这种方式) 使用对称密钥的好处是解密的效率比较快，使用非对称密钥的好处是可以使得传输的内容不能被破解，因为就算你拦截到了数据，但是没有对应的私钥，也是不能破解内容的。就比如说你抢到了一个保险柜，但是没有保险柜的钥匙也不能打开保险柜。那我们就将对称加密与非对称加密结合起来,充分利用两者各自的优势，在交换密钥环节使用非对称加密方式，之后的建立通信交换报文阶段则使用对称加密方式。 具体做法是：发送密文的一方使用对方的公钥进行加密处理“对称的密钥”，然后对方用自己的私钥解密拿到“对称的密钥”，这样可以确保交换的密钥是安全的前提下，使用对称加密方式进行通信。所以，HTTPS采用对称加密和非对称加密两者并用的混合加密机制。 解决报文可能遭篡改问题——数字签名 网络传输过程中需要经过很多中间节点，虽然数据无法被解密，但可能被篡改，那如何校验数据的完整性呢？——校验数字签名 数字签名有两种功效： 能确定消息确定是由发送方签名并发出来的，因为别人假冒不了发送方的签名； 数字签名能确定消息的完整性，证明数据是否未被篡改； 数字签名如何生成： 将一段文本先用Hash函数生成消息摘要，然后用发送者的私钥加密生成数字签名，与原文一起传送给接收者。接下来就是接收者校验数字签名的流程了。 接收者只有用发送者的公钥才能解密被加密的摘要信息，然后用Hash函数对收到的原文产生一个摘要信息，与上一步得到的摘要信息对比。如果相同，则说明收到的信息是完整的，在传输过程中没有被修改，否则说明信息被修改过，因此数字签名能检验信息的完整性。 假设消息传递在Kobe，James两人之间发生。James将消息连同数字签名一起发送给Kobe，Kobe接收到消息后，通过校验数字签名，就可以验证接收到的消息就是James发送的。当然，这个过程的前提是Kobe知道James的公钥。问题的关键的是，和消息本身一样，公钥不能在不安全的网络中直接发送给Kobe,或者说拿到的公钥如何证明是James的。 此时就需要引入了证书颁发机构（Certificate Authority，简称CA），CA数量并不多，Kobe客户端内置了所有受信任CA的证书。CA对James的公钥（和其他信息）数字签名后生成证书。 解决通信方身份可能被伪装的问题——数字证书 数字证书认证机构处于客户端与服务器双方都可信赖的第三方机构的立场上。 我们来介绍一下数字证书认证机构的业务流程 服务器的运营人员向第三方机构CA提交公钥、组织信息、个人信息(域名)等信息并申请认证; CA通过线上、线下等多种手段验证申请者提供信息的真实性，如组织是否存在、企业是否合法，是否拥有域名的所有权等; 如信息审核通过，CA会向申请者签发认证文件-证书。证书包含以下信息：申请者公钥、申请者的组织信息和个人信息、签发机构 CA的信息、有效时间、证书序列号等信息的明文，同时包含一个签名。 其中签名的产生算法：首先，使用散列函数计算公开的明文信息的信息摘要，然后，采用 CA的私钥对信息摘要进行加密，密文即签名; 客户端 Client 向服务器 Server 发出请求时，Server 返回证书文件; 客户端 Client 读取证书中的相关的明文信息，采用相同的散列函数计算得到信息摘要，然后，利用对应 CA的公钥解密签名数据，对比证书的信息摘要，如果一致，则可以确认证书的合法性，即服务器的公开密钥是值得信赖的。 客户端还会验证证书相关的域名信息、有效时间等信息; 客户端会内置信任CA的证书信息(包含公钥)，如果CA不被信任，则找不到对应 CA的证书，证书也会被判定非法。 HTTPS工作流程 Client发起一个HTTPS（比如https://juejin.im/user/5a9a9cdcf265da238b7d771c）的请求，根据RFC2818的规定，Client知道需要连接Server的443（默认）端口。 Server把事先配置好的公钥证书（public key certificate）返回给客户端。 Client验证公钥证书：比如是否在有效期间，证书的用途是不是匹配Client请求的站点，是不是在CRL吊销列表里面，它的上一级证书是否有效，这是一个递归的过程，直到验证到根证书（操作系统内置的Root证书或者Client内置的Root证书）。如果验证通过则继续，不通过则显示警告信息。 CLient使用伪随机数生成器生成加密所使用的对称密钥，然后用证书的公钥加密这个对称密钥，发给Server。 Server使用自己的私钥解密这个消息，得到对称密钥。至此，Client和Server双方都持有了相同的对称密钥。 Server使用对称密钥加密“明文内容A”，发送给Client。 Client使用对称密钥解密相应的密文，得到“明文内容A”。 Client再次发起HTTPS的请求，使用对称密钥加密请求的“明文内容B”，然后Server使用对称密钥解密密文，得到“明文内容B”。 HTTP与HTTPS的区别 HTTP是明文传输协议，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输，身份认证的网络协议，比HTTP协议安全。 关于安全性，用最简单的比喻形容两者的关系就是卡车运货，HTTP下的运货车是敞篷的，货物都是暴露的。而HTTPS则是封闭集装箱车，安全性自然提升不少。 HTTPS比HTTP更加安全，对搜索引擎更友好，利于SEO,谷歌、百度优先索引HTTPS网页; HTTPS需要用到SSL证书，而HTTP不用; HTTPS标准端口443，HTTP标准端口80; HTTPS基于传输层，HTTP基于应用层; HTTPS在浏览器显示绿色安全锁，HTTP没有显示; 为何不所有的网站都使用HTTPS既然HTTPS那么安全可靠，那为何所有的Web网站都使用HTTPS？ 首先，很多人还是会觉得HTTPS实施有门槛，这个门槛在于需要权威CA颁发的SSL证书。从证书的选择、购买到部署，传统的模式下都会比较耗时耗力。 其次，HTTPS普遍认为性能消耗要大于HTTP，因为与纯文本通信相比，加密通信会消耗更多的CPU及内存资源。如果每次通信都加密，会消耗相当多的资源，平摊到一台计算机上时，能够处理的请求数量必定也会随之减少。但事实并非如此，用户可以通过性能优化、把证书部署在SLB或CDN，来解决此问题。举个实际的例子，“双十一”期间，全站HTTPS的淘宝、天猫依然保证了网站和移动端的访问、浏览、交易等操作的顺畅、平滑。通过测试发现，经过优化后的许多页面性能与HTTP持平甚至还有小幅提升，因此HTTPS经过优化之后其实并不慢。 除此之外，想要节约购买证书的开销也是原因之一。要进行HTTPS通信，证书是必不可少的。而使用的证书必须向认证机构（CA）购买。 最后是安全意识。相比国内，国外互联网行业的安全意识和技术应用相对成熟，HTTPS部署趋势是由社会、企业、政府共同去推动的。]]></content>
  </entry>
  <entry>
    <title><![CDATA[九种跨域方式实现原理]]></title>
    <url>%2F2019%2F08%2F27%2F%E4%B9%9D%E7%A7%8D%E8%B7%A8%E5%9F%9F%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[前后端数据交互经常会碰到请求跨域，什么是跨域，以及有哪几种跨域方式，这是本文要探讨的内容。 什么是跨域 什么是同源策略及其限制内容 同源策略是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS，CSRF等攻击。所谓同源是指“协议+域名+端口”三者相同，即便两个不同的域名指向同一个ip地址，也非同源。 同源策略限制内容有： Cookie、LocalStorage、IndexedDB等存储性内容 DOM节点 AJAX请求发送后，结果被浏览器拦截了 但是有三个标签是允许跨域加载资源： &lt;img scr=XXX&gt; &lt;link href=XXX&gt; &lt;script src=XXX&gt; 常见跨域场景 当协议、子域名、主域名、端口号中有任意一个不相同时，都算作不同域。不同域之间相互请求资源，就算作“跨域”。常见跨域场景如下图所示： 特别说明两点： 第一：如果时协议和端口造成的跨域问题，“前台”时无能为力的 第二：在跨域问题上，仅仅是通过“URL的首部”来识别而不会根据域名对应的IP地址是否相同来判断。“URL的首部”可以理解为“协议，域名和端口必须匹配”。 这里你或许有个疑问：请求跨域了，那请求到底发出去没有？ 跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了。你可能会疑问明明通过表单的方式可以发送跨域请求，为什么Ajax就不会？因为归根结底，跨域是为了阻止用户读取到另一个域名下的内容，Ajax可以获取响应，浏览器认为这不安全，所以拦截了响应。但是表单并不会获取新的内容，所以可以发起跨域请求。同时也说明了跨域并不能完全阻止CSRF，因为请求毕竟是发出去了。 跨域解决方案 jsonp JSONP原理 利用&lt;script&gt;标签没有跨域限制的漏洞，网页可以得到从其他来源动态产生JSON数据。JSONP请求一定需要对方的服务器做支持才可以。 JSONP和AJAX对比 JSONP和AJAX相同，都是客户端向服务器端发送请求，从服务器端获取数据的方式。但AJAX属于同源策略，JSONP属于非同源策略（跨域请求）。 JSONP的优缺点 JSONP优点是简单兼容性好，可用于解决主流浏览器的跨域s数据访问的问题。缺点是仅支持get方法具有局限性，不安全可能会遭受XSS攻击。 JSONP的实现流程 声明一个回调函数，其函数名（如show）当做参数值，要传递给跨域请求数据的服务器，函数形参为要获取目标数据（服务器返回的data） 创建一个&lt;script&gt;标签，把哪个跨域的API数据接口地址，赋值给script的src，还要在这个地址中向服务器传递该函数名（可以通过问好传参：?callback=show）。 服务器接收到请求后，需要进行特殊的处理：把传递进来的函数名和它需要给你的数据拼接成一个字符串，例如：传递进来的函数名是show，它准备好的数据是show(‘我不爱你’)。 最后服务器把准备的数据通过HTTP协议返回给客户端，客户端再调用执行之前按声明的会点函数（show）,对返回的数据进行操作。 在开发中可能会遇到多个JSONP请求的回电函数名是相同的，这时候就需要自己封装一个JSONP函数。 123456789101112131415161718192021222324// index.htmlfunction jsonp(&#123; url, params, callback &#125;) &#123; return new Promise((resolve, reject) =&gt; &#123; let script = document.createElement('script') window[callback] = function(data) &#123; resolve(data) document.body.removeChild(script) &#125; params = &#123; ...params, callback &#125; // wd=b&amp;callback=show let arrs = [] for (let key in params) &#123; arrs.push(`$&#123;key&#125;=$&#123;params[key]&#125;`) &#125; script.src = `$&#123;url&#125;?$&#123;arrs.join('&amp;')&#125;` document.body.appendChild(script) &#125;)&#125;jsonp(&#123; url: 'http://localhost:3000/say', params: &#123; wd: 'Iloveyou' &#125;, callback: 'show'&#125;).then(data =&gt; &#123; console.log(data)&#125;) 上面这段代码相当于向http://localhost:3000/say?wd=Iloveyou&amp;callback=show这个地址请求数据，然后后台返回show(&#39;我不爱你&#39;)，最后会运行show()这个函数，打印出’我不爱你’。 jQuery的hsonp形式 JSONP都是GET和异步请求的，不存在其他的请求方式和同步请求，且jQuery默认就会给JSONP的请求清除缓存。 123456789$.ajax(&#123; url:"http://crossdomain.com/jsonServerResponse", dataType:"jsonp", type:"get",//可以省略 jsonpCallback:"show",//-&gt;自定义传递给服务器的函数名，而不是使用jQuery自动生成的，可省略 jsonp:"callback",//-&gt;把传递函数名的那个形参callback，可省略 success:function (data)&#123; console.log(data);&#125;&#125;); CORS CORS需要浏览器和后端同时支持。IE８和９需要通过XDomainRequest来实现。 浏览器会自动进行CORS通信，实现CORS通信的关键是后端，只要后端实现了CORS，就实现了跨域。 服务器设置Access-Control-Allow-Origin就可以开启CORS。该属性表示哪些域名可以访问资源，如果设置通配符则表示所以网站都可以访问资源。 虽然设置CORS和前端没什么关系，但是通过这种方式解决跨域问题的话，胡在发送请求时出现两种情况，分别为简单请求和复杂请求。 简单请求 只要同时满足以下两大条件，就属于简单请求 条件1：使用下列方法之一： GET HEAD POST 条件2：Content-Type的值仅限于下列三者之一： text/plain multipart/form-data application/x-www-form-urlencoded 请求中的任意XMLHttpRequestUpload对象均没有注册任何事件监听器； XMLHttpRequestUpload 对象可以使用 XMLHttpRequest.upload 属性访问。 复杂请求 不符合以上条件的请求就肯定是复杂请求了，复杂请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为“预检”请求，该请求是option方法的，通过该请求来知道服务端是否允许跨域请求。 我们用PUT向后台请求时，属于复杂请求，后台需做如下配置： 12345678910111213// 允许哪个方法访问我res.setHeader('Access-Control-Allow-Methods', 'PUT')// 预检的存活时间res.setHeader('Access-Control-Max-Age', 6)// OPTIONS请求不做任何处理if (req.method === 'OPTIONS') &#123; res.end() &#125;// 定义后台返回的内容app.put('/getData', function(req, res) &#123; console.log(req.headers) res.end('我不爱你')&#125;) 接下来我们看一下完整复杂请求的例子，并且介绍CORS请求相关的字段 12345678910111213141516// index.htmllet xhr = new XMLHttpRequest()document.cookie = 'name=xiamen' // cookie不能跨域xhr.withCredentials = true // 前端设置是否带cookiexhr.open('PUT', 'http://localhost:4000/getData', true)xhr.setRequestHeader('name', 'xiamen')xhr.onreadystatechange = function() &#123; if (xhr.readyState === 4) &#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status === 304) &#123; console.log(xhr.response) //得到响应头，后台需设置Access-Control-Expose-Headers console.log(xhr.getResponseHeader('name')) &#125; &#125;&#125;xhr.send() 12345//server1.jslet express = require('express');let app = express();app.use(express.static(__dirname));app.listen(3000); 123456789101112131415161718192021222324252627282930313233343536//server2.jslet express = require('express')let app = express()let whitList = ['http://localhost:3000'] //设置白名单app.use(function(req, res, next) &#123; let origin = req.headers.origin if (whitList.includes(origin)) &#123; // 设置哪个源可以访问我 res.setHeader('Access-Control-Allow-Origin', origin) // 允许携带哪个头访问我 res.setHeader('Access-Control-Allow-Headers', 'name') // 允许哪个方法访问我 res.setHeader('Access-Control-Allow-Methods', 'PUT') // 允许携带cookie res.setHeader('Access-Control-Allow-Credentials', true) // 预检的存活时间 res.setHeader('Access-Control-Max-Age', 6) // 允许返回的头 res.setHeader('Access-Control-Expose-Headers', 'name') if (req.method === 'OPTIONS') &#123; res.end() // OPTIONS请求不做任何处理 &#125; &#125; next()&#125;)app.put('/getData', function(req, res) &#123; console.log(req.headers) res.setHeader('name', 'jw') //返回一个响应头，后台需设置 res.end('我不爱你')&#125;)app.get('/getData', function(req, res) &#123; console.log(req.headers) res.end('我不爱你')&#125;)app.use(express.static(__dirname))app.listen(4000) 上述代码由http://localhost:3000/index.html向http://localhost:4000/跨域请求，正如我们上面所说的，后端是实现 CORS 通信的关键。 postMessage postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题： 页面和其打开的新窗口的数据传递 多窗口之间消息传递 页面与嵌套的iframe消息传递 上面三个场景的跨域数据传递 postMessage()方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递。 otherWindows.oistMessage(message, targetOrigin, [transfer]); message: 将要发送到其他 window的数据。 targetOrigin:通过窗口的origin属性来指定哪些窗口能接收到消息事件，其值可以是字符串”*”（表示无限制）或者一个URI。在发送消息的时候，如果目标窗口的协议、主机地址或端口这三者的任意一项不匹配targetOrigin提供的值，那么消息就不会被发送；只有三者完全匹配，消息才会被发送。 transfer(可选)：是一串和message 同时传递的 Transferable 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。 接下来我们看个例子： http://localhost:3000/a.html页面向http://localhost:4000/b.html传递“我爱你”,然后后者传回”我不爱你”。 123456789101112// a.html &lt;iframe src="http://localhost:4000/b.html" frameborder="0" id="frame" onload="load()"&gt;&lt;/iframe&gt; //等它加载完触发一个事件 //内嵌在http://localhost:3000/a.html &lt;script&gt; function load() &#123; let frame = document.getElementById('frame') frame.contentWindow.postMessage('我爱你', 'http://localhost:4000') //发送数据 window.onmessage = function(e) &#123; //接受返回数据 console.log(e.data) //我不爱你 &#125; &#125; &lt;/script&gt; 12345// b.html window.onmessage = function(e) &#123; console.log(e.data) //我爱你 e.source.postMessage('我不爱你', e.origin) &#125; WebSocket WebSocket是HTML5的一个持久化的协议，它实现了浏览器与服务器的全双工通信，同时也是跨域的一种解决方案。WebSocket和HTTP都是应用层协议，都基于TCP协议。但是WebSocket是一种双向通信协议，在建立连接之后，WebSocket的server与client都能主动向对方发送或接收数据。同时，WebSocket在建立连接时需要HTTP协议，连接建立好了之后client与server之间的双向通信就与HTTP无关了。 原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好地封装了WebSocket接口，提供了更简单、灵活的接口，也对不支持WebSocket的浏览器提供向下兼容。 我们先来看个例子：本地文件socket.html向localhost:3000发生数据和接受数据 12345678910// socket.html&lt;script&gt; let socket = new WebSocket('ws://localhost:3000'); socket.onopen = function () &#123; socket.send('我爱你');//向服务器发送数据 &#125; socket.onmessage = function (e) &#123; console.log(e.data);//接收服务器返回的数据 &#125;&lt;/script&gt; 1234567891011// server.jslet express = require('express');let app = express();let WebSocket = require('ws');//记得安装wslet wss = new WebSocket.Server(&#123;port:3000&#125;);wss.on('connection',function(ws) &#123; ws.on('message', function (data) &#123; console.log(data); ws.send('我不爱你') &#125;);&#125;) Node中间件代理（两次跨域） 实现原理：同源策略是浏览器需要遵循的标准，而如果是服务器向服务器请求就无需遵循同源策略。代理服务器，需要做以下几个步骤： 接收客户端请求。 将请求转发给服务器 拿到服务器响应数据。 将响应数据转发给客户端 我们先来看个例子：本地文件index.html文件，通过代理服务器http://localhost:3000向目标服务器http://localhost:4000请求数据。 12345678910111213141516// index.html(http://127.0.0.1:5500) &lt;script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"&gt;&lt;/script&gt; &lt;script&gt; $.ajax(&#123; url: 'http://localhost:3000', type: 'post', data: &#123; name: 'xiamen', password: '123456' &#125;, contentType: 'application/json;charset=utf-8', success: function(result) &#123; console.log(result) // &#123;"title":"fontend","password":"123456"&#125; &#125;, error: function(msg) &#123; console.log(msg) &#125; &#125;) &lt;/script&gt; 1234567891011121314151617181920212223242526272829303132333435363738// server1.js 代理服务器(http://localhost:3000)const http = require('http')// 第一步：接受客户端请求const server = http.createServer((request, response) =&gt; &#123; // 代理服务器，直接和浏览器直接交互，需要设置CORS 的首部字段 response.writeHead(200, &#123; 'Access-Control-Allow-Origin': '*', 'Access-Control-Allow-Methods': '*', 'Access-Control-Allow-Headers': 'Content-Type' &#125;) // 第二步：将请求转发给服务器 const proxyRequest = http .request( &#123; host: '127.0.0.1', port: 4000, url: '/', method: request.method, headers: request.headers &#125;, serverResponse =&gt; &#123; // 第三步：收到服务器的响应 var body = '' serverResponse.on('data', chunk =&gt; &#123; body += chunk &#125;) serverResponse.on('end', () =&gt; &#123; console.log('The data is ' + body) // 第四步：将响应结果转发给浏览器 response.end(body) &#125;) &#125; ) .end()&#125;)server.listen(3000, () =&gt; &#123; console.log('The proxyServer is running at http://localhost:3000')&#125;) 1234567891011// server2.js(http://localhost:4000)const http = require('http')const data = &#123; title: 'fontend', password: '123456' &#125;const server = http.createServer((request, response) =&gt; &#123; if (request.url === '/') &#123; response.end(JSON.stringify(data)) &#125;&#125;)server.listen(4000, () =&gt; &#123; console.log('The server is running at http://localhost:4000')&#125;) 上述代码经过两次跨域，值得注意的是浏览器向代理服务器发送请求，也遵循同源策略，最后在index.html文件打印出{&quot;title&quot;:&quot;fontend&quot;,&quot;password&quot;:&quot;123456&quot;} nginx反向代理 实现原理类似于Node中间件代理，需要你搭建一个中转nginx服务器，用于转发请求。 使用nginx反向代理实现跨域，是最简单的跨域方式。只需要修改nginx的配置即可解决跨域问题，支持所有浏览器，支持session，不需要修改任何代码，并且不会影响服务器性能。 实现思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。 先下载nginx，然后将nginx目录下的nginx.com修改如下： 1234567891011121314// proxy服务器server &#123; listen 81; server_name www.domain1.com; location / &#123; proxy_pass http://www.domain2.com:8080; #反向代理 proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名 index index.html index.htm; # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用 add_header Access-Control-Allow-Origin http://www.domain1.com; #当前端只跨域不带cookie时，可为* add_header Access-Control-Allow-Credentials true; &#125;&#125; 最后通过命令行nginx-sreload启动nginx 1234567// index.htmlvar xhr = new XMLHttpRequest();// 前端开关：浏览器是否读写cookiexhr.withCredentials = true;// 访问nginx中的代理服务器xhr.open('get', 'http://www.domain1.com:81/?user=admin', true);xhr.send(); 123456789101112131415// server.jsvar http = require('http');var server = http.createServer();var qs = require('querystring');server.on('request', function(req, res) &#123; var params = qs.parse(req.url.substring(2)); // 向前台写cookie res.writeHead(200, &#123; 'Set-Cookie': 'l=a123456;Path=/;Domain=www.domain2.com;HttpOnly' // HttpOnly:脚本无法读取 &#125;); res.write(JSON.stringify(params)); res.end();&#125;);server.listen('8080');console.log('Server is running at port 8080...'); window.name + iframewindow.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。 其中a.html和b.html是同域的，都是http://localhost:3000;而c.html是http://localhost:4000 12345678910111213141516&lt;iframe src="http://localhost:4000/c.html" frameborder="0" onload="load()" id="iframe"&gt;&lt;/iframe&gt; &lt;script&gt; let first = true // onload事件会触发2次，第1次加载跨域页，并留存数据于window.name function load() &#123; if(first)&#123; // 第1次onload(跨域页)成功后，切换到同域代理页面 let iframe = document.getElementById('iframe'); iframe.src = 'http://localhost:3000/b.html'; first = false; &#125;else&#123; // 第2次onload(同域b.html页)成功后，读取同域window.name中数据 console.log(iframe.contentWindow.name); &#125; &#125; &lt;/script&gt; b.html为中间代理页，与a.html同域，内容为空。 1234// c.html(http://localhost:4000/c.html) &lt;script&gt; window.name = '我不爱你' &lt;/script&gt; 总结：通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。 location.hash + iframe实现原理： a.html欲与c.html跨域相互通信，通过中间页b.html来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。 具体实现步骤：一开始a.html给c.html传一个hash值，然后c.html收到hash值后，再把hash值传递给b.html，最后b.html将结果放到a.html的hash值中。 同样的，a.html和b.html是同域的，都是http://localhost:3000;而c.html是http://localhost:4000 1234567// a.html &lt;iframe src="http://localhost:4000/c.html#iloveyou"&gt;&lt;/iframe&gt; &lt;script&gt; window.onhashchange = function () &#123; //检测hash的变化 console.log(location.hash); &#125; &lt;/script&gt; 12345// b.html &lt;script&gt; window.parent.parent.location.hash = location.hash //b.html将结果放到a.html的hash值中，b.html可通过parent.parent访问a.html页面 &lt;/script&gt; 12345// c.htmlconsole.log(location.hash); let iframe = document.createElement('iframe'); iframe.src = 'http://localhost:3000/b.html#idontloveyou'; document.body.appendChild(iframe); document.domain + iframe该方式只能用于二级域名相同的情况下，比如 a.test.com 和 b.test.com 适用于该方式。 只需要给页面添加 document.domain =&#39;test.com&#39; 表示二级域名都相同就可以实现跨域。 实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。 我们看个例子：页面a.zf1.cn:3000/a.html获取页面b.zf1.cn:3000/b.html中a的值 1234567891011// a.html&lt;body&gt; helloa &lt;iframe src="http://b.zf1.cn:3000/b.html" frameborder="0" onload="load()" id="frame"&gt;&lt;/iframe&gt; &lt;script&gt; document.domain = 'zf1.cn' function load() &#123; console.log(frame.contentWindow.a); &#125; &lt;/script&gt;&lt;/body&gt; 12345678// b.html&lt;body&gt; hellob &lt;script&gt; document.domain = 'zf1.cn' var a = 100; &lt;/script&gt;&lt;/body&gt;总结 CORS支持所有类型的HTTP请求，是跨域HTTP请求的根本解决方案 JSONP只支持GET请求，JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。 不管是Node中间件代理还是nginx反向代理，主要是通过同源策略对服务器不加限制。 日常工作中，用得比较多的跨域方案是cors和nginx反向代理]]></content>
  </entry>
  <entry>
    <title><![CDATA[浏览器渲染原理]]></title>
    <url>%2F2019%2F08%2F21%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[浏览器的内核是指支持浏览器运行的最核心的程序，分为两个部分的，一是渲染引擎，二是JS引擎。渲染引擎在不同的浏览器中也不是都相同的。目前市面上常见的柳然其内核可以分为这四种：Trident（IE）、Gecko（Firefox)、Blink（Chrome、Opera）、Webkit（Safari）。这里面大家最耳熟能详的应该是Webkit内核了，Webkit内核时当下浏览器最好的内核。 本文我就以Webkit为例，对现代浏览器的渲染过程进行一个深度的剖析。 页面加载过程在介绍浏览器渲染过程之前，我们简明扼要介绍下页面的加载过程，有助于更好理解后续渲染过程。 要点如下： 浏览器根据 DNS 服务器得到域名的 IP 地址。 向这个 IP 的机器发送 HTTP 请求 服务器收到、处理并返回 HTTP 请求 浏览器得到返回内容例如在浏览器输入https://juejin.im/timeline，然后经过 DNS 解析，juejin.im对应的 IP 是36.248.217.149（不同时间、地点对应的 IP 可能会不同）。然后浏览器向该 IP 发送 HTTP 请求。 服务端接收到 HTTP 请求，然后经过计算（向不同的用户推送不同的内容），返回 HTTP 请求，返回的内容如下：其实就是一堆 HMTL 格式的字符串，因为只有 HTML 格式浏览器才能正确解析，这是 W3C 标准的要求。接下来就是浏览器的渲染过程。 浏览器渲染过程 浏览器渲染过程大体分为如下三部分： 浏览器会解析三个东西： 一是HTML/SVG/XHTML，HTML字符串描述了一个页面的结构，浏览器会把HTML结构字符串解析转换DOM树形结构。 二是CSS，解析CSS会产生CSS规则树，它和DOM结构比较像。 三是Javascript脚本，等到Javascript 脚本文件加载后， 通过 DOM API 和 CSSOM API 来操作 DOM Tree 和 CSS Rule Tree。 解析完成后，浏览器引擎会通过DOM Tree和CSS Rule Tree来构造Rendering Tree。 Render Tree渲染树并不等同于DOM树，渲染树只会包括需要显示的节点和这些节点的样式信息。 CSS的Rule Tree主要是为了完成匹配并把CSS Rule附加上Rendering Tree上的每个ELement（也就是每个Frame）。 然后，计算每个Frame的位置，这又叫layout和reflow的过程 最好通过调用操作系统Native GUI的API绘制 接下来我们针对这其中所经历的重要步骤详细阐述 构建DOM浏览器会遵守一套步骤将HTML文件转换为DOM树。宏观上，可以分为几个步骤： 浏览器从磁盘或网络读取HTML的原始字节，并根据文件的指定编码（例如UTF-8）将它们转换成字符串。 在网络中传输的内容其实都是0与1这些字节数据，当浏览器接收到这些字节数据以后，它会将这些字节数据转换字符串，也就是我们写的代码。 将字符串转换Token，例如：、等。Token中会标识出当前Token是“开始标签”或是“结束标签”亦或是“文本”等信息。L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"log":false}); 这时候你一定会有疑问，节点与节点之间的关系如何维护？ 事实上，这就是Token要标识“起始标签”和“结束标签”等标识的作用。例如“title”Token的起始标签和结束标签之间的节点肯定是属于“head”的子节点 上图给出了节点之间的关系，例如：“Hello”Token位于“title”开始标签与“title”结束标签之间，表明“Hello”Token是“title”Token的子节点。同理“title”Token是“head”Token的子节点。 生成节点对象并构建DOM 事实上，构建DOM的过程中，不是等所有Token都转换完成后再去生成节点对象，而是一边生成Token一边消耗Token来生成节点对象。换句话说，每个Token被生成后，会立刻消耗这个Token创建出节点对象。注意：带有结束标签标识的Token不会创建节点对象。 接下来我们举个例子，假设有段HTML文本： 1234567891011&lt;html&gt;&lt;head&gt; &lt;title&gt;Web page parsing&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;h1&gt;Web page parsing&lt;/h1&gt; &lt;p&gt;This is an example Web page.&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 上面这段HTML会解析成这样： 构建CSSOMDOM会捕获页面的内容，但浏览器还需要知道页面如何展示，所以需要构建CSSOM。 构建CSSOM的过程与构建DOM的过程非常相似，当浏览器接收到一段CSS，浏览器首先要做的是识别出Token，然后构建节点并生成CSSOM。 在这一过程中，浏览器会确定下每一个节点的样式到底是什么，并且这一过程其实是很消耗资源的。因为样式你可以自行设置给某个节点，也可以通过继承获得。在这一过程中，浏览器得递归 CSSOM 树，然后确定具体的元素到底是什么样式。 注意：CSS匹配HTML元素是一个相当复杂和有性能问题的事情。所以，DOM树要小，CSS尽量用id和class，千万不要过渡层叠下去。 构架渲染树当我们生成 DOM 树和 CSSOM 树以后，就需要将这两棵树组合为渲染树。 在这一过程中，不是简单的将两者合并就行了。渲染树只会包括需要显示的节点和这些节点的样式信息，如果某个节点是 display: none 的，那么就不会在渲染树中显示。 我们或许有个疑惑：浏览器如果渲染过程中遇到JS文件怎么处理？ 渲染过程中，如果遇到&lt;script&gt;就停止渲染，执行 JS 代码。因为浏览器有GUI渲染线程与JS引擎线程，为了防止渲染出现不可预期的结果，这两个线程是互斥的关系。JavaScript的加载、解析与执行会阻塞DOM的构建，也就是说，在构建DOM时，HTML解析器若遇到了JavaScript，那么它会暂停构建DOM，将控制权移交给JavaScript引擎，等JavaScript引擎运行完毕，浏览器再从中断的地方恢复DOM构建。 也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。当然在当下，并不是说 script 标签必须放在底部，因为你可以给 script 标签添加 defer 或者 async 属性（下文会介绍这两者的区别）。 JS文件不只是阻塞DOM的构建，它会导致CSSOM也阻塞DOM的构建。 原本DOM和CSSOM的构建是互不影响，井水不犯河水，但是一旦引入了JavaScript，CSSOM也开始阻塞DOM的构建，只有CSSOM构建完毕后，DOM再恢复DOM构建。 这是什么情况？ 这是因为JavaScript不只是可以改DOM，它还可以更改样式，也就是它可以更改CSSOM。因为不完整的CSSOM是无法使用的，如果JavaScript想访问CSSOM并更改它，那么在执行JavaScript时，必须要能拿到完整的CSSOM。所以就导致了一个现象，如果浏览器尚未完成CSSOM的下载和构建，而我们却想在此时运行脚本，那么浏览器将延迟脚本执行和DOM构建，直至其完成CSSOM的下载和构建。也就是说，在这种情况下，浏览器会先下载和构建CSSOM，然后再执行JavaScript，最后在继续构建DOM。 布局与绘制当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动重排”。 布局流程的输出是一个“盒模型”，它会精确地捕获每个元素在视口内的确切位置和尺寸，所有相对测量值都将转换为屏幕上的绝对像素。 布局完成后，浏览器会立即发出“Paint Setup”和“Paint”事件，将渲染树转换成屏幕上的像素。 以上我们详细介绍了浏览器工作流程中的重要步骤，接下来我们讨论几个相关的问题： 几点补充说明 async和defer的作用是什么？有什么区别? 接下来我们对比下 defer 和 async 属性的区别： 其中蓝色线代表JavaScript加载；红色线代表JavaScript执行；绿色线代表 HTML 解析。 1）情况1&lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt;没有 defer 或 async，浏览器会立即加载并执行指定的脚本，也就是说不等待后续载入的文档元素，读到就加载并执行。 2）情况2&lt;script async src=&quot;script.js&quot;&gt;&lt;/script&gt; (异步下载)async 属性表示异步执行引入的 JavaScript，与 defer 的区别在于，如果已经加载好，就会开始执行——无论此刻是 HTML 解析阶段还是 DOMContentLoaded 触发之后。需要注意的是，这种方式加载的 JavaScript 依然会阻塞 load 事件。换句话说，async-script 可能在 DOMContentLoaded 触发之前或之后执行，但一定在 load 触发之前执行。 3）情况3 &lt;script defer src=&quot;script.js&quot;&gt;&lt;/script&gt;(延迟执行)defer 属性表示延迟执行引入的 JavaScript，即这段 JavaScript 加载时 HTML 并未停止解析，这两个过程是并行的。整个 document 解析完毕且 defer-script 也加载完成之后（这两件事情的顺序无关），会执行所有由 defer-script 加载的 JavaScript 代码，然后触发 DOMContentLoaded 事件。 defer 与相比普通 script，有两点区别：载入 JavaScript 文件时不阻塞 HTML 的解析，执行阶段被放到 HTML 标签解析完成之后。在加载多个JS脚本的时候，async是无顺序的加载，而defer是有顺序的加载。 为什么操作 DOM 慢 把 DOM 和 JavaScript 各自想象成一个岛屿，它们之间用收费桥梁连接。——《高性能 JavaScript》 JS 是很快的，在 JS 中修改 DOM 对象也是很快的。在JS的世界里，一切是简单的、迅速的。但 DOM 操作并非 JS 一个人的独舞，而是两个模块之间的协作。 因为 DOM 是属于渲染引擎中的东西，而 JS 又是 JS 引擎中的东西。当我们用 JS 去操作 DOM 时，本质上是 JS 引擎和渲染引擎之间进行了“跨界交流”。这个“跨界交流”的实现并不简单，它依赖了桥接接口作为“桥梁”（如下图）。 过“桥”要收费——这个开销本身就是不可忽略的。我们每操作一次 DOM（不管是为了修改还是仅仅为了访问其值），都要过一次“桥”。过“桥”的次数一多，就会产生比较明显的性能问题。因此“减少 DOM 操作”的建议，并非空穴来风。 你真的了解回流和重绘吗 渲染的流程基本上是这样（如下图黄色的四个步骤）：1.计算CSS样式 2.构建Render Tree 3.Layout – 定位坐标和大小 4.正式开画 注意：上图流程中有很多连接线，这表示了Javascript动态修改了DOM属性或是CSS属性会导致重新Layout，但有些改变不会重新Layout，就是上图中那些指到天上的箭头，比如修改后的CSS rule没有被匹配到元素。 这里重要要说两个概念，一个是Reflow，另一个是Repaint 重绘：当我们对 DOM 的修改导致了样式的变化、却并未影响其几何属性（比如修改了颜色或背景色）时，浏览器不需重新计算元素的几何属性、直接为该元素绘制新的样式（跳过了上图所示的回流环节）。 回流：当我们对 DOM 的修改引发了 DOM 几何尺寸的变化（比如修改元素的宽、高或隐藏元素等）时，浏览器需要重新计算元素的几何属性（其他元素的几何属性和位置也会因此受到影响），然后再将计算的结果绘制出来。这个过程就是回流（也叫重排） 我们知道，当网页生成的时候，至少会渲染一次。在用户访问的过程中，还会不断重新渲染。重新渲染会重复回流+重绘或者只有重绘。回流必定会发生重绘，重绘不一定会引发回流。重绘和回流会在我们设置节点样式时频繁出现，同时也会很大程度上影响性能。回流所需的成本比重绘高的多，改变父节点里的子节点很可能会导致父节点的一系列回流。 1）常见引起回流属性和方法任何会改变元素几何信息(元素的位置和尺寸大小)的操作，都会触发回流， 添加或者删除可见的DOM元素； 元素尺寸改变——边距、填充、边框、宽度和高度 内容变化，比如用户在input框中输入文字 浏览器窗口尺寸改变——resize事件发生时 计算 offsetWidth 和 offsetHeight 属性 设置 style 属性的值 2）常见引起重绘属性和方法 3）如何减少回流、重绘 使用 transform 替代 top 使用 visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回流（改变了布局） 不要把节点的属性值放在一个循环里当成循环里的变量。 1234for(let i = 0; i &lt; 1000; i++) &#123; // 获取 offsetTop 会导致回流，因为需要去获取正确的值 console.log(document.querySelector(&apos;.test&apos;).style.offsetTop)&#125; 不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局 动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 requestAnimationFrame CSS 选择符从右往左匹配查找，避免节点层级过多 将频繁重绘或者回流的节点设置为图层，图层能够阻止该节点的渲染行为影响别的节点。比如对于 video 标签来说，浏览器会自动将该节点变为图层。 性能优化策略基于上面介绍的浏览器渲染原理，DOM 和 CSSOM 结构构建顺序，初始化可以对页面渲染做些优化，提升页面性能。 JS优化： 1&lt;script&gt; 标签加上 defer属性 和 async属性 用于在不阻塞页面文档解析的前提下，控制脚本的下载和执行。 defer属性： 用于开启新的线程下载脚本文件，并使脚本在文档解析完成后执行。 async属性： HTML5新增属性，用于异步下载脚本文件，下载完毕立即解释执行代码。 CSS优化： &lt;link&gt; 标签的 rel属性 中的属性值设置为 preload 能够让你在你的HTML页面中可以指明哪些资源是在页面加载完成后即刻需要的,最优的配置加载顺序，提高渲染性能 总结综上所述，我们得出这样的结论： 浏览器工作流程：构建DOM -&gt; 构建CSSOM -&gt; 构建渲染树 -&gt; 布局 -&gt; 绘制。 CSSOM会阻塞渲染，只有当CSSOM构建完毕后才会进入下一个阶段构建渲染树。 通常情况下DOM和CSSOM是并行构建的，但是当浏览器遇到一个不带defer或async属性的script标签时，DOM构建将暂停，如果此时又恰巧浏览器尚未完成CSSOM的下载和构建，由于JavaScript可以修改CSSOM，所以需要等CSSOM构建完毕后再执行JS，最后才重新DOM构建。]]></content>
  </entry>
  <entry>
    <title><![CDATA[从URL输入到页面展现]]></title>
    <url>%2F2019%2F08%2F19%2F%E4%BB%8EURL%E8%BE%93%E5%85%A5%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[在浏览器中输入URL到整个页面显示在用户面前时这个过程中到底发生了什么？经历怎样的一个过程？ 总体来说分为以下几个过程： DNS解析：将域名分析成IP地址 TCP连接：TCP三次握手 发生HTTP请求 服务器处理请求并返回HTTP报文 浏览器解析渲染页面 断开连接：TCP四次握手 URL到底是啥URL（Uniform Resource Locator），统一资源定位符，用来定位互联网资源，俗称网址。 1scheme://host.domain:port/path/filename 各部分解释如下： scheme - 定义因特网服务的类型。常见的协议有http、https、ftp和file，其中最常见的类型是http，而https则是进行加密的网络传输。 host - 定义域主机(http的默认主机是www)。 domain - 定义因特网域名，比如w3school.com.cn。 port - 定义主机上的端口号（http的默认端口是80）。 path - 定义服务器上的路径（如果省略，则文档必须位于网站的根目录中）。 filename - 定义文档/资源的名称。 域名解析（DNS）在浏览器输入网址后，首先要经过域名解析，因为浏览器并不能直接通过域名找到对应的服务器，而是要通过IP地址。大家这里或许会有个疑问——计算机既可以被赋予IP地址，又可以被赋予主机名和域名。那怎么不一开始就赋予个 IP 地址？这样就可以省去解析麻烦。我们先来了解下什么是 IP 地址。 IP地址 IP地址是指互联网协议地址，是IP Address的缩写。IP地址是IP协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。IP地址是一个32位的二进制数，比如127.0.0.1为本机地址。 什么是域名解析 DNS协议提供通过域名查找IP地址，或逆向从IP地址反查找域名的服务。DNS是一个网络服务器，我们的域名解析简单来说就是在DNS上记录一条信息记录。 1例如 baidu.com 220.114.23.56（服务器外网IP地址）80（服务器端口号） 浏览器如何通过域名去查询URL对应的IP呢 浏览器缓存：浏览器会按照一定的频率缓存DNS记录。 操作系统缓存：如果浏览器缓存中找不到需要的DNS记录，那就去操作系统中找。 路由缓存：路由器也是有DNS缓存的。 ISP的DNS服务器：ISP是互联网服务提供商（Internet Service Provider）的简称，ISP有专门的DNS服务器应对DNS查询请求。 根服务器：ISP的DNS服务器还找不到的话，它就会向根服务器发出请求，进行递归查询（DNS 服务器先问根域名服务器.com 域名服务器的 IP 地址，然后再问.baidu 域名服务器，依次类推）。 小结 浏览器通过向 DNS 服务器发送域名，DNS 服务器查询到与域名相对应的 IP 地址，然后返回给浏览器，浏览器再将 IP 地址打在协议上，同时请求参数也会在协议搭载，然后一并发送给对应的服务器。接下来介绍向服务器发送 HTTP 请求阶段，HTTP 请求分为三个部分：TCP 三次握手、http 请求响应信息、关闭 TCP 连接。 TCP三次握手在客户端发送数据之前会发起 TCP 三次握手用以同步客户端和服务端的序列号和确认号，并交换 TCP 窗口大小信息。 TCP三次握手的过程如下： 客户端发送一个带SYN，Seq=X的数据包到服务器端口（第一次握手，由浏览器发起，告诉服务器我要发送请求了）。 服务器发回一个带 SYN=1， ACK=X+1， Seq=Y 的响应包以示传达确认信息（第二次握手，由服务器发起，告诉浏览器我准备接受了，你赶紧发送吧）。 客户端再回传一个带 ACK=Y+1， Seq=Z 的数据包，代表“握手结束”（第三次握手，由浏览器发送，告诉服务器，我马上就发了，准备接受吧）。 为什么需要三次握手 谢希仁著《计算机网络》中讲“三次握手”的目的是“为了防止已失效的连接请求报文段突然又传送到服务器端，因而产生错误”。 发送HTTP请求TCP三次握手结束后，开始发送HTTP请求报文。 请求报文由请求行（request line）、请求头（header）、空行、请求体四个部分组成，如下图所示： 请求行包含请求方法、URL、协议版本 请求方法包含8种：GET、POST、PUT、DELETE、PATCH、HEAD、OPTIONS、TRACE。 URL即请求地址，由&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;&lt;参数&gt;组成 协议版本即http版本号 1POST /chapter17/user.html HTTP/1.1 以上代码中“POST”代表请求方法，“/chapter17/user.html”表示 URL，“HTTP/1.1”代表协议和协议的版本。现在比较流行的是 Http1.1 版本。 请求头包含请求的附加信息，由关键字/值对组成，每行一对，关键字和值由英文冒号“:”分割。 请求头部通知服务器有关客户端请求的信息。它包含许多有关的客户端环境和请求正文的有用信息。其中比如：Host，表示主机名，虚拟主机；Connection，HTTP/1.1增加的，使用keep-alive，即持续连接，一个链接可以发送多个请求；User-Agent，请求发送者，兼容性以及定制化需求。 请求体，可以承载多个请求参数的数据，包含回车符、换行符和请求数据，并不是所有请求都具有请求数据。 1name=tom&amp;password=1234&amp;realName=tomson 上面代码，承载着 name、password、realName 三个请求参数。 服务器处理请求并返回HTTP报文 服务器 服务器是网络环境中的高性能计算机，它侦听网络上的其他计算机（客户机）提交的服务请求，并提供相应的服务，比如网页服务、文件下载服务、邮件服务、视频服务。而客户端主要的功能是浏览网页、看视频、听音乐等等，两者截然不同。 每台服务器上都会安装处理请求的应用——web server。常见的 web server 产品有 apache、nginx、IIS 或 Lighttpd 等。web server 担任管控的角色，对于不同用户发送的请求，会结合配置文件，把不同请求委托给服务器上处理相应请求的程序进行处理（例如 CGI 脚本，JSP 脚本，servlets，ASP 脚本，服务器端 JavaScript，或者一些其它的服务器端技术等），然后返回后台程序处理产生的结果作为响应。 2.MVC 后台处理阶段 后台开发现在有很多框架，但大部分都还是按照 MVC 设计模式进行搭建的。 MVC 是一个设计模式，将应用程序分成三个核心部件：模型（model）– 视图（view）–控制器（controller），它们各自处理自己的任务，实现输入、处理和输出的分离。 3.http 响应报文 响应报文由响应行（request line）、响应头部（header）、响应主体三个部分组成。如下图所示： 响应行包含：协议版本，状态码，状态码描述 状态码规则如下：1xx：指示信息–表示请求已接收，继续处理。2xx：成功–表示请求已被成功接收、理解、接受。3xx：重定向–要完成请求必须进行更进一步的操作。4xx：客户端错误–请求有语法错误或请求无法实现。5xx：服务器端错误–服务器未能实现合法的请求。 响应头部包含响应报文的附加信息，由 名/值 对组成 响应主体包含回车符、换行符和响应返回数据，并不是所有响应报文都有响应数据 浏览器解析渲染页面浏览器拿到响应文本HTML后，接下来介绍下浏览器渲染机制 浏览器解析渲染页面分为以下五个步骤： 根据HTML解析出DOM树 根据CSS解析生成CSS规则树 结合DOM树和CSS规则树，生成渲染树 根据渲染树计算每一个节点的信息 根据计算好的信息绘制页面 根据HTML解析DOM树 根据HTML的内容，将标签按照结构解析成为DOM树，DOM树解析的过程是一个深度优先遍历，即先构建当前节点的所有子节点，再构建下一个兄弟节点。 再读取HTML文档，构建DOM树的过程中，若遇到script标签则DOM树的构建会暂停，直到脚本执行完毕。 根据CSS解析生成CSS规则树 解析CSS规则树时js执行将暂停，直到CSS规则树就绪 浏览器在CSS规则树生成之前不会进行渲染 结合DOM树和CSS规则树，生成渲染树 DOM 树和 CSS 规则树全部准备好了以后，浏览器才会开始构建渲染树。 精简 CSS 并可以加快 CSS 规则树的构建，从而加快页面相应速度。 根据渲染树计算每一个节点的信息（布局） 布局：通过渲染树中渲染对象的信息，计算出每一个渲染对象的位置和尺寸 回流：在布局完成后，发现了某个部分发生了变化影响了布局，那就需要倒回去重新渲染 根据计算好的信息绘制页面 绘制阶段，系统会遍历呈现树，并调用呈现器的“paint”方法，将呈现器的内容显示在屏幕上。 重绘：某个元素的背景颜色，文字颜色等，不影响元素周围或内部布局的属性，将只会引起浏览器的重绘。 回流：某个元素的尺寸发生了变化，则需重新计算渲染树，重新渲染。 断开连接当数据传送完毕，需要断开 tcp 连接，此时发起 tcp 四次挥手 发起方向被动方发送报文，Fin、Ack、Seq，表示已经没有数据传输了。并进入 FIN_WAIT_1 状态。(第一次挥手：由浏览器发起的，发送给服务器，我请求报文发送完了，你准备关闭吧) 被动方发送报文，Ack、Seq，表示同意关闭请求。此时主机发起方进入 FIN_WAIT_2 状态。(第二次挥手：由服务器发起的，告诉浏览器，我请求报文接受完了，我准备关闭了，你也准备吧) 被动方向发起方发送报文段，Fin、Ack、Seq，请求关闭连接。并进入 LAST_ACK 状态。(第三次挥手：由服务器发起，告诉浏览器，我响应报文发送完了，你准备关闭吧) 发起方向被动方发送报文段，Ack、Seq。然后进入等待 TIME_WAIT 状态。被动方收到发起方的报文段以后关闭连接。发起方等待一定时间未收到回复，则正常关闭。(第四次挥手：由浏览器发起，告诉服务器，我响应报文接受完了，我准备关闭了，你也准备吧)]]></content>
  </entry>
  <entry>
    <title><![CDATA[如何居中一个元素]]></title>
    <url>%2F2019%2F08%2F18%2F%E5%A6%82%E4%BD%95%E5%B1%85%E4%B8%AD%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[水平居中行内元素水平居中利用text-align:center可以实现在块级元素内部的行内元素水平居中。此方法对inline、inline-block、inline-table和inline-flex元素水平居中都有效。 123.parent&#123;//在父容器设置 text-align:center; &#125; 此外，如果块级元素内部包着也是一个块级元素，我们可以先将其有块级元素改变为行内块元素，再通过设置行内块元素居中以达到水平居中。 1234567891011&lt;div class="parent"&gt; &lt;div class="child"&gt;Demo&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .parent&#123; text-align:center; &#125; .child &#123; display: inline-block; &#125;&lt;/style&gt; 块级元素的水平居中这种情形可以有多种实现方式，下面我们详细介绍： 将该块级元素左右外边距margin-left和margin-right设置为auto 1234.child&#123; width: 100px;//确保该块级元素定宽 margin:0 auto;&#125; 使用table+margin 先将子元素设置为块级表格来显示（类似），再将其设置水平居中。display:table在表现上类似block元素，但是宽度为内容宽。 123456789&lt;div class="parent"&gt; &lt;div class="child"&gt;Demo&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .child &#123; display: table; margin: 0 auto; &#125;&lt;/style&gt; 使用absolute+transform 先将父元素设置为相对定位，再将子元素设置为绝对定位，向右移动子元素，移动距离为父容器的一半，最后通过向左移动子元素的一半宽度以达到水平居中。 12345678910111213&lt;div class="parent"&gt; &lt;div class="child"&gt;Demo&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .child &#123; position:absolute; left:50%; transform:translateX(-50%); &#125; .parent &#123; position:relative; &#125;&lt;/style&gt; 不过transform属于css3内容，兼容性存在一定问题，高版本浏览器需要添加一些前缀。 使用flex+justify-content 通过CSS3中的布局利器flex中的justify-content属性来达到水平居中。 123456789&lt;div class="parent"&gt; &lt;div class="child"&gt;Demo&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .parent &#123; display: flex; justify-content:center; &#125;&lt;/style&gt; 使用flex-margin 通过flex将父容器设置为flex布局，再设置子元素居中。 1234567891011&lt;div class="parent"&gt; &lt;div class="child"&gt;Demo&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .parent &#123; display: flex; &#125; .child &#123; margin:0 auto; &#125;&lt;/style&gt; 多块级元素水平居中 利用flex布局 利用弹性布局(flex)，实现水平居中，其中justify-content用于设置弹性盒子元素在主轴(默认横轴)方向上的对齐方式，本例中设置子元素水平居中显示。 1234 #container &#123; display: flex; justify-content: center;&#125; 利用inline-block 将要水平排列的块级元素设为display:inline-block，然后在父级元素上设置text-align:center，达到与上面的行内元素的水平居中一样的效果。 123456.container &#123; text-align: center;&#125;.inline-block &#123; display: inline-block;&#125; 浮动元素水平居中 定宽的浮动元素，通过子元素设置relative+负margin 12345678.child &#123; position:relative; left:50%; margin-left:-250px;&#125;&lt;div class="parent"&gt; &lt;span class="child" style="float: left;width: 500px;"&gt;我是要居中的浮动元素&lt;/span&gt;&lt;/div&gt; 不定宽的浮动元素，父子容器都用相对定位 1234567891011121314&lt;div class="box"&gt; &lt;p&gt;我是浮动的&lt;/p&gt; &lt;p&gt;我也是居中的&lt;/p&gt;&lt;/div&gt;.box&#123; float:left; position:relative; left:50%;&#125;p&#123; float:left; position:relative; right:50%;&#125; 通用办法flex布局 利用弹性布局(flex)的justify-content属性，实现水平居中。 1234567891011.parent &#123; display:flex; justify-content:center;&#125;.chlid&#123; float: left; width: 200px;//有无宽度不影响居中&#125;&lt;div class="parent"&gt; &lt;span class="chlid"&gt;我是要居中的浮动元素&lt;/span&gt;&lt;/div&gt; 绝对定位元素水平居中 这种方式非常独特，通过子元素绝对定位，外加margin:0 auto来实现 123456789101112131415&lt;div class="parent"&gt; &lt;div class="child"&gt;让绝对定位的元素水平居中对齐。&lt;/div&gt;&lt;/div&gt; .parent&#123; position:relative; &#125; .child&#123; position: absolute; /*绝对定位*/ width: 200px; height:100px; background: yellow; margin: 0 auto; /*水平居中*/ left: 0; /*此处不能省略，且为0*/ right: 0;/*此处不能省略，且为0*/ &#125; 垂直居中单行内联元素垂直居中12345678910&lt;div id="box"&gt; &lt;span&gt;单行内联元素垂直居中。&lt;/span&gt;。&lt;/div&gt;&lt;style&gt; #box &#123; height: 120px; line-height: 120px; border: 2px dashed #f69c55; &#125;&lt;/style&gt; 多行内联元素垂直居中 利用flex布局 利用flex布局实现垂直居中，其中flex-direction:column定义主轴为纵向。这种方式在较老的浏览器存在兼容性问题。 1234567891011121314&lt;div class="parent"&gt; &lt;p&gt;Dance like nobody is watching, code like everybody is. Dance like nobody is watching, code like everybody is. Dance like nobody is watching, code like everybody is.&lt;/p&gt;&lt;/div&gt;&lt;style&gt; .parent &#123; height: 140px; display: flex; flex-direction: column; justify-content: center; border: 2px dashed #f69c55; &#125;&lt;/style&gt; 块级元素垂直居中 使用absolute+负margin(已知高度宽度) 通过绝对定位元素距离顶部50%，并设置margin-top向上偏移元素高度的一半，就可以实现了。 123456789101112&lt;div class="parent"&gt; &lt;div class="child"&gt;固定高度的块级元素垂直居中。&lt;/div&gt;&lt;/div&gt;.parent &#123; position: relative;&#125;.child &#123; position: absolute; top: 50%; height: 100px; margin-top: -50px;&#125; 使用absolute+tranform 当垂直居中的元素的高度和宽度未知时，可以借助CSS3的transform属性向Y轴反向偏移50%的方法实现垂直居中。但是部分浏览器存在兼容性的问题 1234567891011&lt;div class="parent"&gt; &lt;div class="child"&gt;未知高度的块级元素垂直居中。&lt;/div&gt;&lt;/div&gt;.parent &#123; position: relative;&#125;.child &#123; position: absolute; top: 50%; transform: translateY(-50%);&#125; 使用flex+align-items 通过设置flex布局中的属性align-items，使子元素垂直居中。 1234567&lt;div class="parent"&gt; &lt;div class="child"&gt;未知高度的块级元素垂直居中。&lt;/div&gt;&lt;/div&gt;.parent &#123; display:flex; align-items:center;&#125; 使用table-cell+vertical-align 通过将父元素转化为一个表格单元格显示（类似 和 ），再通过设置 vertical-align属性，使表格单元格内容垂直居中。 123456789&lt;div class="parent"&gt; &lt;div class="child"&gt;Demo&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .parent &#123; display: table-cell; vertical-align: middle; &#125;&lt;/style&gt; 水平垂直居中绝对定位与负边距实现(已知高度宽度) 这种方式需要知道被垂直居中元素的高和宽，才能计算出margin值，兼容所有浏览器 12345678910// css部分 #container &#123; position: relative; &#125; #center &#123; position: absolute; top: 50%; left: 50%; margin: -50px 0 0 -50px; &#125; 123456// html部分(这部分不做变化,下面例子直接共用)&lt;body&gt; &lt;div id='container'&gt; &lt;div id='center' style="width: 100px;height: 100px;background-color: #666"&gt;center&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;绝对定位与matgin：auto(已知高度宽度)这种方式无序知道被垂直居中元素的高和宽，但不能兼容低版本的IE浏览器 ​123456789101112#container &#123; position: relative; height:100px;//必须有个高度 &#125;#center &#123; position: absolute; top: 0; left: 0; right: 0; bottom: 0; margin: auto;//注意此处的写法 &#125; 绝对定位+CSS3(未知元素的高宽)利用CSS3的transform，可以轻松的在未知元素的高度的情况下实现元素的垂直居中。 123456789#container &#123; position: relative; &#125;#center &#123; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); &#125; flex布局利用flex布局，其中justify-content用于设置或检索弹性盒子元素在主轴(横轴)方向上的对齐方式，而align-items属性定义flex子项在容器的当前行的侧轴(纵轴)方向上的对齐方式。不兼容低版本的IE浏览器。 123456#container &#123;//直接在父容器设置即可 height: 100vh;//必须有高度 display: flex; justify-content: center; align-items: center; &#125; flex/grid与margin：auto(最简单写法)容器元素设为flex布局或是grid布局，子元素只要写margin：auto即可，不能兼容低版本的IE浏览器 1234567#container &#123; height: 100vh;//必须有高度 display: grid; &#125; #center &#123; margin: auto; &#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[懒加载和预加载]]></title>
    <url>%2F2019%2F08%2F16%2F%E6%87%92%E5%8A%A0%E8%BD%BD%E5%92%8C%E9%A2%84%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[懒加载什么是懒加载懒加载也叫延迟加载，指的是在长网页中延迟加载图像，是一种很好优化网页性能的方式。 用户滚动到他们之前，可视区域外的图像不会加载。这与图像预加载相反，在长网页上使用延迟加载将使网页加载更快。在某些情况下，它还可以帮助减少服务器负载。常适用图片很多，页面很长的电商网站场景中。 为什么要用懒加载 能提升用户的体验，不妨设想下，用户打开想手机淘宝长页面的时候，如果页面上所有的图片都需要加载，由于图片数目较大，等待时间很长，用户难免会心生抱怨，这就严重影响用户体验。 减少无效资源的加载，这样能明显减少服务器的压力和流量，也能够减少浏览器的负担。 防止并发加载的资源过多会阻塞js的加载，影响网站的正常使用。 懒加载的原理首先将页面上的图片的src属性设为空字符串，而图片的真实路径则设置在data-original属性中，当页面滚动的时候需要去监听scroll事件，在scrool事件的回调中，判断我们的懒加载的图片是否进入可视区域，如果图片在可视区内将图片的src属性设置为data-original的值，这样就可以实现延迟加载。 懒加载实现步骤12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Lazyload&lt;/title&gt; &lt;style&gt; .image-item &#123; display: block; margin-bottom: 50px; height: 200px;//一定记得设置图片高度 &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;img src="" class="image-item" lazyload="true" data-original="images/1.png"/&gt;&lt;img src="" class="image-item" lazyload="true" data-original="images/2.png"/&gt;&lt;img src="" class="image-item" lazyload="true" data-original="images/3.png"/&gt;&lt;img src="" class="image-item" lazyload="true" data-original="images/4.png"/&gt;&lt;img src="" class="image-item" lazyload="true" data-original="images/5.png"/&gt;&lt;img src="" class="image-item" lazyload="true" data-original="images/6.png"/&gt;&lt;img src="" class="image-item" lazyload="true" data-original="images/7.png"/&gt;&lt;img src="" class="image-item" lazyload="true" data-original="images/8.png"/&gt;&lt;img src="" class="image-item" lazyload="true" data-original="images/9.png"/&gt;&lt;img src="" class="image-item" lazyload="true" data-original="images/10.png"/&gt;&lt;img src="" class="image-item" lazyload="true" data-original="images/11.png"/&gt;&lt;img src="" class="image-item" lazyload="true" data-original="images/12.png"/&gt;&lt;script&gt;var viewHeight =document.documentElement.clientHeight//获取可视区高度function lazyload()&#123; var eles=document.querySelectorAll（'img[data-original][lazyload]'）Array.prototype.forEach.call(eles,function(item,index)&#123;var rectif(item.dataset.original==="") returnrect=item.getBoundingClientRect()// 用于获得页面中某个元素的左，上，右和下分别相对浏览器视窗的位置if(rect.bottom&gt;=0 &amp;&amp; rect.top &lt; viewHeight)&#123;!function()&#123; var img=new Image() img.src=item.dataset.original img.onload=function()&#123; item.src=img.src &#125;item.removeAttribute（"data-original"）//移除属性，下次不再遍历item.removeAttribute（"lazyload"） &#125;() &#125; &#125;)&#125;lazyload()//刚开始还没滚动屏幕时，要先触发一次函数，初始化首页的页面图片document.addEventListener（"scroll"，lazyload)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 预加载什么是预加载资源预加载是另一个性能优化技术，我们可以使用该技术来预先告知浏览器某些资源可能会被使用到。预加载简单来说就是将所有所需的资源提取请求到本地，这样后面在需要用时就直接从缓存取资源。 为什么要用预加载在网页全部加载之前，对一些主要内容进行加载，以提供给用户更好的体验，减少等待的时间。否则，如果一个页面的内容过于庞大，没有使用预加载技术的页面就会长时间的展现为一片空白，直到所有内容加载完毕。 实现预加载的几种办法 使用HTML标签 1&lt;img src="http://pic26.nipic.com/20121213/6168183 0044449030002.jpg" style="display:none"/&gt; 使用Image对象 1&lt;script src="./myPreload.js"&gt;&lt;/script&gt; 123//myPreload.js文件var image= new Image()image.src="http://pic26.nipic.com/20121213/6168183 004444903000 2.jpg" 使用XMLHttpReq对象，虽然存在跨域问题，但会精细控制预加载过程 123456789101112131415161718var xmlhttprequest = new XMLHttpRequest()xmlhttprequest.onreadystatechange = callbackxmlhttprequest.onprogress = progressCallbackxmlhttprequest.open("GET", "http://image.baidu.com/mouse,jpg", true)xmlhttprequest.send()function callback() &#123; if(xmlhttprequest.readyState==4&amp;&amp; xmlhttprequest.status==200)&#123; var responseText=xmlhttprequest.responseText &#125;else&#123; console.log("Request was unsuccessful:"+xmlhttprequest.status) &#125;&#125;function progressCallback(e) &#123; e= e || event if(e.lengthComputable) &#123; console.log("Received"+e.loaded+"of"+e.total+"bytes") &#125;&#125; 使用PreloadJS库 PreloadJS提供了一种预加载内容的一致方式，以便在HTML应用程序中使用。预加载可以使用HTML标签以及XHR来完成。默认情况下，PreloadJS会尝试使用XHR加载内容，因为它提供对进度和完成事件的更好支持，但是由于跨域问题，使用基于标记的加载可能更好。 1234567891011//使用preload.jsvar queue=new createjs.LoadQueue();//默认是xhr对象，如果是new createjs.LoadQueue(false)是指使用HTML标签，可以跨域queue.on("complete",handleComplete,this);queue.loadManifest([&#123;id:"myImage",src:"http://pic26.nipic.com/20121213/6168183 0044449030002.jpg"&#125;,&#123;id："myImage2"，src:"http://pic9.nipic.com/20100814/2839526 1931471581702.jpg"&#125;]);function handleComplete()&#123; var image=queue.getResuLt("myImage"); document.body.appendChild(image);&#125; 懒加载和预加载的对比两者都是提高页面性能有效的办法，两者主要区别是一个提前加载，一个是延迟甚至不加载。懒加载对服务器端有一定的缓解压力作用，预加载则会增加服务器前端压力。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Markdown语法]]></title>
    <url>%2F2019%2F07%2F09%2FMarkdown%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[标题在想要设置为标题的文字面前加#来表示，一个#是一级标题，两个#是二级标题以此类推。支持六级标题。 注：标准语法一般在#后跟一个空格再写文。 示例： 123456# 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题###### 这是六级标题 效果如下： 字体斜体要倾斜的文字左右分别用一个*号抱起来 加粗要加粗的文字左右分别用两个*号抱起来 斜体加粗要倾斜和加粗的文字左右分别用三个*号包起来 删除线要加删除线的文字左右分别用两个~号包起来 示例： 1234*这是倾斜的文字***这是加粗的文字*****这是斜体加粗的文字***~~这是加删除线的文字~~ 效果如下： 这是倾斜的文字这是加粗的文字这是斜体加粗的文字这是加删除线的文字 引用在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt; 示例： 123&gt;这是引用的内容&gt;&gt;这是引用的内容&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容 效果如下： 这是引用的内容 这是引用的内容 这是引用的内容 分割线三个或三个以上的-或者*都可以。示例： 1234-------******* 效果如下： 可以看到，显示效果都是一样的。 图片语法： 123![图片alt](图片位置 "图片titlle")图片alt就是显示在图片下面的文字，相当于对图片内容的解释。图片titile是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加 示例： 12![blockchain](https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=702257389,1274025419&amp;fm=27&amp;gp=0.jpg "区块链") 效果如下： ![blockchain](https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=702257389,1274025419&amp;fm=27&amp;gp=0.jpg “区块链”) 超链接语法： 12[超链接](超链接地址 "超链接title")title 可加不可加 示例： 12[简书](http://jianshu.com)[百度](http://baidu.com) 效果如下： 简书百度 列表无序列表语法： 无序列表用-、+、*任何一种都可以。 12345- 列表内容+ 列表内容* 列表内容注意： - + * 跟内容之间都要有一个空格 效果如下： 列表内容 列表内容 列表内容 有序列表语法：数字加点 123451. 列表内容2. 列表内容3. 列表内容注意： 序号跟内容之间要有空格 效果如下： 列表内容 列表内容 列表内容 列表嵌套上一级与下一级之间桥三个空格即可 一级无序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 一级无序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 一级无序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 表格语法： 1234567891011表头|表头|表头---| :--: |---:内容|内容|内容内容|内容|内容第二行分割表头和内容。- 有一个就行，为了对齐，就多加了几个文字默认居左-两边加：表示文字居中-右边加：表示文字居右注意：原生的语法两边都要用 示例： 姓名 技能 排行 刘备 哭 大哥 关羽 打 二哥 张飞 骂 三弟 代码语法：单行代码： 代码之间分别用一个反引号抱起来 1`代码内容` 代码块： 代码之间分别用三个反引号包起来，且两边的反引号单独占一行。 12345(```)代码...代码...代码...(```) 注意： 为了防止转义，前后三个反引号处加了小括号，实际是没有的。 示例： 单行代码 1`create database hero;` 代码块： 123456(```) function fun()&#123; echo "这是一句非常牛逼的代码"; &#125; fun();(```) 效果如下： 单行代码 create database hero; 代码块： 1234function fun()&#123; echo "这是一句非常牛逼的代码";&#125;fun(); 流程图123456789(```)flowst=&gt;start: 开始op=&gt;operation: My Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op&amp;(```) 注意： 为了防止转义，前后三个反引号处加了小括号，实际是没有的。 效果如下： ```st=>start: 开始 op=>operation: My Operation cond=>condition: Yes or No? e=>end st->op->cond cond(yes)->e cond(no)->op &{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12} var code = document.getElementById("flowchart-0-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value)); var diagram = flowchart.parse(code); diagram.drawSVG("flowchart-0", options);]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F06%2F15%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
