<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ES6系列之私有变量的实现]]></title>
    <url>%2F2019%2F09%2F20%2FES6%E7%B3%BB%E5%88%97%E4%B9%8B%E7%A7%81%E6%9C%89%E5%8F%98%E9%87%8F%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[在阅读《ECMAScript6入门》的时候，零散的看到有私有变量的实现，所有在此总结一篇。 约定实现： 123456789101112131415class Example &#123; constructor() &#123; this._private = 'private' &#125; getName() &#123; return this._private &#125;&#125;var ex = new Example()console.log(ex.getName()) // privateconsole.log(ex._private) // private 优点： 写法简单 调试方便 兼容性好 缺点： 外部可以访问和修改 语言没有配合的机制，如for-in语句会将所有属性枚举出来 命名冲突 闭包实现一： 123456789101112class Example() &#123; constructor() &#123; var _private = '' _private = 'private' this.getName = function() &#123; return _private &#125; &#125;&#125;var ex = new Example()console.log(ex.getName()) // privateconsole.log(ex._private) // undefined 优点： 无命名冲突 外部无法访问和修改 缺点： constructor的逻辑变得复杂。构造函数应该只做对象初始化的事情，现在为了实现私有变量，必须包含部分方法的实现，代码组织上略不清晰。 方法存在于实例，而非原型上，子类也无法使用super调用。 构建增加一点点开销。 实现二： 12345678910111213141516171819const Examole = (function() &#123; var _private = '' class Example &#123; constructor() &#123; _private = 'private' &#125; getName() &#123; return _private &#125; &#125; return Example&#125;)()var ex = new Example()console.log(ex.getName()) // privateconsole.log(ex._private) // undefined 优点： 无命名冲突 外部无法访问和修改 缺点： 写法有一点复杂 构建增加一点点开销 Symbol实现： 123456789101112131415161718const Example = (function() &#123; var _private = Symbol('private') class Example &#123; constructor() &#123; this[_private] = 'privatw' &#125; getName() &#123; return this[_private] &#125; &#125; return Example&#125;)()var ex = new Example()console.log(ex.getName()) // privateconsole.log(ex.name) // undefined 优点： 无命名冲突 外部无法访问和修改 无性能损失 缺点： 写法稍微复杂 兼容性也还好 WeakMap实现： 123456789101112131415const _private = new WeakMap()class Example &#123; constructor() &#123; _private.set(this, 'private') &#125; getName() &#123; return _private.get(this) &#125;&#125;var ex = new Example()console.log(ex.getName()) // privateconsole.log(ex.name) // undefined 如果这样写，你可能觉得封装性不够，你也可以这样写： 12345678910111213141516171819const Example = (function() &#123; var _private = new WeakMap() class Example &#123; constructor() &#123; _private.set(this, 'private') &#125; getName() &#123; return _private.get(this) &#125; &#125; return Example&#125;)()var ex = new Example()console.log(ex.getName()) // privateconsole.log(ex.name) // undefined 优点： 无命名冲突 外部无法访问和修改 缺点： 写法比较麻烦 兼容性有点问题 有一定性能代价 最新提案12345678910111213class Point &#123; #x; #y; constructor(x, y) &#123; this.#x = x; this.#y = y; &#125; equals(point) &#123; return this.#x === point.#x &amp;&amp; this.#y === point.#y; &#125;&#125; 那么为什么不直接使用 private 字段呢？比如说这样： 1234567class Foo &#123; private value; equals(foo) &#123; return this.value === foo.value; &#125;&#125; 简单点来说，就是嫌麻烦，当然也有性能上的考虑…… 举个例子，如果我们不使用 #，而是使用 private 关键字： 123456789101112class Foo &#123; private value = '1'; equals(foo) &#123; return this.value === foo.value; &#125;&#125;var foo1 = new Foo();var foo2 = new Foo();console.log(foo1.equals(foo2)); 在这里我们新建了两个实例，然后将 foo2 作为参数传入了 foo1 的实例方法中。 那么我们可以获取 foo2.value 的值吗？如果我们直接 foo2.value 肯定是获取不到值的，毕竟是私有变量，可是 equals 是 Foo 的一个类方法，那么可以获取到的吗？ 答案是可以的。 其实这点在其他语言，比如说 Java 和 C++ 中也是一样的，类的成员函数中可以访问同类型实例的私有变量，这是因为私有是为了实现“对外”的信息隐藏，在类自己内部，没有必要禁止私有变量的访问，你也可以理解为私有变量的限制是以类为单位，而不是以对象为单位，此外这样做也可以为使用者带来便利。 既然获取值是可以的，那么打印的结果应该为 true，但是如果我们传入的值不是 Foo 的实例，而是一个其他对象呢？ 12345var foo1 = new Foo();console.log(foo1.equals(&#123; value: 2&#125;)); 当然这里代码也是可以正常运行的，但是对于编译器来说，就有一点麻烦了，因为编译器不知道 value 到底是 foo 的正常属性还是私有属性，所以编译器需要做判断，先判断 foo 是不是 Foo 的实例，然后再接着获取值。 这也意味着每次属性访问都需要做这样一个判断，而引擎已经围绕属性访问做了高度优化，懒得改，而且还降低速度。 不过除了这个工作之外，还会有一些其他的内容需要考虑，比如说： 你必须将私有的 key 编码进每个词法环境 for in 可以遍历这些属性吗？ 私有属性和正常属性同名的时候，谁会屏蔽谁？ 怎么防止私有属性的名称不被探测出来。 关于使用 # 而不使用 private 更多的讨论可以参考这个 Issue。 当然这些问题都可以被解决啦，就是麻烦了点。 而如果你选择 #，实现的方式将跟 JavaScript 对象属性完全没有关系，将会使用 private slots 的方式以及使用一个新的 slot 查找语法，总之就是会比 private 的实现方式简单很多。]]></content>
  </entry>
  <entry>
    <title><![CDATA[ES6系列之defineProperty与proxy]]></title>
    <url>%2F2019%2F09%2F19%2FES6%E7%B3%BB%E5%88%97%E4%B9%8BdefineProperty%E4%B8%8Eproxy%2F</url>
    <content type="text"><![CDATA[我们或多或少都听过数据绑定这个词，数据绑定的关键在于监听数据的变化，可是对于这样一个对象：var obj = { value: 1 }，我们该怎么知道obj发生了改变呢？ definePropertyES5提供Object.defineProperty方法，该方法可以在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回这个对象。 语法：Object.defineProperty(obj, prop, descriptor) 参数 12345obj: 要在其上定义属性的对象。prop: 要定义或修改的属性的名称。descriptor: 将被定义或修改的属性的描述符 举个例子： 12345678var obj = &#123;&#125;Object.defineProperty(obj, 'num', &#123; value: 1, writable: true, enumerable: true, configurable: true&#125;)// 对象obj拥有属性num，值为1 虽然我们可以直接添加属性与值，但是使用这种方式，我们能进行更多的配置。 函数的第三个参数descriptor所表示的属性描述符有两种形式：数据描述符和存取描述符。 两者均具有以下两种键值： configurable：当且仅当该属性的configurable为true时，该属性描述符才能够被改变，也能够被删除。默认为false。 enumerable：当且仅当该属性的enumerable为true时，该属性才能够出现在对象的枚举属性中，默认为false。 数据描述符同时具有以下可选键值： value: 该属性对应的值。可以是任何有效的JavaScript值（数值、对象、函数等），默认为undefined。 writable：当且仅当该属性的writable为true时，该属性才能被赋值运算符改变，默认为false。 存取描述符同时具有以下可选键值： get:一个给属性提供getter的方法，如果没有getter则为undefined，该方法返回值被用来用作属性值，默认为undefined set：一个给属性提供setter的方法，如果没有setter则为undefined，该方法将接受唯一参数，并将该参数的新值分配给该属性，默认为undefined 值得注意的是：属性描述符必须是数据描述符或者存取描述符两种之一，不能同时是两者，这就意味着你可以： 123456Object.defineProperty(&#123;&#125;, "num", &#123; value: 1, writable: true, enumerable: true, configurable: true&#125;); 也可以： 1234567891011var value = 1;Object.defineProperty(&#123;&#125;, "num", &#123; get : function()&#123; return value; &#125;, set : function(newValue)&#123; value = newValue; &#125;,a enumerable : true, configurable : true&#125;); 但是不可以： 1234567// 报错Object.defineProperty(&#123;&#125;, "num", &#123; value: 1, get: function() &#123; return 1; &#125;&#125;); 此外，所有的属性描述符都是非必须的，但是 descriptor 这个字段是必须的，如果不进行任何配置，你可以这样： 12var obj = Object.defineProperty(&#123;&#125;, "num", &#123;&#125;);console.log(obj.num); // undefined Setter和Getter之所以讲到defineProperty，是因为我们要使用存取描述符种的get和set，这两种方法又被称为getter和setter。由于getter和setter定义的属性称为存取器属性。 当程序查询存取器属性的值时，JavaScript调用getter方法，这个方法的返回值就是属性存取表达式的值。当程序设置一个存取器属性的值时，JavaScript调用setter方法，将赋值表达式右侧的值当做参数传入setter。从某种意义上讲，这个方法负责设置属性值，可以忽略setter方法的返回值。 举个例子： 1234567891011121314var obj = &#123;&#125;, value = nullObject.defineProperty(obj, 'nul', &#123; get: function() &#123; console.log('执行了get操作') return value &#125;, set: function() &#123; console.log('执行了set操作') value = newValue &#125;&#125;)obj.num = 1 // 执行了set操作console.log(obj.num) // 执行了get操作 这不就是我们要的监控数据改变的方法吗？我们再来封装一下： 12345678910111213141516171819202122function Archiver() &#123; var value = null var archive = [] Object.defineProperty(this, 'num', &#123; get: function() &#123; console.log('执行了get操作') return value &#125;, set: function(value) &#123; console.log('执行了set操作') value = value archive.push(&#123; val: value &#125;) &#125; &#125;) this.getArchive = function() &#123; return archive &#125;&#125;var arc = new Archiver()arc.num = 11; // 执行了 set 操作arc.num = 13; // 执行了 set 操作console.log(arc.getArchive()); // [&#123; val: 11 &#125;, &#123; val: 13 &#125;] watch API既然可以监控数据的改变，那我可以这样设想，即当数据改变的时候，自动进行渲染工作。举个例子： HTML 中有个 span 标签和 button 标签 12&lt;span id="container"&gt;1&lt;/span&gt;&lt;button id="button"&gt;点击加 1&lt;/button&gt; 当点击按钮的时候，span标签里的值加1。 传统的做法是： 1234document.getElementById('button').addEventListener('click', function() &#123; var container = document.getElementById('container') container.innerHTML = Number(container.innerHTML) + 1&#125;) 如果使用defineProperty： 1234567891011121314151617181920var obj = &#123; value: 1&#125;// 储存obj.value的值var value = 1Object.defineProperty(obj, 'value', &#123; get: function() &#123; return value &#125;, set: function(newValue) &#123; value = newValue document.getElementById('container').innerHTML = newValue &#125;&#125;)document.getElementById('button').addEventListener('click', function() &#123; obj.value += 1&#125;) 代码看似增多了，但是当我们需要改变span标签的值，直接修改obj.value的值就可以了。 然而，现在的写法，我们还需要单独声明一个变量存储obj.value的值，因为如果你在set中直接obj.value = newValue就会陷入无限的循环中。此外，我们可能需要监控很多属性值的改变，要是一个一个写，也是很累的，所有我们简单的写了个watch函数。使用效果如下： 1234567891011var obj = &#123; value: 1&#125;watch(obj, 'value', function(newvalue) &#123; document.getElementById('container').innerHTML = newvalu&#125;)document.getElementById('button').addEventListener('click', function() &#123; obj.value += 1&#125;) 现在我们来写这个watch函数： 1234567891011121314151617181920(function() &#123; var root = this function watch(obj, name, func) &#123; var value = obj[name] Object.defineProperty(obj, name, &#123; get: function() &#123; return value &#125;, set: function() &#123; value = newValue func(value) &#125; &#125;) if (value) obj[name] = value &#125; this.watch = watch&#125;) 现在我们已经可以监控对象属性值的改变，并且可以根据属性值的改变，添加回调函数。 proxy使用defineProperty只能重新定义读取(get)和设置(set)行为，到了ES6，提供了Proxy。可以重定义更多的行为，比如in、delete、函数调用等更多行为。 Proxy这个词的原意是代理，用在这里表示由它来‘代理’某些操作。ES6原生提供Proxy构造函数，用来生成Proxy实例。我们来看它的语法: 1var proxy = new Proxy(target, handle) proxy对象的所有用法，都是上面这种形式，不同的只是handler参数的写法。其中，new Proxy()表示生成一个Proxy实例，target参数表示所有拦截的目标对象，handler参数也是一个对象，用来定制拦截行为： 12345678910111213var proxy = new Proxy(&#123;&#125;, &#123; get: function(obj, prop) &#123; console.log('设置get操作') return obj[prop] &#125;, set: function(obj, prop, value) &#123; console.log('设置set操作') obj[prop] = value &#125;&#125;)proxy.time = 35 // 设置set操作console.log(proxy.time) // 设置get操作 35 除了get和set之外，proxy可以拦截多达13种操作，比如has(target, propKey)，可拦截propKey in proxy的操作，返回一个布尔值。 12345678910111213// 使用has方法隐藏某些属性，不被in运算符发现var handler = &#123; has (target, key) &#123; if (key[0] === '_') &#123; return false &#125; return key in target &#125;&#125;var target = &#123; _prop: 'foo', prop: 'foo' &#125;var proxy = new Proxy(target, handler)console.log('_prop' in proxy) // false 又比如说apply方法拦截函数的调用、call和apply操作。 apply方法可以接受三个参数，分别是目标对象、目标对象的上下文对象(this)和目标对象的参数数值，不过这里我们简单演示一下： 123456789var target = function () &#123; return 'I am the target' &#125;var handler = &#123; apply: function () &#123; return 'I am the proxy' &#125;&#125;var p = new Proxy(target, handler)p() // 'I am the target' 又比如说 ownKeys 方法可以拦截对象自身属性的读取操作。具体来说，拦截以下操作： Object.getOwnPropertyNames() Object.getOwnPropertySymbols() Object.keys() 12345678910111213141516let target = &#123; _bar: 'foo', _prop: 'bar', prop: 'baz'&#125;let handler = &#123; ownKeys (target) &#123; return Reflect.ownKeys(target).filter(key =&gt; key[0] !== '_') &#125;&#125;let proxy = new Proxy(target, handler)for (let key of Object.keys(proxy)) &#123; console.log(target[key])&#125; 值得注意的是，proxy 的最大问题在于浏览器支持度不够，而且很多效果无法使用 poilyfill 来弥补。 watch API优化我们使用proxy再来写一下watch函数。 12345678910111213141516171819202122232425262728293031(function() &#123; var root = this function watch(target, func) &#123; var proxy = new Proxy(target, &#123; get: function(target, prop) &#123; return target[prop] &#125;, set: function(target, prop, value) &#123; target[prop] = value func(prop, value) &#125; &#125;) return proxy &#125; this.watch = watch&#125;)()var obj = &#123; value: 1&#125;var newObj = watch(obj, function(key, newvalue) &#123; if (key == 'value') document.getElementById('container').innerHTML = newvalue&#125;)document.getElementById('button').addEventListener('click', function() &#123; newObj.value += 1&#125;) 我们也可以发现，使用 defineProperty 和 proxy 的区别，当使用 defineProperty，我们修改原来的 obj 对象就可以触发拦截，而使用 proxy，就必须修改代理对象，即 Proxy 的实例才可以触发拦截。]]></content>
  </entry>
  <entry>
    <title><![CDATA[ES6系列之异步处理实战]]></title>
    <url>%2F2019%2F09%2F19%2FES6%E7%B3%BB%E5%88%97%E4%B9%8B%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[我们已查找指定目录下的最大文件为例，感受从： 回调函数 -&gt; Promise -&gt; Generator -&gt; Async 异步处理方式的改变。 API介绍为了实现这个功能，我们需要用到几个Nodejs的API，所有我们来简单介绍下。 fs.readdir：方法用于读取目录，返回一个包含文件和目录的数组。 fs.stat: 方法的参数是一个文件或目录，它产生一个对象，该对象包含了该文件或目录的具体信息。此外，该对象还有一个isFile()方法可以判断正在处理的到底是一个文件，还是一个目录。 思路分析我们基本的实现思路就是： 用fs.readdir获取指定目录的内容信息 循环遍历内容信息，使用fs.stat获取该文件或者目录的具体信息 将具体信息储存起来 当全部储存起来，筛选其中的是文件的信息 遍历比较，找出最大文件 获取并返回最大文件 回调函数123456789101112131415161718192021222324252627282930313233343536var fs = require('fs')var path = require('path')function findLargest(dir, cb) &#123; // 读取目录下的所有文件 fs.readdir(dir, function(er, files) &#123; if (er) return cb(er) var counter = files.length var errored = false var stats = [] files.forEach(function(file, index) &#123; // 读取文件信息 fs.stat(path.join(dir, file), function(er, stat) &#123; if (errored) return if (er) &#123; errored = true return cb(er) &#125; stats[index] = stat // 事先算好有多少个文件，读取1个文件信息，计数减一，当为0时，说明读取完毕 if (--couner == 0) &#123; var largest = stats.filter(function(stat) &#123; return stat.isFile()&#125;) .reduce(function(prev, next) &#123; if (prev.size &gt; next.size) return prev return next &#125;) cb(null, files[stats.indexOf(largest)]) &#125; &#125;) &#125;) &#125;)&#125; 使用方式为： 12345// 查找当前目录最大的文件findLargest('./', function(er, filename) &#123; if (er) return console.error(er) console.log('largest file was:', filename)&#125;) Promise123456789101112131415161718192021222324252627282930313233343536var fs = require('fs')var path = require('path')var readDir = function(dir) &#123; return new Promise(function(resolve, reject) &#123; fs.readdir(dir, function(err, files) &#123; if (err) reject(err) resolve(files) &#125;) &#125;)&#125;var stat = function(path) &#123; return new Promise(function(resolve, reject) &#123; fs.stat(path, function(err, stat) &#123; if (err) reject(err) resolve(stat) &#125;) &#125;)&#125;function findLargest(dir) &#123; return readDir(dir).then(function(files) &#123; let promises = files.map(file =&gt; stat(path.join(dir, file))) return Promise.all(promises).then(function(stats) &#123; return &#123; stats, files &#125; &#125;) &#125;).then(data =&gt; &#123; let latgest = data.stats.filter(function(stat) &#123; return stat.isFile() &#125;) .reduce((pre, next) =&gt; &#123; if (prev.size &gt; next.size) return prev return next &#125;) return data.files[data.stats.indexOf(largest)] &#125;)&#125; 使用方式为： 1234567findLargest('./').then(function(filename) &#123; console.log('largest file was:', filename)&#125;).catch(function() &#123; console.log(error)&#125;) Generator12345678910111213141516171819202122232425262728293031323334353637var fs = require('fs')var path = require('path')var co = require('co')var readDir = function(dir) &#123; return new Promise(function(resolve, reject) &#123; fs.readdir(dir, function(err, files) &#123; if (err) reject(err) resolve(files) &#125;) &#125;)&#125;var stat = function(path) &#123; return new Promise(function(resolve, reject) &#123; fs.stat(path, function(err, stat) &#123; if (err) reject(err) resolve(stat) &#125;) &#125;)&#125;function* findLargest(dir) &#123; var files = yield readDir(dir) var stats = yield files.map(function(file) &#123; return stat(path.join(dir, file)) &#125;) let largest = stats.filter(function(stat) &#123; return stat.isFile() &#125;) .reduce((prev, next) =&gt; &#123; if (prev.size &gt; next.size) return prev return next &#125;) return files[stats.indexOf(largest)]&#125; 使用方式为： 1234567co(findLargest, './').then(function(filename) &#123; console.log('largest file was:', filename)&#125;).catch(function() &#123; console.log(error)&#125;) Async12345678910111213141516171819202122232425262728293031323334var fs = require('fs')var path = require('path')var readDir = function(dir) &#123; return new Promise(function(resolve, reject) &#123; fs.readdir(dir, function(err, files) &#123; if (err) reject(err) resolve(files) &#125;) &#125;)&#125;var stat = funcion(path) &#123; return new Promise(function(resolve, reject) &#123; fs.stat(path, function(err, stat) &#123; if (err) reject(err) resolve(stat) &#125;) &#125;)&#125;async function findLargest(dir) &#123; var files = await readDir(dir) let promises = files.map(file =&gt; stat(path.join(dir, file))) var stats = await Promise.all(promises) let largest = stats.filter(function(stat) &#123; return stat.isFile() &#125;) .reduce((prev, next) =&gt; &#123; if (prev.size &gt; next.size) return prev return next &#125;) return files[stats.indexOf(largest)]&#125; 使用方式为： 1234567findLargest('./').then(function(filename) &#123; console.log('largest file was', filename)&#125;).catch(function() &#123; console.log(error)&#125;)]]></content>
  </entry>
  <entry>
    <title><![CDATA[ES6系列之Async]]></title>
    <url>%2F2019%2F09%2F16%2FES6%E7%B3%BB%E5%88%97%E4%B9%8BAsync%2F</url>
    <content type="text"><![CDATA[ES2017标准引入了async函数，使得异步操作变得更加方便。 在异步处理上，async函数就是Generator的语法糖。 举个例子： 1234567891011// 使用generatorvar fetch = require('node-fetch')var co = require('co')function* gen() &#123; var r1 = yield fetch('https://api.github.com/users/github') var json1 = yield r1.json() console.log(json1.bio)&#125;co(gen) 当你使用async时： 12345678910// 使用asyncvar fecth = require('node-fetch')var fetchData = aysnc function() &#123; var r1 = await fetch('https://api.github.com/users/github') var json1 = await r1.json() console.log(json1.bio)&#125;fetchData() 其实async函数的实现原理，就是将generator函数和自动执行器包装在一个函数里。 12345678910async function fn(args) &#123; // ...&#125;// 等同于function fn(args) &#123; return spawn(function* () &#123; //... &#125;)&#125; spawn函数指的是自动执行器，就比如说co。 再加上async函数返回一个Promise对象，你也可以理解为aysnc函数是基于Promise和Generator的一层封装。 async与 Promise严谨的说，async是一种语法，Promise是一个内置对象，两者并不具备可比性，更何况async函数返回一个Promise对象…… 这里主要是展示一些场景，使用async会比使用Promise更优雅的处理异步流程。 代码更加简洁 1234567891011121314// 实例1function fetch() &#123; return ( fetchData() .then(() =&gt; &#123; return 'done' &#125;) )&#125;async function fetch() &#123; await fetchData() return 'done'&#125; 123456789101112131415161718192021222324// 实例2function fetch() &#123; return fetchData() .then(data =&gt; &#123; if (data.moreData) &#123; return fetchAnotherData(data) .then(moreData =&gt; &#123; return moreData &#125;) &#125; else &#123; return data &#125; &#125;)&#125;async function fetch() &#123; const data = await fetchData() if (data.moreData) &#123; const moreData = await fetchAnotherData(data) return moreData &#125; else &#123; return data &#125;&#125; 123456789101112131415161718// 实例3function fetch() &#123; return &#123; fetchData() .then(value1 =&gt; &#123; return fetchMoreData(value1) &#125;) .then(value2 =&gt; &#123; return fetchMoreData2(value2) &#125;) &#125;&#125;async function fetch() &#123; const value1 = await fetchData() const value2 = await fetchMoreData(value1) return fetchMoreData2(value2)&#125; 错误处理 12345678910111213function fetch() &#123; try &#123; fetchData() .then(result =&gt; &#123; const data = JSON.parse(result) &#125;) .catch((err) =&gt; &#123; console.log(err) &#125;) &#125; catch (err) &#123; console.log(err) &#125;&#125; 在这段代码种，try/catch能捕获fetchData()种的一些Promise构造错误，但不能捕获JSON.parse抛出的异常，如果要处理JSON.parse抛出的异常，需要添加catch函数重复一遍异常处理的逻辑。 在实际项目中，错误处理逻辑可能会很复杂，这回导致冗余的代码。 1234567async function fetch() &#123; try &#123; const data = JSON.parse(await fetchData()) &#125; catch (err) &#123; console.log(err) &#125;&#125; async/await的出现使得try/catch就可以捕获同步和异步的错误。 调试 12345678910111213141516171819const fetchData = () =&gt; new Promise((resolve) =&gt; setTimeout(resolve, 1000, 1))const fetchMoreData = (value) =&gt; new Promise((resolve) =&gt; setTimeout(resolve, 1000, value + 1))const fetchMoreData2 = (value) =&gt; new Promise((resolve) =&gt; setTimeout(resolve, 1000, value + 2))function fetch() &#123; return ( fetchData() .then((value1) =&gt; &#123; console.log(value1) return fetchMoreData(value1) &#125;) .then(value2 =&gt; &#123; return fetchMoreData2(value2) &#125;) )&#125;const res = fetch();console.log(res); 因为then中的代码是异步执行，所有当你打断点的时候，代码不会顺序执行，尤其当你使用step over的时候，then函数会直接进入下一个then函数。 123456789101112const fetchData = () =&gt; new Promise((resolve) =&gt; setTimeout(resolve, 1000, 1))const fetchMoreData = () =&gt; new Promise((resolve) =&gt; setTimeout(resolve, 1000, 2))const fetchMoreData2 = () =&gt; new Promise((resolve) =&gt; setTimeout(resolve, 1000, 3))async function fetch() &#123; const value1 = await fetchData() const value2 = await fetchMoreData(value1) return fetchMoreData2(value2)&#125;;const res = fetch();console.log(res); 而使用 async 的时候，则可以像调试同步代码一样调试。 aysnc地狱aysnc地狱主要是指开发者贪图语法上的简洁而让原本可以并行执行的内容变成顺序执行，从而影响了性能，但用地狱形容有点夸张了点…… 例子一 123456(async () =&gt; &#123; const listPromise = getList() const anotherListPromise = getAnotherList() await listPromise await anotherListPromise&#125;)() 也可以使用Promise.all(): 123(async () =&gt; &#123; Promise.all([getList(), getAnotherList().then(...)])&#125;)() 例子二 当然上面这个例子比较简单，我们再来扩充一下： 12345678(async () =&gt; &#123; const listPromise = await getList() const anotherListPromise = await getAnotherList() // dosomething await submit(listPromise) await submiet(anotherListPromise)&#125;) 因为await的特性，整个例子有了明显的先后顺序，然而 getList() 和 getAnotherList() 其实并无依赖，submit(listData) 和 submit(anotherListData) 也没有依赖关系，那么对于这种例子，我们该怎么改写呢？ 基本分为三个步骤： 找出依赖关系 在这里，submit(listPromise)需要getList()之后，submit(anotherListPromise)需要在anotherListPromise()之后。 将互相依赖的语句包裹在async函数中。 1234567891011aysnc function handleList() &#123; const listPromise = await getList() // ... await submit(listPromise)&#125;aysnc function handleAnotherList() &#123; const anotherlistPromise = await getAnotherList() // ... await submit(anotherlistPromise)&#125; 并发执行aysnc函数 123456789101112131415161718192021222324async function handleList() &#123; const listPromise = await getList(); // ... await submit(listData);&#125;async function handleAnotherList() &#123; const anotherListPromise = await getAnotherList() // ... await submit(anotherListData)&#125;// 方法一(async () =&gt; &#123; const handleListPromise = handleList() const handleAnotherListPromise = handleAnotherList() await handleListPromise await handleAnotherListPromise&#125;)()// 方法二(async () =&gt; &#123; Promise.all([handleList(), handleAnotherList()]).then()&#125;)() 继发与并发问题： 给定一个URL数组，如何实现接口和继发和并发？ async继发实现： 12345678// 继发一async function loadData() &#123; var res1 = await fetch(url1) var res2 = await fetch(url2) var res3 = await fetch(url3) return 'whew all done'&#125; 1234567// 继发二async function loadData(urls) &#123; for (const url of urls) &#123; const response = await fetch(url) console.log(await response.text()) &#125;&#125; async并发实现： 12345// 并发async function loadData() &#123; var res = await Promise.all([fetch(ulr1), fetch(url2), fetch(url3)]) return 'whew all done'&#125; 123456789101112// 并发二async function loadData(urls) &#123; const textPormises = urls.map(async url =&gt; &#123; const response = await fetch(url) return response.text() &#125;) // 按次序输出 for (const textPromise of textPromises) &#123; console.log(await textPromise) &#125;&#125; asyn错误捕获尽管我们可以使用try-catch捕获错误，但是当我们需要捕获多个错误并做不同的处理时，很快try-catch就会导致代码杂乱，就比如： 1234567891011121314151617181920212223242526272829303132async function asyncTask(cb) &#123; try &#123; const user = await UserModel.findById(1) if (!user) return cb('No user found') &#125; catch (e) &#123; return cb('Unexpected error occured') &#125; try &#123; const savedTask = await TaskModel(&#123; userId: user.id, name: 'Demo Task' &#125;) &#125; catch (e) &#123; return cb('Error occurred while saving task') &#125; if (user.notificationsEnabled) &#123; try &#123; await NotificationService.sendNotification(user.id, 'Task Created') &#125; catch (e) &#123; return cb('Error while sending notification') &#125; &#125; if (saveTask.assignedUser.id !== user.id) &#123; try &#123; await NotificationService.sendNotification(savedTask.assignedUser.id, 'Task was created for you') &#125; catch (e) &#123; return cb('Error while sending notification') &#125; &#125; cb(null, savedTask)&#125; 为了简化这种错误的捕获，我们可以给await后的promise对象添加catch函数，为此我们需要写一个helper： 1234567// to.jsexport default function to(promise) &#123; return promise.then(data =&gt; &#123; return [null, data] &#125;) .catch(err =&gt; [err])&#125; 整个错误捕获的代码可以简化为： 123456789101112131415import to from './to.js'async function asyncTask() &#123; let err, user, savedTask [err, user] = await to(UserModel.findById(1)) if(!user) throw new CustomerError('No user found') [err, savedTask] = await to(TaskModel(&#123; userId: user.id, name: 'Demo Task' &#125;)) if (err) throw new CustomError('Error occurred while saving task') if (user.notificationsEnabled) &#123; const [err] = await to(NotificationService.sendNotification(user.id, 'Task Created')) if (err) console.error('Just log the error and continue flow') &#125;&#125; async的一些讨论async 会取代 Generator 吗？ Generator 本来是用作生成器，使用 Generator 处理异步请求只是一个比较 hack 的用法，在异步方面，async 可以取代 Generator，但是 async 和 Generator 两个语法本身是用来解决不同的问题的。 async 会取代 Promise 吗？ async 函数返回一个 Promise 对象 面对复杂的异步流程，Promise 提供的 all 和 race 会更加好用 Promise 本身是一个对象，所以可以在代码中任意传递 async 的支持率还很低，即使有 Babel，编译后也要增加 1000 行左右。]]></content>
  </entry>
  <entry>
    <title><![CDATA[ES6系列之Generator的自动执行]]></title>
    <url>%2F2019%2F09%2F16%2FES6%E7%B3%BB%E5%88%97%E4%B9%8BGenerator%E7%9A%84%E8%87%AA%E5%8A%A8%E6%89%A7%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[## 单个异步任务 1234567var fetch = require('node-fetch')function* gen() &#123; var url = 'https://api.github.com/users/github' var result = yield fetch(url) console.log(result.bio)&#125; 为了获得最终的执行结果，你需要这样做： 12345678var g = gen()var result = g.next()result.value.then(function(data) &#123; return data.json()&#125;).then(function(data) &#123; g.next(data)&#125;) 首先执行Generator函数，获取遍历器对象。 然后使用next方法，执行异步任务的第一阶段，即fetch(url)。 注意，由于fetch(url)会返回一个Pr。Promise对象，所以result的值为： 1&#123; value: Promise &#123; &lt;pending&gt; &#125;, done: false &#125; 最后我们为这个Promise对象添加一个then方法，先将其返回的数据格式化data.json()，再调用g.next，将获得的数据传进去，由此可以执行异步任务的第二阶段，代码执行完毕。 多个异步任务上节我们只调用了一个接口，那如果我们调用了多个接口，使用了多个yield，我们岂不是在then函数中不断的嵌套下去…… 所以我们来看看执行多个异步任务的情况 123456789var fetch = require('node-fetch')function* gen() &#123; var r1 = yield fetch('https://api.github.com/users/github') var r2 = yield fetch('https://api.github.com/users/github/followers') var r3 = yield fetch('https://api.github.com/users/github/repos') console.log([r1.bio, r2[0].login, r3[0].full_name].join('\n'))&#125; 为了获得最终的执行结果，你可能要写成： 123456789101112131415161718192021var g = gen()var result1 = g.next()result1.value.then(function(data)&#123; return data.json()&#125;).then(function(data)&#123; return g.next(data).value&#125;).then(function(data)&#123; return data.json()&#125;).then(function(data)&#123; return g.next(data).value&#125;).then(function(data)&#123; return data.json()&#125;).then(function(data)&#123; g.next(data)&#125;) 但我知道你肯定不想写成这样…… 其实，利用递归，我们可以这样写： 123456789101112131415161718function run(gen) &#123; var g = gen() function next(data) &#123; var result = g.next(data) if (result.done) return result.value.then(function(data) &#123; return data.json() &#125;).then(function(data) &#123; next(data) &#125;) &#125; next()&#125;run(gen) 其中的关键就是yield的时候返回一个Promise对象，给这个Promise对象添加then方法，当异步操作成功时执行then中的onFullfilled函数，onFullfilled函数中又去执行g.next，从而让Generator继续执行，然后再返回一个Promise，再在成功时执行g.next，然后再返回…… 启动器函数在run这个启动器函数厚葬，我们在then函数中将数据格式化data.json()，但是更广泛的情况下，比如yield直接跟一个Promise，而非一个fetch函数返回的Promise，因为没有json方法，代码就会报错。所以为了更具备通用性，连同这个例子和启动器，我们修改为： 1234567891011121314151617181920212223242526272829var fetch = require('node-fetch')function* gen() &#123; var r1 = yield fetch('https://api.github.com/users/github') var json1 = yield r1.json(); var r2 = yield fetch('https://api.github.com/users/github/followers') var json2 = yield r2.json(); var r3 = yield fetch('https://api.github.com/users/github/repos') var json3 = yield r3.json(); console.log([json1.bio, json2[0].login, json3[0].full_name].join('\n'))&#125;function run(gen) &#123; var g = gen() function next(data) &#123; var result = g.next(data) if (result.done) return result.value.then(function(data) &#123; next(data) &#125;) &#125; next()&#125;run(gen) 只要yield后跟着一个Promise对象，我们就可以利用这个run函数将Generator函数自动执行。 回调函数yield后一定要跟着一个Promise对象才能保证Generator的自动执行吗？如果只是一个回调函数呢？我们来看个例子： 首先我们来模拟一个普通的异步请求： 12345function fetchData(url, cb) &#123; setTimeout(function() &#123; cb(&#123; status: 200, data: url &#125;) &#125;, 1000)&#125; 我们可以将这种函数改造成： 1234567function fetchData(url) &#123; return function(cb) &#123; setTime(function() &#123; cb( &#123; status: 200, data: url &#125;) &#125;, 1000) &#125;&#125; 对于这样的Generator函数： 123456function* gen() &#123; var r1 = yield fetchData('https://api.github.com/users/github') var r2 = yield fetchData('https://api.github.com/users/github/followers') console.log([r1.data, r2.data].join('\n'))&#125; 如果想获得最终的结果： 123456789var g = gen()var r1 = g.next()r1.value(function(data) &#123; var v2 = g.next(data) r2.value(function(data) &#123; g.next(data) &#125;)&#125;) 如果写成这样的话，我们会面临跟第一节同样的问题，那就是当使用多个 yield 时，代码会循环嵌套起来…… 同样利用递归，所以我们可以将其改造成： 123456789101112131415function run(gen) &#123; var g = gen() function next(data) &#123; var result = g.next(data) if (result.done) return result.value(next) &#125; next()&#125;run(gen) run由此可以看出Generator函数的自动执行需要一种机制，即当异步操作有了结果，能够自动交回执行权。 而两种方法可以做到这一点。 （1）回调函数。将异步操作进行包装，暴露出回调函数，在回调函数里面交回执行权。 （2）Promise 对象。将异步操作包装成 Promise 对象，用 then 方法交回执行权。 在两种方法中，我们各写了一个 run 启动器函数，那我们能不能将这两种方式结合在一些，写一个通用的 run 函数呢？我们尝试一下： 1234567891011121314151617181920212223242526// 第一版function run(gen) &#123; var gen = gen() function next(data) &#123; var result = gen.next(data) if (result.done) returm if (isPromise(result.value)) &#123; result.value.then(function(data) &#123; next(data) &#125;) &#125; else &#123; result.value(next) &#125; &#125; next()&#125;function isPromise(obj) &#123; return 'function' == typeof obj.then&#125;module.exports = run return Promise我们已经写了一个不错的启动器函数，支持yield后跟回调函数或者Promise对象。 现在有一个问题需要思考，就是我们如何获取Generator函数的返回值呢？又如果Generator函数中出现了错误，就比如fetch了一个不存在的接口，这个错误该如何捕获呢？ 这很容易让人联想到Promise，如果这个启动器函数返回一个Promise，我们就可以给这个Promise对象添加then函数，当所有的异步操作执行成功后，我们执行onFullfilled函数，如果由任何失败，就执行onReject函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 第二版function run(gen) &#123; var gen = gen() return new Promise(function(resolve, rejext) &#123; function next(data) &#123; try &#123; var result = gen.next(data) &#125; catch (e) &#123; return reject(e) &#125; if (result.done) &#123; return resolve(result.value) &#125; var value = toPromise(result.value) value.then(function(data) &#123; next(data) &#125;, function(e) &#123; reject(e) &#125;) &#125; next() &#125;)&#125;function isPromise(obj) &#123; return 'function' == typeof obj.then&#125;function toPromise(obj) &#123; if (isPromise(obj)) return obj if ('function' == typeof obj) return thunkToPromise(obj) return obj&#125;function thunkToPromise(fn) &#123; return new Promise(function(resolve, rejext) &#123; fn(function(err, res) &#123; if (err) return rejext(err) resolve(res) &#125;) &#125;)&#125;module.exports = run 与第一版有很大的不同： 首先，我们返回了一个Promise，当result.done为true的时候，我们将该值resolve(result.value)，如果执行的过程中出现错误，被carch住，我们将原因reject(e)。 其次，我们会使用thunkToPromise 将回调函数包装成一个Promise，然后统一添加then函数。在这里值得注意的是，在thunkToPromise 函数中，我们遵循了error first的原则，这意味着当我们处理回调函数的情况时： 12345678// 模拟数据请求function fetchData(url) &#123; return function(cb) &#123; setTimeout(function() &#123; cb(null, &#123; status: 200, data: url &#125;) &#125;, 1000) &#125;&#125; 在成功时，第一个参数应该返回null，表示没有错误原因。 优化我们在第二版的基础上将代码写的更加简洁优雅一点，最终的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// 第三版function run(gen) &#123; return newe Promise(function(resolve, rejecet) &#123; if (typeof gen == 'function') gen = gen() // 如果gen不是一个迭代器 if (!gen || typeof gen.next !== 'function') return resolve(gen) onFulfilled() function onFulfilled(res) &#123; var ret try &#123; ret = gen.next(res) &#125; catch (e) &#123; return reject(e) &#125; next(ret) &#125; function onRejected(err) &#123; var ret try &#123; ret = gen.throw(err) &#125; catch (e) &#123; return reject(e) &#125; next(ret) &#125; function next(ret) &#123; if (ret.done) return resolve(ret.value) var value = toPromise(ret.valeu) if (value &amp;&amp; isPromise(value)) return value.then(onFulfilled, onRejected) return onReject(new TypeError('You may only yield a function, promise ' + 'but the following object was passed: "' + String(ret.value) + '"')) &#125; &#125;)&#125;function isPromise(obj) &#123; return 'function' == typeof obj.then&#125;function toPromise(obj) &#123; if (isPromise(obj)) return obj if ('function' == typeof obj) return thunkToPromise(obj) return obj&#125;function thunkToPromise(fn) &#123; return new Promise(function(resolve, rejext) &#123; fn(function(err, res) &#123; if (err) return reject(err) resolve(res) &#125;) &#125;)&#125;module.exports = run CO如果我们再将这个启动器函数写的完整一些，我们就相当于写了一个co，实际上，上面的代码确实来自co。 而co是什么 co 是大神 TJ Holowaychuk 于 2013 年 6 月发布的一个小模块，用于 Generator 函数的自动执行。 如果直接使用 co 模块，这两种不同的例子可以简写为： 12345678910111213141516// yield 后是一个 Promisevar fetch = require('node-fetch');var co = require('co');function* gen() &#123; var r1 = yield fetch('https://api.github.com/users/github'); var json1 = yield r1.json(); var r2 = yield fetch('https://api.github.com/users/github/followers'); var json2 = yield r2.json(); var r3 = yield fetch('https://api.github.com/users/github/repos'); var json3 = yield r3.json(); console.log([json1.bio, json2[0].login, json3[0].full_name].join('\n'));&#125;co(gen); 12345678910111213141516171819// yield 后是一个回调函数var co = require('co');function fetchData(url) &#123; return function(cb) &#123; setTimeout(function() &#123; cb(null, &#123; status: 200, data: url &#125;) &#125;, 1000) &#125;&#125;function* gen() &#123; var r1 = yield fetchData('https://api.github.com/users/github'); var r2 = yield fetchData('https://api.github.com/users/github/followers'); console.log([r1.data, r2.data].join('\n'));&#125;co(gen);]]></content>
  </entry>
  <entry>
    <title><![CDATA[ES6之Promise]]></title>
    <url>%2F2019%2F09%2F16%2FES6%E4%B9%8BPromise%2F</url>
    <content type="text"><![CDATA[说起Promise，我们一般都会从回调或者回调地狱说起，那么使用回调到底会导致哪些不好的地方呢？ 回调 回调嵌套 使用回调，我们很可能会将业务代码写成如下这种形式： 1234567891011doA( function() &#123; doB() doC(function() &#123; doD() &#125;) doE()&#125;)doF() 当然这是一种简化的形式，我们可以判断出执行的顺序为： 123456doA()doF()doB()doC()doE()doD() 然而在实际项目中，代码会更加杂乱，为了排查问题，我们需要绕过很多碍眼的内容，不断的在函数间进行跳转，使得排查问题的难度也在成倍增加。 当然之所以导致这个问题，其实时因为这种嵌套的书写方式跟人线性的思考方式相维和，以至于我们需要花更多一些精力去思考真正的执行顺序，嵌套和缩进只是这个思考过程中转移注意力的细枝末节而已。 当然了，与人线性的思考方式相维和，还不是最糟糕的，实际上，我们还会在代码中加入各种各样的逻辑判断，就比如说上面这个例子中，doD()必须在doC()完成后才能完成，如果doC()执行失败了呢？我们要重试doC()吗？还是直接转到其他错误处理函数中？当我们将这些判断都加入到这个流程中，很快代码就会变得非常复杂，以至于无法维护和更新。 控制反转 正常书写代码的时候，我们理所当然可以控制自己的代码，然而当我们使用回调的时候，这个回调函数是否能接着执行，其实取决于使用回调的哪个API。就比如： 123456// 回调幻术是否被执行取决于buy模块import &#123;buy&#125; from './buy.js'buy(itemData, function(res) &#123; console.log(res)&#125;) 对于我们经常使用的fetch这种API，一般是没有什么问题的，但是如果我们使用的是第三方的API呢？ 当你调用了第三方的API，对方是否会因为某个错误导致你传入的回调函数执行了多次呢？ 为了避免出现这样的问题，你可以在自己的回调函数中加入判断，可是万一又因为某个错误，这个函数没有执行呢？万一这个回调函数有时同步执行，有时异步执行呢？ 我们总结一下这些情况： 回调函数执行多次 回调函数没有执行 回调函数有时同步执行，有时异步执行 对于这些情况，你可能都要在回调函数中做些处理，并且每次执行回调函数的时候都要做些处理，这就带来了很多重复的代码。 回调地狱我们先来看一个简单的回调地狱的实例。 现在要找出一个目录中最大的文件，处理步骤应该是： 用fs.readdir获取目录中的文件列表 循环遍历文件，使用fs.stat获取文件信息 比较找出最大文件 以最大文件的文件名为参数调用回调 代码如下： 123456789101112131415161718192021222324252627282930313233343536var fs = require('fs')var path = require('path')function findLargest(dir, cb) &#123; // 读取目录下的所有文件 fs.readdir(dir, function(er, files) &#123; if (er) return cb(er) var counter = files.length var errored = false var stats = [] files.forEach(function(file, index) &#123; // 读取文件信息 fs.stat(path.join(dir, file), function(er, stat) &#123; if (errored) return if (er) &#123; errored = true return cb(er) &#125; stats[index] = stat // 事先算好有多少个文件，读完1个文件，计数减1，当为0时，说明读取完毕 if (--counter == 0) &#123; var largest = stats.filter(function(stat) &#123; return stat.isFile() &#125;).reduce(function(prev, next) &#123; if (prev.size &gt; next.size) return prev return next &#125;) cb(null, files[stats.indexOf(largest)]) &#125; &#125;) &#125;) &#125;)&#125; 使用方式为： 12345// 查找当前目录最大的文件findLargest('./', function(er, filename) &#123; if (er) return console.error(er) console.log('largest file was:', filename)&#125;) 看完这个例子，我们再来聊聊回调地狱的其他问题： 难以复用 回调的顺序确定下来之后，相对其中的某些环节进行复用也很困难，牵一发而动全身。 举个例子，如果你想对fs.stat读取文件信息这段代码进行复用，因为代码中引用了外层的变量，提取出来后还需要对外层的代码进行修改。 堆栈信息被断开 我们知道，JavaScript引擎维护了一个执行上下文栈，当函数执行的时候，会创建该函数的执行上下文压入栈中，当函数执行完毕后，会将该执行上下文出栈。 如果A函数中调用了B函数，JavaScript会先将A函数的执行上下文压入栈中，再将B函数的执行上下文压入栈中，当B函数执行完毕，将B函数执行上下文出栈，当A函数执行完毕后，将A函数执行上下文出栈。 这样的好处在于，我们如果中断代码执行，可以检索完整的堆栈信息，从中获取任何我们想要获取的信息。 可以异步回到函数并非如此，比如执行｀fs.readdir｀的时候，其实是将回调函数加入任务队列中，代码继续执行，直到主线程完成后，才会从任务队列中选择已完成的任务并将其加入栈中，此时栈中只有这一个执行上下文，如果回调报错，也无法获取调用该异步操作时的栈中的信息。不容易判定哪里出现了错误。 此外，因为异步的缘故，使用try catch语句也无法直接获取错误。 借助外层变量 当多个异步计算同时进行，比如这里遍历读取文件信息，由于无法预期完成顺序，必须借助外层作用域的变量。比如这里的count、errored、stats等，不仅写起来麻烦，而且如果你忽略了文件读取错误时的情况，不记录错误状态，就会接着读取其他文件，造成无谓的浪费。此外外层的变量，也可能会被其他统一作用域的函数访问并且修改，容易造成误操作。 之所以单独讲讲回调地狱，其实是想说嵌套和缩进只是回调地狱的一个梗而已，它导致的问题远非嵌套导致的可读性降低而已。 PromisePromise使得以上绝大部分的问题都得到了解决。 嵌套问题 举个例子： 12345678function(url, function(err, res, body) &#123; if (err) handleError(err) fs.writeFile('1.txt', body, function(err) &#123; request(url2, function(err, res, body) &#123; if (err) handleError(err) &#125;) &#125;)&#125;) 使用Promise后： 12345678910request(url).then(function(result) &#123; return writeFileAsynv('1.txt', result)&#125;).then(function(result) &#123; return request(url2)&#125;).catch(function(e) &#123; handleError(e)&#125;) 而对于读取最大文件的那个例子，我们使用promise可以简化为： 1234567891011121314151617181920212223242526272829303132333435363738394041var fs = require('fs')var path = require('path')var readDir = function(dir) &#123; return new Promise(function(resolve, reject) &#123; fs.readdir(dir, function(err, files) &#123; if (err) reject(err) resolve(files) &#125;) &#125;)&#125;var stat = function(path) &#123; return new Promise(function(resolve, reject) &#123; fs.stat(path, function(err, stat) &#123; if (err) reject(err) resolve(stat) &#125;) &#125;)&#125;function findLargest(dir) &#123; return readDir(dir) .then(function(files) &#123; let promises = files.map(file =&gt; stat(path.join(dir, file))) return Promise.all(promises).then(function(stats) &#123; return &#123; stats, files &#125; &#125;) &#125;) .then(data =&gt; &#123; let largest = data.stats .filter(function(stat) &#123; return stat.isFile() &#125;) .reduce((prev, next) =&gt; &#123; if (prev.size &gt; next.size) return prev return next &#125;) return data.files[data.stats.indexOf(largest)] &#125;)&#125; 控制反转再反转 前面我们讲到使用第三方回调 API 的时候，可能会遇到如下问题： 回调函数执行多次 回调函数没有执行 回调函数有时同步执行有时异步执行 对于第一个问题，Promise 只能 resolve 一次，剩下的调用都会被忽略。 对于第二个问题，我们可以使用 Promise.race 函数来解决： 12345678910111213function timeoutPromise(delay) &#123; return new Promise(function(resolve, reject) &#123; setTimeout(function() &#123; reject('Timeout!') &#125;, delay) &#125;)&#125;Promise.race([ foo(), timeoutPromise(3000)]).then(function() &#123;&#125;, function(err) &#123;&#125;) 对于第三个问题，为什么有的时候会同步执行，有的时候是异步执行呢？ 我们来看个例子： 1234567891011121314var cache = &#123;...&#125;function downloadFile(url) &#123; if (cache.has(url)) &#123; // 如果存在cache，这里为同步调用 return Promise.resolve(cache.get(url)) &#125; return fetch(url).then(file =&gt; cache.set(url, file)) // 这里为异步调用&#125; console.log('1')console.log('1');getValue.then(() =&gt; console.log('2'));console.log('3'); 在这个例子中，有cache的情况，打印结果为1 2 3 ，在没有cache的时候，打印结果为1 3 2。 然而如果将这种同步和混用的代码作为内部实现，只暴露接口给外部调用，调用方由于无法判断到底是异步还是同步状态，影响程序的可维护性和可测试性。 简单来说就是同步和异步共存的情况无法保证程序逻辑的一致性。 然而Promise解决了这个问题，我们来看个例子： 123456789101112var promise = new Promise(function(resolve) &#123; resolve() console.log(1)&#125;)promise.then(function() &#123; console.log(2)&#125;)console.log(3)// 1 3 2 即使promise对象立刻进入resolved状态，即同步调用resolve函数，then函数中指定的方法依然是异步进行的。 PromiseA+ 规范也有明确的规定： 实践中要确保 onFulfilled 和 onRejected 方法异步执行，且应该在 then 方法被调用的那一轮事件循环之后的新执行栈中执行。 Promise反模式 Promise嵌套 123456// badloadSomething().then(function(something) &#123; loadAnotherthing().then(function(another) &#123; DoSomethingOnThem(something, another) &#125;)&#125;) 12345// goodPromise.all([loadSomething(), loadAnotherthing()]).then(function([something, another]) &#123; DoSomethingOnThem(...[something, another])&#125;) 断开的Promise链 123456789// badfunction anAsyncCall() &#123; var promise = doSomethingAsync() promise.then(function() &#123; somethingComplicated() &#125;) return promise&#125; 1234567// goodfunction anAsyncCall() &#123; var promise = doSomethingAsync() return promise.then(function() &#123; somethingComplicated() &#125;)&#125; 混乱的集合 12345678910111213// badfunction workMyCollection(arr) &#123; var resultArr = [] function _recursive(idx) &#123; if (idx &gt;= resultArr.length) return resultArr return doSomethingAsync(arr[idx]).then(function(res) &#123; resultArr.push(res) return _recursive(idx + 1) &#125;) &#125; return _recursive(0)&#125; 你可以写成： 12345function workMyCollection(arr) &#123; return Promise.all(arr.map(function(item) &#123; return doSomethingAsync(item) &#125;))&#125; 如果你非要以队列的形式执行，你可以写成： 1234567function workMyCollection(arr) &#123; return arr.reduce(function(promise, item) &#123; return promise.then(function(result) &#123; return doSomethingAsyncWithResult(item, result) &#125;) &#125;, Promise.resolve())&#125; catch 123456// badsomethingAsync.then(function() &#123; return somethingElseAsync()&#125;, function(err) &#123; handleMyError(err)&#125;) 如果somethingElseAsync抛出错误，是无法被捕获的，你可以写成： 12345678// goodsomethingAsync.then(function() &#123; return somethingElseAsync()&#125;).then(null, function(err) &#123; handleMyError(err)&#125;) 12345678// goodsomethingAsync().then(function() &#123; return somethingElseAsync()&#125;).catch(function(err) &#123; handleMyError(err)&#125;) 红绿灯问题题目： 红灯三秒亮一次，绿灯一秒亮一次，黄灯两秒亮一次：如何让三个灯不断交替重复亮灯？ 三个亮灯函数已经存在： 123456789function red()&#123; console.log('red');&#125;function green()&#123; console.log('green');&#125;function yellow()&#123; console.log('yellow');&#125; 利用then和递归实现： 1234567891011121314151617181920212223242526272829303132function red()&#123; console.log('red');&#125;function green()&#123; console.log('green');&#125;function yellow()&#123; console.log('yellow');&#125;var light = function(timmer, cb) &#123; return new Promise(function(resolve, reject) &#123; setTimeout(function() &#123; cb() resolve() &#125;, timmer) &#125;)&#125;var step = function() &#123; Promise.resolve().then(function() &#123; return light(3000, red) &#125;).then(function() &#123; return light(2000, green) &#125;).then(function() &#123; return light(1000, yellow) &#125;).then(function() &#123; step() &#125;)&#125;step() promisify有的时候，我们需要将callback语法的API改造成Promise语法，为此我们需要一个promisify的方法。 因为callback语法传参比较明确，最后一个参数传入回调函数，回调函数的第一个参数是一个错误信息，如果没有错误，就是null，所以我们可以直接写出一个简单的promisify方法： 12345678910111213function promisify(original) &#123; return function(...args) &#123; return new Promise((resolve, reject) =&gt; &#123; args.push(function callback(err, ...values) &#123; if (err) &#123; return reject(err) &#125; return resolve(...values) &#125;) original.call(this, ...args) &#125;) &#125;&#125; Promise的局限性 错误被吃掉了 首先我们要理解，什么是错误被吃掉，是指错误信息不被打印吗？ 并不是，举个例子： 12throw new Error('error');console.log(233333); 在这种情况下，由于throw error的缘故，代码被阻断执行，就不会打印233333，再举个例子： 12const promise = new Promise(null)console.log(233333) 以上代码依然会被阻断执行，这是因为如果通过无效的方式使用Promise，并且出现了一个错误阻碍了正常Promise的构造，结果会得到一个立刻跑出的异常，而不是一个被拒绝的Promise。 然而再举个例子： 1234let promise = new Promise(() =&gt; &#123; throw new Error('error')&#125;)console.log(233333) 这次会正常打印233333，说明Promise内部的错误不会影响到Promise外部的代码，而这种情况我们就通常称为“吃掉错误”。 其实着并不是Promise独有的局限性，try…catch也是这样，同样会捕获一个异常并简单的吃掉错误。 而正是因为错误被吃掉了，Promise链中的错误很容易被忽略掉，这也是为什么会一般推荐在Promise链的最后添加一个catch函数，因为对于一个没有错误处理函数的Promise链，任何错误都会在链中被传播下去，直到你注册了错误处理函数。 单一值 Promise只能由一个完成值或一个拒绝原因，然而在真实使用的时候，往往需要传递多个值，一般做法都是构造一个对象或数组，然后再传递，then中获得这个值后，又会进行取值赋值的操作，每次封装和解封都无疑让代码变得笨重。 说真的，并没有什么好的方法，建议使用ES6的解构赋值： 1234Promise.all([Promise.resolve(1), Promise.resolve(2)]).then(([x, y] =&gt; &#123; console.log(x, y)&#125;)) 无法取消 Promise一旦新建，它就会立即执行，无法中途取消。 无法得知pending状态 当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。]]></content>
  </entry>
  <entry>
    <title><![CDATA[ES6系列值WeakMap]]></title>
    <url>%2F2019%2F09%2F16%2FES6%E7%B3%BB%E5%88%97%E4%B9%8BWeakMap%2F</url>
    <content type="text"><![CDATA[我们先从WeakMap的特性说起，然后聊聊WeakMap的一些应用场景。 特性 WeakMap只接受对象作为键名 12345const map = new WeakMap()map.set(1, 2)// TypeError: Invalid value used as weak map keymap.set(null, 2);// TypeError: Invalid value used as weak map key WeakMap的键名所引用的对象是弱应用 这句话其实让我非常费解，我个人觉得这句话真正想表达的意思应该是： WeakMaps hold “weak” references to key objects, 翻译过来应该是 WeakMaps 保持了对键名所引用的对象的弱引用。 我们先聊聊弱引用： 在计算机程序设计中，弱引用与强引用相对，是指不能确保其引用的对象不会被垃圾回收器回收的引用。 一个对象若只被弱引用所引用，则被认为是不可访问（或弱可访问）的，并因此可能在任何时刻被回收。 在 JavaScript 中，一般我们创建一个对象，都是建立一个强引用： 1var obj = new Object(); 只有当我们手动设置obj = null 的时候，才有可能回收obj所引用的对象。 而如果我们能创建一个弱引用的对象 12// 假设可以这样创建一个var obj = new WeakObject() 我们什么都不用做，只用静静的等待垃圾回收机制执行，obj所引用的对象就会被回收。 我们再来看看这句： WeakMap保持了对键名所引用的对象的弱引用 正常情况下，我们举个例子： 1234const key = new Array(5 * 1024 * 1024)const arr = [ [key, 1]] 使用这种方式，我们其实建立了arr和key所引用的对象（我们假设这个真正的对象叫Obj）的强引用。 所有当你设置key = null时，只是去掉了key对Obj的强引用，并没有去除arr对Obj的强引用，所以Obj还是不会被回收掉。 Map类型也是类似： 1234567let map = new Map()let key = new Array(5 * 1024 * 1024)// 建立了map对key'所引用对象的强引用map.set(key, 1)// key = null 不会导致key的原引用对象被回收key = null 我们可以通过Node来证明一下这个问题： 1234567891011121314151617181920// 允许手动执行垃圾回收机制node --expose-gcglobal.gc() // 返回Nodejs的内存占用情况，单位是bytesprocess.memoryUsage() // heapUsed: 460360 = 4.4Mlet map = new Map()let key = new Array(5 * 1024 * 1024)map.set(key, 1)global.gc()process.memoryUsage() // heapUsed: 46751472 注意这里大约是 44.6Mkey = nullglobal.gc()process.memoryUsage() // heapUsed: 46754648 ≈ 44.6M// 这句话其实是无用的，因为 key 已经是 null 了map.delete(key);global.gc();process.memoryUsage(); // heapUsed: 46755856 ≈ 44.6M 如果你想要让 Obj 被回收掉，你需要先 delete(key) 然后再 key = null: 12345let map = new Map();let key = new Array(5 * 1024 * 1024);map.set(key, 1);map.delete(key);key = null; 我们依然通过 Node 证明一下： 123456789101112131415161718node --expose-gcglobal.gc();process.memoryUsage(); // heapUsed: 4638376 ≈ 4.4Mlet map = new Map();let key = new Array(5 * 1024 * 1024);map.set(key, 1);global.gc();process.memoryUsage(); // heapUsed: 46727816 ≈ 44.6Mmap.delete(key);global.gc();process.memoryUsage(); // heapUsed: 46748352 ≈ 44.6Mkey = null;global.gc();process.memoryUsage(); // heapUsed: 4808064 ≈ 4.6M 这个时候就要说到 WeakMap 了： 1234const wm = new WealMap()let key = new Array(5 * 1024 * 1024)wm.set(key, 1)key = null 当我们设置 wm.set(key, 1) 时，其实建立了 wm 对 key 所引用的对象的弱引用，但因为 let key = new Array(5 * 1024 * 1024) 建立了 key 对所引用对象的强引用，被引用的对象并不会被回收，但是当我们设置 key = null 的时候，就只有 wm 对所引用对象的弱引用，下次垃圾回收机制执行的时候，该引用对象就会被回收掉。 我们用 Node 证明一下： 1234567891011121314node --expose-gcglobal.gc();process.memoryUsage(); // heapUsed: 4638992 ≈ 4.4Mconst wm = new WeakMap();let key = new Array(5 * 1024 * 1024);wm.set(key, 1);global.gc();process.memoryUsage(); // heapUsed: 46776176 ≈ 44.6Mkey = null;global.gc();process.memoryUsage(); // heapUsed: 4800792 ≈ 4.6M 所以WeakMap可以帮你省掉手动删除对象关联数据的步骤，所以当你不能或者不想控制关联数据的生命周期时，就可以考虑使用WeakMap 总结这个弱引用的特性，就是WeakMap保持了对键名所引用的对象的弱引用，即垃圾回收机制不将该引用考虑在内。只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存也就是说，一旦不再需要，WeakMap里面的键名对象和所对应的键值对会自动消失，不用手动删除引用。 也正是因为这样的特性，WeakMap内部有多少个成员，取决于垃圾回收机制有没有运行，运行前后很可能成员个数时不一样的，而垃圾回收机制何时运行是不可预测的，因此ES6规定WeakMap不可遍历。 所以WeakMap不像Map，一是没有遍历操作（即没有keys()、values()和entries()方法），也没有size属性，也不支持clear()方法。所以WeakMap只要四个方法可以用：get()、set()、has()、delete().。 应用 在DOM对象上保存相关数据 传统使用jQuery的时候，我们会通过$.data()在DOM对象上存储相关信息（就比如在删除按钮元素上储存帖子的ID信息），jQuery内部会使用一个对象管理DOM和对应的数据，当你将DOM元素删除，DOM对象置为空的时候，相关联的数据并不会被删除，你必须手动执行$.removeData()才能删除掉相关联的数据，WeakMap就可以简化这一操作。 12345678let wm = new WeakMap(), element = document.querySelector('.element')wm.set(element, 'data')let value = wm.get(element)console.log(vlaue) // dataelement.parentNode.removeChild(element)element = null 数据缓存 从上一个例子，我们也可以看出，当我们需要关联对象和数据，比如在不修改原有对象的情况下储存某些属性或者根据对象储存一些计算的值等，而又不想管理这些数据时非常适合考虑使用WeakMap。数据缓存就是一个很好的例子。 12345678910111213const cache = new WeakMap()function countOwnKeys(obj) &#123; if (cache.has(obj)) &#123; console.log('Cached') return cache.get(obj) &#125; else &#123; console.log('Computed') const count = Object.keys(obj).length cache.set(obj, count) return count &#125;&#125; 私有属性 WeakMap也可以被用于实现私有变量，不过在ES6中实现私有变量的方式有很多种，这只是其中一种： 1234567891011121314151617const privateData = new WeakMap()class Person &#123; constructor(name, age) &#123; privateData.set(this, &#123; name: name, age: age &#125;) &#125; getName() &#123; return privateData.get(this).name &#125; getAge() &#123; return privateData.get(this).age &#125;&#125;export default Person]]></content>
  </entry>
  <entry>
    <title><![CDATA[ES6系列之迭代器与for...of]]></title>
    <url>%2F2019%2F09%2F15%2FES6%E7%B3%BB%E5%88%97%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8Efor-of%2F</url>
    <content type="text"><![CDATA[## 起源 一段标准的for循环代码： 12345var color = ['red', 'green', 'blue']for (var i = 0, len = color.length; i &lt; len; i++) &#123; console.log(color[i])&#125; 看着很简单，但是回顾这段代码，实际上我们仅仅是需要数组中元素的值，但是却需要提前获取数组长度，声明索引变量等，尤其当多个循环嵌套的时候，更需要使用多个索引变量，代码的复杂度就会大大增加，比如我们使用双重循环进行去重： 12345678910111213141516function unique(array) &#123; var res = [] for (var i = 0, arrayLen = array.length; i &lt; arrayLen; i++) &#123; for (var j = 0, resLen = res.length; j &lt; resLen; j++) &#123; if (array[i] === res[j]) &#123; break &#125; &#125; if (j === resLen) &#123; res.push(array[i]) &#125; &#125; return res&#125; 为了消除这种复杂度以及减少循环中的错误（比如错误使用其他循环中的变量），ES6提供了迭代器与for…of循环共同解决这个问题。 迭代器所谓迭代器，其实就是一个具有next()方法的对象，每次调用next()都会返回一个结果对象，该结果对象有两个属性，value表示当前的值，done表示遍历是否结束。 我们直接用ES5的语法创建一个迭代器 12345678910111213141516171819202122function createIterator(items) &#123; var i = 0 return &#123; next: function() &#123; var done = i &gt;= item.length var value = !done ? items[i++] : undefined return &#123; done: done, value: value &#125; &#125; &#125;&#125;// iterator就是一个迭代对象var itrtator = createIterator([1, 2, 3])console.log(iterator.next()); // &#123; done: false, value: 1 &#125;console.log(iterator.next()); // &#123; done: false, value: 2 &#125;console.log(iterator.next()); // &#123; done: false, value: 3 &#125;console.log(iterator.next()); // &#123; done: true, value: undefined &#125; for…of除了迭代器之外，我们还需要一个可以遍历迭代器对象的方式，ES6提供了for…of语句，我们直接用for…of遍历一下我们上节生成的遍历器对象： 12345var iterator = createIterator([1, 2,3])for (let value of iterator) &#123; console.log(value)&#125; 结果报错TypeError: iterator is not iterable，表明我们生成的iterator对象并不是iterable（可遍历的）。 那么什么才是iterable（可遍历的）呢？ 其实一种数据结构只需要部署了Iterator接口，我们就称这种数据结构是“可遍历的”（iterable）。 ES6规定，默认的Iterator接口部署在数据结构的Symbol.iterator属性，或者说，一个数据结构只要具有Symbol.iterator属性，就可以认为是“可遍历”（iterable）。 举个例子： 123456789const obj = &#123; value: 1&#125;for (value of obj) &#123; console.log(value)&#125;// TypeError: iterator is not iterable 我们直接for…of遍历一个对象会报错，然而如果我们给该对象添加Symbol.iterator属性： 1234567891011121314const obj = &#123; value: 1&#125;obj[Symbol.iterator] = function() &#123; return createIterator([1, 2,3])&#125;for (value of obj) &#123; console.log(value)&#125;// 1// 2// 3 由此，我们可以发现for…of遍历的其实是对象的Symbol.iterator属性。 默认可遍历对象然而如果我们直接遍历一个数组对象 123456789const colors = ['red', 'green', 'blue']for (let color of colors) &#123; console.log(color)&#125;// red// green// blue 尽管我们没有手动添加Symbol.iterator属性，还是可以遍历成功，这是因为ES6默认部署了Symbol.iterator属性，当然我们也可以手动修改这个属性： 12345678910111213var colors = ['red', 'green', 'blue']colors[Symbol.iterator] = function() &#123; return createIterator([1, 2, 3])&#125;for (let color of colors) &#123; console.log(color)&#125;// 1// 2// 3 除了数组之外，还有一些数组结构默认部署了Symbol.iterator属性。 所以for…of循环可以使用的范围包括： 数组 Set Map 类数组对象，如arguments对象，DOM NodeList对象 Generator对象 字符串 模拟实现for…of其实模拟实现for…of也比较简单，基本就是通过Symbol.iterator属性获取迭代器对象，然后使用while遍历一下： 12345678910111213141516171819function forOf(obj, cb) &#123; let iterable, result if (typeof obj[Symbol.iteratorp] !== 'function') &#123; throw new TypeError(result + ' is not iterable') &#125; if (typeof cb !== 'function') &#123; throw new TypeError('cb must be callable') &#125; iterable = obj[Symbol.iterator]() result = iterable.next() while (!iterable.done) &#123; cb(result.value) result = iterable.next() &#125;&#125; 内建迭代器为了更好的访问对象中的内容，比如有的时候我们仅仅需要数组中的值，但有的时候不仅需要使用值还需要使用索引，ES6为数组、Map、Set集合内建了以下三种迭代器： entries()返回一个遍历器对象，用来遍历[键名，键值]组成的数组。对应数组，键名就是索引值。 keys()返回一个遍历器对象，用来遍历所有的键名。 values()返回一个遍历器对象，用来遍历所有的键值。 以数组为例： 12345678910111213141516171819202122232425var colors = ['red', 'green', 'blue']for (let index of color.keys()) &#123; console.log(index)&#125;// 0// 1// 2for (let color of colors.values()) &#123; console.log(color)&#125;// red// green// bluefor (let itemm of color.entries()) &#123; console.log(item)&#125;// [0, 'red']// [1, 'green']// [2, 'blue'] Map类型与数组类似，但是对于Set类型需要注意以下： 12345678910111213141516171819202122232425var color = new Set(['red', 'green', 'blue'])for (let index of color.keys()) &#123; console.log(index)&#125;// red// green// bluefor (let color of colors.values()) &#123; console.log(color)&#125;// red// green// bluefor (let itemm of color.entries()) &#123; console.log(item)&#125;// [red, 'red']// [green, 'green']// [blue, 'blue'] Set类型的keys()和values()返回的是相同的迭代器，这也意味着在Set这种数据结构中键名与键值相同。 而且每个集合类型都有一个默认的迭代器，在for…of循环中，如果没有显示指定则使用默认的迭代器。数组和Set集合的默认迭代器是values()方法，Map集合的默认迭代器是entries()方法。 这也就是为什么直接for…of遍历Map和Set数据结构，返回不同的数据结构。 123456789const values = new Set([1, 2, 3])for (let value of values) &#123; console.log(value)&#125;// 1// 2// 3 1234567const values = new Map([["key1", "value1"], ["key2", "value2"]]);for (let value of values) &#123; console.log(value);&#125;// ["key1", "value1"]// ["key2", "value2"] 遍历 Map 数据结构的时候可以顺便结合解构赋值： 12345678const values = new Map([["key1", "value1"], ["key2", "value2"]]);for (let [key, value] of values) &#123; console.log(key + ":" + value);&#125;// key1:value1// key2:value2 Babel是如何编译for…of的我们可以在Babel 的 Try it out 中查看编译的结果： 12345const colors = new Set(['red', 'green', 'blue'])for (let color of colors) &#123; console.log(color)&#125; 对于这样一段代码，编译的结果如下： 1234567891011121314151617181920212223242526272829303132'use strict'var colors = new Set(['res', 'green', 'blue'])var _iteratorNormalCompletion = truevar _didIteratorError = falsevar _iteratorError = undefinedtry &#123; for ( var _iterator = colors[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true ) &#123; var color = _setp.value console.log(color) &#125;&#125; catch (err) &#123; _didIteratorError = true _iteratorError = err&#125; finally &#123; try &#123; if (!_iteratorNormalCompletion &amp;&amp; _iterator.return) &#123; _iterator.return() &#125; &#125; finally &#123; if (_didIteratorError) &#123; throw _iteratorError &#125; &#125;&#125; 至少由编译的结果可以看出，使用for of 循环的背后，还是会使用Symbol.iterator接口。 而这段代码稍微复杂的地方有两端，一段是for循环： 12345678for ( var _iterator = colors[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) &#123; var color = _step.value; console.log(color);&#125; 跟标准的for循环写法有些区别，我们看下for语句的语法： 1for (initialize; test; increment) statement initialize、test和increment三个表达式之间用分号分隔，它们分别负责初始化操作、循环条件判断和计数器变量的更新。 for语句其实就相当于： 12345initializewhile (test) &#123; statement increment&#125; 代码的逻辑为：先进行初始化，然后每次循环执行之前会执行test表达式，并判断表达式的结果来决定是否执行循环体，如果test计算结果为真值，则执行循环体中的statement。最后，执行increment表达式。 而且值得注意的是，其实 for 循环中的三个表达式中任意一个都可以被忽略，不过分号还是要写的。 比如 for(;;)，不过这就是一个死循环…… 比如： 12345var i = 0, len = colors.length;for (; i &lt; len; i++) &#123; console.log(colors[i]);&#125; 又比如： 123var i = 0, len = colors.length;for 后我们再来看 Babel 编译的这个 for 循环表达式： 12345678for ( var _iterator = colors[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) &#123; var color = _step.value; console.log(color);&#125; 用 while 的写法相当于： 1234567var _iterator = colors[Symbol.iterator](), _step;while (!(_iteratorNormalCompletion = (_step = _iterator.next()).done)) &#123; var color = _step.value; console.log(color); _iteratorNormalCompletion = true;&#125; 是不是就好懂了很多呢，然后你就会发现，其实 _iteratorNormalCompletion = true 这句是完全没有必要的…… 另外一段稍微复杂的代码是: 12345678910111213try &#123; ...&#125; catch (err) &#123; ...&#125; finally &#123; try &#123; if (!_iteratorNormalCompletion &amp;&amp; _iterator.return) &#123; _iterator.return(); &#125; &#125; finally &#123; ... &#125;&#125; 因为 _iteratorNormalCompletion = (_step = _iterator.next()).done，所以 _iteratorNormalCompletion 表示的就是是否完成了一次完整的迭代过程，如果没有正常的迭代完成，并且迭代器有 return 方法时，就会执行该方法。 而之所以这么做，就要提到迭代器的 return 方法。 引用阮一峰老师的 ECMAScript 6 入门: 遍历器对象除了具有 next 方法，还可以具有 return 方法和 throw 方法。如果你自己写遍历器对象生成函数，那么 next 方法是必须部署的，return 方法和 throw 方法是否部署是可选的。 return 方法的使用场合是，如果 for…of 循环提前退出（通常是因为出错，或者有 break 语句或 continue 语句），就会调用 return 方法。如果一个对象在完成遍历前，需要清理或释放资源，就可以部署 return 方法。 我们可以举个例子： 1234567891011121314151617181920212223242526272829303132333435function createIterator(items) &#123; var i = 0 return &#123; next: function() &#123; var done = i &gt;= items.length var value = !done ? items[i++] : undefiend return &#123; done: done, value: value &#125; &#125;, return: function() &#123; console.log('执行了return方法') return &#123; value: 23333, done: true &#125; &#125; &#125;&#125;var colors = ['red', 'green', 'blue']var iterator = createIterator([1, 2, 3])colors[Symbol.iterator] = function() &#123; return iterator&#125;for (let color of colors) &#123; if (color == 1) break console.log(color)&#125;// 执行了return方法 不过正如你在编译后的代码中看到，仅仅是在有 return 函数的时候执行了 return 函数而已，return 函数中返回的值其实并不生效…… 但是你不返回值或者返回一个基本类型的值的话，结果又会报错…… 1TypeError: Iterator result undefined is not an object 这是因为 return 方法必须返回一个对象，而这又是 Generator 规范决定的…… 总之如果是在浏览器中使用的话，return 函数的返回值其实并不生效 T^T]]></content>
  </entry>
  <entry>
    <title><![CDATA[Symbol的使用场景]]></title>
    <url>%2F2019%2F09%2F14%2FSymbol%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%2F</url>
    <content type="text"><![CDATA[## ES6第7中数据类型——Symbol 已经有的6中数据类型：Undefined、Null、布尔值、字符串、数值、对象，现在ES6新加入一种数据类型——Symbol。我们先来看看它的最大特点：独一无二。 1234567891011// 没有参数的情况var s1 = Symbol()var s2 = Symbol()console.log(s1 === s2) // false// 有参数的情况var s1 = Symbol("foo");var s2 = Symbol("foo");console.log(s1 === s2) // false 这里的的’foo’只是该Symbol的一个描述，并不代表两个参数都为’foo’时，就能够证明这两个Symbol相等。 作为属性名的使用12345678910111213141516var mySymbol1 = Symbol()// 第一种写法a[mySymbol] = 'Hello'// 第二种写法var a = &#123; [mySymbol]: 'Hello'&#125;// 第三种写法var a = &#123;&#125;Object.defineProperty(a, mySymbol, &#123; value: 'Hello' &#125;)// 以上写法都得到同样结果a[mySymbol] // 'Hello' 注意，这里不可以使用a.mySymbol = &#39;hello&#39;来填充该属性值，因为点运算符后面总是字符串。 为什么要是有Symbol？ 那么问题来了，我们究竟为什么要使用Symbol呢？有这样一种场景，我们向区分两个属性，其实我们并不在意这两个属性值究竟是什么，我们在意的是，这两个属性绝对要区分开来！例如： 12345678910111213var shapeType = &#123; triangle: 'Triangle' &#125;function getArea(shape, options) &#123; var area = 0 switch(shape) &#123; case shape.triangle: area = 0.5 * options.width * options.height break &#125; return area&#125; 这个时候，我们仅仅是想区分各种形状，因为不同的形状用不同计算面积的公式。这里是用的是triangle的名字就在‘Triangle’,而事实上我们不想对triangle去特地取个名，我们只想区分triangle这个形状不同于任何其他形状，那么这个时候Symbol就派上用场啦! 123const shapeType = &#123; triangle: Symbol()&#125; 发现了吗，也就是说我们不用非要去给变量赋一个字符串的值，去区分它和别的变量的值不同，因为去给每个变量娶个语义化而又不同的值是一个伤脑子的事，当我们只需要知道每个变量的值是不同的时，我们就可以使用Symbol/]]></content>
  </entry>
  <entry>
    <title><![CDATA[ES6系列之模拟Symbol类型]]></title>
    <url>%2F2019%2F09%2F14%2FES6%E7%B3%BB%E5%88%97%E4%B9%8B%E6%A8%A1%E6%8B%9FSymbol%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[实际上，Symbol的很多特性都无法模拟实现，所以先让我们回顾下有哪些特性，然后挑点能实现的。当然在看的过程中，你也可以思想这个特性是否能实现，如果能实现，该如何实现。 回顾ES6引入了一种新的原始数据类型Symbol，表示独一无二的值。 Symbol值通过Symbol函数生成，使用typeof，结果是“symbol” 12var s = Symbol()console.log(typeof s) // "symbol" Symbol函数前不能使用new命令，否则会报错。这是因为生成的Symbol是一个原始类型的值，不是对象。 instanceof的结果为false 12var s = Symbol('foo')console.log(s instanceof Symbol) // false Symbol函数可以接受一个字符串作为参数，表示对Symbol实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。 12var s1 = Symbol(foo)console.log(s1) // Symbol(foo) 如果Symbol的参数时一个对象，就会调用该对象的toString方法，将其转为字符串，然后才生成一个Symbol值。 1234567const obj = &#123; toString() &#123; return 'abc' &#125;&#125;const sym = Symbol(obj)console.log(sym) // Symbol(abc) Symbol函数的参数只是表示对当前Symbol值的描述，相同参数的Symbol函数的返回值时不相等的。 1234567891011// 没有参数的情况var s1 = Symbol()var s2 = Symbol()console.log(s1 === s2) // false// 有参数的情况var s1 = Symbol('foo')var s2 = Symbol('foo')console.log(s1 === s2) // false Symbol值不能与其他类型的值进行运算，会报错。 12var sym = Symbol('My Symbol')console.log('Your Symbol is ' + sym) // TypeError: can't convert symbol to string Symbol值可以显示转为字符串 123var sym = Symbol('My Symbol')console.log(String(sym)); // 'Symbol(My Symbol)'console.log(sym.toString()); // 'Symbol(My Symbol)' Symbol值可以作为标识符，用于对象的属性名，可以保证不会出现同名的属性 1234567891011121314151617var mySymbol = Symbol()// 第一种写法var a = &#123;&#125;a[mySymbol] = 'Hello!'// 第二种写法var a = &#123; [mySymbol]: 'Hello!'&#125;// 第三种写法var a = &#123;&#125;Object.defineProperty(a, mySybol, &#123; value: 'Hello!' &#125;)// 以上写法都得到同样结果console.log(a[mySymbol]) // 'Hello!' Symbol作为属性名，该属性不会出现在for…in、for…of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回。但是，它也不是私有属性，有一个Object.getOwnPropertySymbols方法，可以获取指定对象的所以Symbol属性名。 12345678910var obj = &#123;&#125;var a = Symbol('a')var b = Symbol('b')obj[a] = 'Hello'obj[b] = 'World'var objectSymbols = Object.getOwnPropertySymbols(obj)console.log(objectSymbols) // [Symbol(a), Symbol(b)] 如果我们希望使用同一个Symbol值，可以使用Symbol.for。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的Symbol值。如果有，就返回这个Symbol值，否则就新建并返回一个该字符串为名称的Symbol值。 1234var s1 = Symbol.for('foo')var s2 = Symbol.for('foo')console.log(s1 === s2) Symbol.keyFor方法返回一个已登记的Symbol类型值的key。 12345var s1 = Symbol.for('foo')console.log(Symbol.keyFor(s1)) // 'foo'var s2 = Symbol('foo')console.log(Symbol.keyFor(s2)) // undefined 分析看完以上的特性，你觉得哪些特性是可以模拟实现的呢？ 如果我们要模拟实现一个 Symbol 的话，基本的思路就是构建一个 Symbol 函数，然后直接返回一个独一无二的值。 不过在此之前，我们先看看规范中调用 Symbol 时到底做了哪些工作： Symbol ( [ description ] )When Symbol is called with optional argument description, the following steps are taken: If NewTarget is not undefined, throw a TypeError exception. If description is undefined, var descString be undefined. Else, var descString be ToString(description). ReturnIfAbrupt(descString). Return a new unique Symbol value whose [[Description]] value is descString. 当调用 Symbol 的时候，会采用以下步骤： 如果使用 new ，就报错 如果 description 是 undefined，让 descString 为 undefined 否则 让 descString 为 ToString(description) 如果报错，就返回 返回一个新的唯一的 Symbol 值，它的内部属性 [[Description]] 值为 descString 考虑到还需要定义一个 [[Description]] 属性，如果直接返回一个基本类型的值，是无法做到这一点的，所以我们最终还是返回一个对象。 第一版参照着规范，其实我们已经开始写起来了： 1234567891011121314151617181920212223242526272829// 第一版(function() &#123; var root = this var SymbolPolyfill = function Symbol(description) &#123; // 实现特性第二点：Symbol函数前不能使用new命令 if (this instanceof SymbolPolyfill) &#123; throw new TypeError('Symbol is not a constructor') &#125; // 实现特性第五点：如果Symbol的参数是一个对象，就会调用该对象的toString方法，将其转为字符串，然后才生成一个Symbol值。 var descString = description === undefined ? undefined : String(description) var symbol = Object.create(null) Object.defineProperties(symbol, &#123; '__Description__': &#123; value: descString, writable: false, enumerable: false, configurable: false &#125; &#125;) // 实现特性第六点：因为调用该方法，返回的是一个新对象，两个对象之间，只要引用不用，就不会相等 return symbol &#125; root.SymbolPolyfill = SymbolPolyfill()&#125;)() 只需要参照规范，我们已经实现了特性的第2、5、6点。 第二版我们来看看其他的特性该如何实现： 使用typeof，结果为’symbol’ 利用ES5，我们并不能修改typeof操作符的结果，所以这个无法实现。 instanceof的结果为false 因为不是通过new的方式实现的，所以instanceof的结果自然是false Symbol函数可以接受一个字符串作为参数，表示对Symbol实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。 当我们打印一个原生Symbol值的时候： 1console.log(Symbol('1')) // Symbol(1) 可时我们模拟实现的时候返回的确实一个对象，所以这个也是无法实现的，当然你修改console.log这个方法就是另讲。 Symbol值可以显式转为字符串 1234var sym = Symbol('My symbol');console.log(String(sym)); // 'Symbol(My symbol)'console.log(sym.toString()); // 'Symbol(My symbol)' 当调用 String 方法的时候，如果该对象有 toString 方法，就会调用该 toString 方法，所以我们只要给返回的对象添加一个 toString 方法，即可实现这两个效果。 12345678// 第二版// 前面代码相同var symbol = Object.create(&#123; toString: function() &#123; return 'Sybol(' + this.__Description__ + ')' &#125;,&#125;)// 后面代码相同 第三版 Symbol值可以作为标识符，用于对象的属性名，可以保证不会出现同名的属性。 看着好像没什么，这点其实和第8点是冲突的，这是因为当我们模拟的所谓Symbol值其实是一个有着toString方法的对象，当对象作为对象的属性名的时候，就会进行隐式类型转换，还是会调用我们添加的toString方法，对于 Symbol(‘foo’) 和 Symbol(‘foo’)两个 Symbol 值，虽然描述一样，但是因为两个对象，所以并不相等，但是当作为对象的属性名的时候，都会隐式转换为ymbol(foo) 字符串，这个时候就会造成同名的属性。举个例子： 12345678910var a = SymbolPolyfill('foo')var b = SymbolPolyfill('foo')console.log(a === b) // falsevar o = &#123;&#125;o[a] = 'hello'o[b] = 'world'console.log(o) // &#123; Symbol(foo): 'world' &#125; 为了防止不会出现同名的属性，毕竟这是一个非常重要的特性，迫不得已，我们需要修改toString方法，让它返回一个唯一值，所以第八点就无法实现了，而且我们还需要再写一个用来生成唯一值的方法，就命名为generateName，我们将该唯一值添加到返回对象的Name属性中保存下俩。 12345678910111213141516171819202122232425262728293031323334353637383940414243// 第三版(function() &#123; var root = this var generateName = (function() &#123; var postfix = 0 return function(descString) &#123; postfix++ return '@@' + descString + '_' + postfix &#125; &#125;)() var SymbolPolyfill = function Symbol(description) &#123; if (this instanceof SymbolPolyfill) throw new TypeError('Symbol is not a constructor'); var descString = description === undefined ? undefined : String(description) var symbol = Object.create(&#123; toString: function() &#123; return this.__Name__; &#125; &#125;) Object.defineProperties(symbol, &#123; '__Description__': &#123; value: descString, writable: false, enumerable: false, configurable: false &#125;, '__Name__': &#123; value: generateName(descString), writable: false, enumerable: false, configurable: false &#125; &#125;); return symbol; &#125; root.SymbolPolyfill = SymbolPolyfill&#125;)() 此时再看下这个例子： 12345678910var a = SymbolPolyfill('foo');var b = SymbolPolyfill('foo');console.log(a === b); // falsevar o = &#123;&#125;;o[a] = 'hello';o[b] = 'hi';console.log(o); // Object &#123; "@@foo_1": "hello", "@@foo_2": "hi" &#125; 第四版我们再看看接下来的特性。 Symbol值不能与其他类型的值进行运算，会报错 以 + 操作符为例,当进行隐式类型转换的时候，会先调用对象的valueOf方法，如果没有返回基本值就会再调用toString方法，所以我们考虑再valueOf方法中进行报错，比如： 1234567var symbol = Object.create(&#123; valueOf: function() &#123; throw new Error('Cannot convert a Symbol value') &#125;&#125;)console.log('1' + symbol) // 报错 看着很简单的解决这个问题，可是如果我们是显示调用valueOf方法呢》对于一个原生的Symbol值： 12var s1 = Symbol('foo')console.log(s1.valueOf()) // Symbol(foo) 是的，对于原生Symbol，显示的调用valueOf方法，会直接返回该Symbol值，而我们又无法判断是显式还是隐式的调用，所以这个我们就只能实现一半，要不然实现隐式调用报错，要不然实现显式调用返回该值，那……我们选择不报错的那个吧，即后者。 我们迫不得已的修改 valueOf 函数： 123456789101112// 第四版// 前面面代码相同 ……var symbol = Object.create(&#123; toString: function() &#123; return this.__Name__; &#125;, valueOf: function() &#123; return this; &#125;&#125;);// 后面代码相同 …… 第五版 Symbol 作为属性名，该属性不会出现在 for…in、for…of 循环中，也不会被 Object.keys()、Object.getOwnPropertyNames()、JSON.stringify() 返回。但是，它也不是私有属性，有一个 Object.getOwnPropertySymbols 方法，可以获取指定对象的所有 Symbol 属性名。 嗯，无法实现。 有时，我们希望重新使用同一个Symbol值，Symbol.for方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的Symbol值。如果有，就返回这个Symbol值，否则就新建并返回一个以该字符串为名称的Symbol值。 这个实现类似与函数记忆，我们建立一个对象，用来存储已经船舰的Symbol值即可 Symbol.ketFor方法返回一个已登记的Symbol类型值的key 面临forMap查找该值对应的键值即可。 12345678910111213141516171819202122232425262728// 第五版// 前面代码相同......var SymbolPolyfill = function() &#123; ... &#125;var forMap = &#123;&#125;Object.defineProperties(SymbolPolyfill, &#123; 'for': &#123; value: function(description) &#123; var descString = description === undefined ? undefined : String(description) return forMap[descString] ? forMap[descString] : forMap[descString] = SymbolPolyfill(descString) &#125;, writable: true, enumerable: false, configurable: true &#125;, 'keyFor': &#123; value: function(symbol) &#123; for (var key in forMap) &#123; if (forMap[key] === symbol) return key &#125; &#125;, writable: true, enumerable: false, configurable: true &#125;&#125;)// 后面代码相同..... 完整实现综上所述： 无法实现的特性：1、4、7、8、10 可以实现的特性：2、3、5、6、9、11、12 最后的实现如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970(function() &#123; var root = this var generateName = (function() &#123; var postdix = 0 return function(descString) &#123; postfix++ return '@@' + descString + '_' + postfix &#125; &#125;)() var SymbolPolyfill = function Symbol(description) &#123; if (this instanceof SymbolPolyfill) &#123; throw new TypeError('Symbol is not a contructor') &#125; var descString = description === undefined ? undefined : String(description) var symbol = Object.create(&#123; toString: function() &#123; return this.__Name__ &#125;, valueOf: function() &#123; return this &#125; &#125;) Object.defineProperties(symbol, &#123; '__Description__': &#123; value: descString, writable: false, enumerabel: false, configurable: false &#125;, '__Name__': &#123; value: generateName(descString), writable: false, enumerable: false, configurable: false &#125; &#125;) return symbol &#125; var forMap = &#123;&#125; Object.defineProperties(SymbolPolyfill, &#123; 'for': &#123; value: function(description) &#123; var descString = description === undefined ? undefined : String(description) return forMap[descString] ? forMap[descString] : forMap[descString] = SymbolPolyfill(descString) &#125;, writable: true, enumerable: false, configurable: true &#125;, 'keyFor': &#123; value: function(symbol) &#123; for (var key in forMap) &#123; if (forMap[key] === symbol) &#123; return key &#125; &#125; &#125;, writable: true, enumerable: false, configurable: true &#125; &#125;) root.SymbolPolyfill = SymbolPolyfill&#125;)()]]></content>
  </entry>
  <entry>
    <title><![CDATA[ES6系列之箭头函数]]></title>
    <url>%2F2019%2F09%2F13%2FES6%E7%B3%BB%E5%88%97%E4%B9%8B%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[我们先来回顾下箭头函数的基本语法。 1let func = value =&gt; value 相当于： 123let func = function(value) &#123; return value&#125; 如果需要给函数传入多个参数： 1let func = (value, num) =&gt; value + num 如果函数的代码块需要多条语句： 123let func = (value, num) =&gt; &#123; return value * num&#125; 如果需要直接返回一个对象： 1let func = (value, num) =&gt; (&#123;total: value * num&#125;) 与变量解构结合： 123456789let func = (&#123;value, num&#125;) =&gt; (&#123;total: value * num&#125;))// 使用var result = func(&#123; value: 10, num: 10&#125;)console.log(result) // &#123;total: 100&#125; 比较我们重点比较一下箭头函数与普通函数。主要区别有： 没有this 箭头函数没有this，所有需要通过查找作用域链来确定this的值。 这就意味着如果箭头函数被非箭头函数包含，this绑定的就是最近一次非箭头函数的this/ 模拟一个实际开发中的例子。 我们的需求是点击一个按钮，改变该按钮的背景色。 为了方便开发，我们抽离一个Button组件，当需要使用的时候，直接： 12// 传入元素id值即可绑定该元素点击时改变背景色的事件new Button('button') HTML代码如下： 123&lt;button id="button"&gt; 点击变色&lt;/button&gt; JavaScript代码如下： 1234567891011121314function Button(id) &#123; this.element = document.querySelector('#' + id) this.bindEvent()&#125;Button.prototype.bindEvent = function() &#123; this.element.addEventListener('click', this.setBgColor, false)&#125;Button.prototype.setBgColor = function() &#123; this.element.sytle.backgroundColor = '#1abc9c'&#125;var button = new Button('button') 看着好像没有问题，结果却是报错 Uncaught TypeError: Cannot read property &#39;style&#39; of undefined。 这是因为当使用addEventListener()为一个元素注册事件的时候，事件函数里的this值是该元素的引用。 所有如果我们在setBgColor中console.log(this)，this指向的是按钮元素，那this.element就是undefined，报错自然就理所当然了。 也许你会问，既然this都指向了按钮元素，那我们直接修改setBgColor函数为： 123Button.prototype.setBgColor = function() &#123; this.style.backgroundColor = '#1abc9c'&#125; 确实可以这样做，但是在实际的开发中，我们可能会在setBgColor中还调用其他的函数，比如写成这种： 1234Button.prototype.setBgColor = function() &#123; this.setElementColor() this.setOtherElementColor()&#125; 所以我们还是希望setBgColor中的this是指向实例对象的，这样就可以调用其他的函数。 利用ES5，我们一般会这样做： 123Button.prototype.bindEvent = function() &#123; this.element.addEventListener('click', this.setBgColor.bind(this), false)&#125; 为了避免addEventListener的影响，使用bind强制绑定setBgColor()的this为实例对象。 使用ES6，我们可以更好的解决这个问题： 123Button.prototype.bindEvent = function() &#123; this.element.addEventListener('click', event =&gt; this.setBgColor(event), false)&#125; 由于箭头函数没有this，所以会向外层查找this的值，即bindEvent中的this，此时this指向实例对象，所以可以正确的调用this.setBgColor方法。而this.setBgColor中的this也会正确指向实例对象。 在这里再额外提一点，就是注意bindEvent和setBgColor在这里使用的是普通函数的形式，而非箭头函数，如果我们改成箭头函数，会导致函数里的this指向window对象（非严格模式下）。 最后，因为箭头函数没有this，所以也不能用call()、apply()、bind()这些方法改变this的指向，可以看一个例子： 123var value = 1var result = (() =&gt; this.value).bind(&#123;value: 2&#125;)()console.log(result) 没有arguments 箭头函数没有自己的arguments对象，这不一定是件坏事，因为箭头函数可以访问外围函数的arguments对象： 123456function constant() &#123; return () =&gt; arguments[0]&#125;var result = constant(1)console.log(result()) // 1 那如果我们就是要访问箭头函数的参数呢？ 我们可以通过命名参数或rest参数的形式访问参数。 1let nums = (...nums) =&gt; nums 不能通过new关键字调用 JavaScript函数有两个内部方法：[[Call]]和[[Construct]] 当通过new调用函数时，执行[[Construct]]方法，创建一个实例对象，然后再执行函数体，将this绑定到实例上。 当直接调用的时候，执行[[Call]]方法，直接执行函数体。 箭头函数并没有[[Construct]]方法，不能被用作构造函数，如果通过new的方式调用，会报错。 12var Foo = () =&gt; &#123;&#125;var foo = new Foo() // TypeError: Foo is not a constructor 没有new.target 因为不能使用new调用，所以也没有new.target值。 没有原型 由于不能使用new调用箭头函数，所以也没有构建原型的需求，于是箭头函数也不存在prototype这个属性。 12var Foo = () =&gt; &#123;&#125;console.log(Foo.prototype) // undefined 没有super 连原型都没有，自然也不饿能通过super来访问原型的属性，所以箭头函数也没有super的，不过跟this、arguments、new.target一样，这些值有外围最近一层非箭头函数 决定。 总结最后，关于箭头函数，引用 MDN 的介绍就是： An arrow function expression has a shorter syntax than a function expression and does not have its own this, arguments, super, or new.target. These function expressions are best suited for non-method functions, and they cannot be used as constructors. 翻译过来就是： 箭头函数表达式的语法比函数表达式更短，并且不绑定自己的this，arguments，super或 new.target。这些函数表达式最适合用于非方法函数(non-method functions)，并且它们不能用作构造函数。 那么什么是 non-method functions 呢？ 我们先来看看 method 的定义： A method is a function which is a property of an object. 对象属性中的函数就被称之为 method，那么 non-mehtod 就是指不被用作对象属性中的函数了，可是为什么说箭头函数更适合 non-method 呢？ 让我们来看一个例子就明白了： 123456789var obj = &#123; i: 10, b: () =&gt; console.log(this.i, this), c：function() &#123; console.log(this.i, this) &#125;&#125;obj.b() // undefined Windowobj.c() // 10, Object &#123;...&#125; 自执行函数自执行函数的形式： 123(function() &#123; console.log(1)&#125;)() 或者： 123(function() &#123; console.log(1)&#125;()) 利用箭头简化自执行函数的写法： 123(() =&gt; &#123; console.log(1)&#125;)() 但是注意：使用以下这种写法却会报错： 123(() =&gt; &#123; console.log(1)&#125;())]]></content>
  </entry>
  <entry>
    <title><![CDATA[模板字符串]]></title>
    <url>%2F2019%2F09%2F13%2FES6%E7%B3%BB%E5%88%97%E4%B9%8B%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[## 基础语法 12let message = `Hello World`console.log(message) 如果需要在字符串中使用反撇号，可以使用反斜杠转义： 12let message = `Hello \` World`console.log(message) 值得一提的是，在模板字符串中，空格、缩进、换行都会被保留： 1234567let message = ` &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt;`console.log(message) 注意，打印的结果中第一行是一个换行，你可以使用trim函数消除换行： 1234567let message = ` &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt;`.trim()console.log(message) 嵌入变量模板字符串支持嵌入变量，只需要将变量名写在${}之中，其实不止变量，任意的JavaScript表达式都是可以的： 123let x =1, y = 2let message = `&lt;ul&gt;&lt;li&gt;$&#123;x&#125;&lt;/li&gt;&lt;li&gt;$&#123;x + y&#125;&lt;/li&gt;&lt;/ul&gt;`;console.log(message); // &lt;ul&gt;&lt;li&gt;1&lt;/li&gt;&lt;li&gt;3&lt;/li&gt;&lt;/ul&gt; 值得一提的是，模板字符串支持嵌套： 1234567891011let arr = [&#123;value: 1&#125;, &#123;value: 2&#125;];let message = ` &lt;ul&gt; $&#123;arr.map((item) =&gt; &#123; return ` &lt;li&gt;$&#123;item.value&#125;&lt;/li&gt; ` &#125;)&#125; &lt;/ul&gt;`;console.log(message); 打印结果如下： 注意，在li标签中间多了个逗号，这是因为当大括号中的值不是字符串时，会将其转为字符串，比如一个数组[1, 2, 3]就会被转为1, 2, 3，逗号就是这样产生的。 如果要消除这个逗号，我们可以先join一下： 1234567891011let arr = [&#123;value: 1&#125;, &#123;value: 2&#125;];let message = ` &lt;ul&gt; $&#123;arr.map((item) =&gt; &#123; return ` &lt;li&gt;$&#123;item.value&#125;&lt;/li&gt; ` &#125;).join(&apos;&apos;)&#125; &lt;/ul&gt;`;console.log(message); 打印结果如下： 标签模板模板标签时一个非常重要的能力，模板字符串可以紧跟一个函数名后面，该函数将被调用来处理这个模板字符串，举个例子： 123let x = 'Hi', y = 'Kevin'var res = message`$&#123;x&#125;, I am $&#123;y&#125;`console.log(res) 我们可以定义message函数来处理返回的字符串： 1234567// literals 文字// 注意在这个例子中literals的第一个元素和最后一个元素都是空字符串function message(literals, value1, value2) &#123; console.log(literals) console.log(value1) console.log(value2)&#125; 我们利用这些参数将其拼回去： 1234567891011function message(literals, ...values) &#123; let result = '' for (let i = 0, i &lt; values.length; i++) &#123; result += literals[i] result += values[i] &#125; result += literals[literals.length - 1] return result&#125; 我也可以这样写： 1234567function message(literals, ...values) &#123; let result = literals.reduce((prev, next, i) =&gt; &#123; let value = values[i - 1] return prev + value + next &#125;) return result&#125; 学着拼合回去是一件非常重要的事情，因为我们经过各种处理，最终都还是要拼回去的…… oneLine讲完基础，我们可以来看一些实际的需求： 123456let message = ` Hi, Daisy! I am Kevin.`; 出于可能性 或者其他原因，我希望书写的时候是换行的，但是最终输出的字符是在一行，这就需要借助模板标签来实现了，我们尝试写一个这样的函数： 1234567891011// oneLine 第一版function oneLine(template, ...expressions) &#123; let result = template.reduce(prev, next, i) =&gt; &#123; let expression = expressions[i - 1] return prev + expression + next &#125; result = result.replace(/(\s+)/g, " ") result = result.trim() return result&#125; 实现原理很简单，拼合回去然后将多个空白符如换行符、空格等替换成一个空格。 使用如下： 1234567let message = oneLine ` Hi, Daisy! I am Kevin.`;console.log(message); // Hi, Daisy! I am Kevin. 不过你再用下去就会发现一个问题，如果字符间就包括多个空格呢？举个例子： 1234let message = oneLine` Preserve eg sentences. Double spaces within input lines.`; 如果使用这种匹配方式，sentences. 与 Double 之间的两个空格也会被替换成一个空格。 我们可以再优化一下，我们想要的效果是将每行前面的多个空格替换成一个空格，其实应该匹配的是换行符以及换行符后面的多个空格，然后将其替换成一个空格，我们可以将正则改成： 1result = result.replace(/(\n\s*)/g, " "); 就可以正确的匹配代码。最终的代码如下： 123456789101112// oneLine 第二版function oneLine(template, ...expressions) &#123; let result = template.reduce((prev, next, i) =&gt; &#123; let expression = expressions[i - 1]; return prev + expression + next; &#125;); result = result.replace(/(\n\s*)/g, " "); result = result.trim(); return result;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[ES6系列之let和const]]></title>
    <url>%2F2019%2F09%2F13%2FES6%E7%B3%BB%E5%88%97%E4%B9%8Blet%E5%92%8Cconst%2F</url>
    <content type="text"><![CDATA[通过 var声明的变量存在变量提升的特性： 12345if (condition) &#123; var value = 1&#125;console.log(value) 初学者可能会觉得只有condition为true的时候，才会创建value，如果condition为false，结果应该是报错，然而因为变量提升的原因，代码相当于： 123456var valueif (condition) &#123; value = 1&#125;console.log(value) 如果condition为false，结果会是undefined。 除此之外，在for循环中： 12345for (var i = 0; i &lt; 10; i++) &#123; ···&#125;console.log(i) 为了加强对变量生命周期的控制，ECMAScript6引入块级作用域。 块级作用域存在于： 函数内部 块中（字符 { 和 } 之间的区域） let和const块级声明用于声明在指定块的作用域之外无法访问的变量。 let和const都是块级声明的一种。 我们来回顾下let和const的特点。 不会被提升 12345if (false) &#123; let valur = 1&#125;console.log(value) // Uncaught ReferenceError: value is not defined 重复声明报错 12var value = 1var value = 2 // Uncaught SyntaxError: Identifier 'value' has already been declared 不绑定全局作用域 当在全局作用域中使用var声明的时候，会创建一个新的全局变量作为全局对象的属性。 12var value = 1console.log(window.value) // 1 然而，let和const不会： 12let value = 1console.log(window.value) // undefined 再来说下let和const的区别： const用于声明常量，其值一旦被设定不能再被修改，否则会报错 值得一提的是：const声明不允许修改绑定，但允许修改值，这意味着当用const声明对象时： 12345678910const data = &#123; value: 1&#125;// 没问题data.value = 2data.num = 3// 报错data = &#123;&#125; // Uncaught TypeError: Assignment to constant variable. 暂时死区临时死区（Temporal Dead Zone），简称为TDZ。 let和const声明的变量不会被提升到作用域顶部，如果在声明之前访问这些变量，会导致报错： 12console.log(typeof value) // Uncaught ReferenceError: value is not definedlet value = 1 这是因为JavaScript引擎在扫描代码发现变量声明时，要么将它们提升到作用域顶部（遇到var声明），要么将声明放在TDZ中（遇到let和const声明）。访问TDZ中的变量会触发运行时错误。只有执行过变量声明语句后，变量才会从TDZ中移除，然后方可访问。 看似很好理解，不保证不会犯错： 12345678910111213var value = 'global'// 例子1(function() &#123; console.log(value) let value = 'local'&#125;())// 例子2&#123; console.log(value) const value = 'local'&#125; 两个例子中，结果并不会打印’global’，而是报错Uncaught ReferenceError: value is not defined，就是因为 TDZ 的缘故。 循环中的块级作用域1234567var funcs = []for (var i = 0, i &lt; 3; i++) &#123; funcs[i] = function () &#123; console.log(i) &#125;&#125;funcs[0]() // 3 一个老生常谈的面试题，解决方案如下： 123456789var funcs = []for (var i = 0; i &lt; 3; i++) &#123; funcs[i] = (function(i) &#123; return function() &#123; console.log(i) &#125; &#125;(i))&#125;funcs[0]() // 0 ES6的let为这个问题提供了新的解决方案： 1234567var funcs = []for (let i = 0; i &lt; 3; i++) &#123; function[i] = function () &#123; console.log(i) &#125;&#125;funcs[0]() // 0 问题在于，上面讲了let不提升，不能重复声明，不能绑定全局作用域等等特性，可是为什么在这里就能正确打印出i值呢？ 如果是不重复声明，在循环第二次的时候，又用let声明了i，应该报错呀，就算因为某种原因，重复声明不报错，一遍一遍迭代，i的值最终还应该是3呀。 设置循环变量的那个部分是一个单独的作用域，就比如： 1234567for (let i = 0; i &lt; 3; i++) &#123; let i = 'abc' console.log(i)&#125;// abc// abc// abc 这个例子是对的，如果我们把let改成var呢？ 12345for (var i = 0; i &lt; 3; i++) &#123; var i = 'abc' console.log(i)&#125;// abc 为什么结果就不一样了呢，如果有单独的作用域，结果应该是相同的 如果要追究这个问题，就要抛弃掉之前所讲的这些特性！这是因为 let 声明在循环内部的行为是标准中专门定义的，不一定就与 let 的不提升特性有关，其实，在早期的 let 实现中就不包含这一行为。 我们会发现，在for循环中使用let和var，底层会使用不同的处理方式。 那么当使用let的时候底层到底是怎样做的呢？ 简单的来说，就是在 for (let i = 0; i &lt; 3; i++) 中，即圆括号之内建立一个隐藏的作用域，这就可以解释为什么： 1234567for (let i = 0; i &lt; 3; i++) &#123; let i = 'abc' console.log(i)&#125;// abc// abc// abc 然后每次迭代循环时都创建一个新变量，并以之前迭代中同名变量的值将其初始化。这样对于下面这样一段代码： 1234567var funcs = []for (let i = 0; i &lt; 3; i++) &#123; funcs[i] = function () &#123; console.log(i) &#125;&#125;funcs[0]() // 0 就相当于： 123456789101112131415161718// 伪代码(let i = 0) &#123; funcs[0] = function() &#123; console.log(i) &#125;;&#125;(let i = 1) &#123; funcs[1] = function() &#123; console.log(i) &#125;;&#125;(let i = 2) &#123; funcs[2] = function() &#123; console.log(i) &#125;;&#125;; 当执行函数的时候，根据词法作用域就可以找到正确的值，其实也可以理解为let声明模仿了闭包的做法来简化循环过程。 循环中的let和const不过到这里还没有结束，如果我们把let改成const呢？ 1234567var funcs = [];for (const i = 0; i &lt; 10; i++) &#123; funcs[i] = function () &#123; console.log(i); &#125;;&#125;funcs[0](); // Uncaught TypeError: Assignment to constant variable. 结果会是报错，因为虽然我们每次都创建了一个新的变量，然而我们在迭代中尝试修改const的值，所有最终会报错。 说完了普通的for循环，我们还有for in 循环。 那下面的结果时什么呢？ 12345678var funcs = [], object = &#123;a: 1, b: 1, c: 1&#125;;for (var key in object) &#123; funcs.push(function()&#123; console.log(key) &#125;);&#125;funcs[0]() 结果是’c’ 那如果把 var 改成 let 或者 const 呢？ 使用 let，结果自然会是 ‘a’，const 呢？ 报错还是 ‘a’? 结果是正确打印 ‘a’，这是因为在 for in 循环中，每次迭代不会修改已有的绑定，而是会创建一个新的绑定。]]></content>
  </entry>
  <entry>
    <title><![CDATA[数组去重]]></title>
    <url>%2F2019%2F09%2F10%2F%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%2F</url>
    <content type="text"><![CDATA[数组去重的方法： 双重循环也许我们先想到的是使用indexOf来循环判断一遍，但是再这个方法之前，让我们先看看最原始的方法： 12345678910111213141516171819var array = [1, 1, '1', '1']function unique(array) &#123; // res用来存储结果 for (var i = 0, arrayLen = array.length; i &lt; arrayLen; i++) &#123; for (var j = 0, resLen = res.length; j &lt; resLen; j++) &#123; if (array[i] === res[j]) &#123; break; &#125; &#125; // 如果array[i]是唯一的，那么执行完循环，j等于resLen if (j === resLen) &#123; res.push(array[i]) &#125; &#125; return res&#125;console.log(unique(array)) // [1, '1'] 在这个方法中，我们使用循环嵌套，最外层循环array，里面循环res，如果array[i]的值res[j]的值相等就跳出循环，如果都不等于，说明元素是唯一的，这时候j的值就会等于res的长度，根据这个特点进行判断，将值添加进res。 indexOf我们可以用indexOf简化内层的循环 1234567891011121314var array = [1, 1, '1', '1']function unique(array) &#123; var res = [] for (var i = 0, len = array.length; i &lt; len; i++) &#123; var current = array[i] if (res.indexOf(current) === -1) &#123; res.push(current) &#125; &#125; return res;&#125;console.log(unique(array)) 排序后去重‘试想我们先将要去重的数组使用sort方法排序后，相同的值就会被排在一起，然后我们就可以只判断当前元素与上一个元素是否相同，相同就说明重复，不相同就添加进res，让我们写个demo： 1234567891011121314151617var array = [1, 1, '1', '1']function unique(array) &#123; var res = [] var sortedArray = array.concat().sort() var seen for (var i = 0, len = sortedArray.length; i &lt; len; i++) &#123; // 如果是第一个元素或者相邻的元素不相同 if (!i || seen !== sortedArray[i]) &#123; res.push(sortedArray[i]) &#125; seen = sortedArray[i] &#125; return res&#125;console.log(unique(array)) 如果我们对一个已经排好序的数组去重，这种方法效率肯定高于使用indexOf。 unique API知道了这两种方法后，我们可以去尝试写一个名为unique的工具函数，我们根据一个参数isSorted判断传入的数组是否是已排序的，如果为true，我们就判断相邻元素是否相同，如果为false，我们就使用indexOf进行判断。 123456789101112131415161718192021222324var array1 = [1, 2, '1', 2, 1]var array2 = [1, 1, '1', 2, 2]// 第一版function unique(array, isSorted) &#123; var res = [] var seen = [] for (var i = 0, len = array.length; i &lt; len; i++) &#123; var value = array[i] if (isSorted) &#123; if (!i || seen !== value) &#123; res.push(value) &#125; seen = value &#125; else if (res.indexOf(value) === -1) &#123; res.push(value) &#125; &#125; return res&#125;console.log(unique(array1)) // [1, 2, '1']console.log(unique(array2, true)) // [1, '1', 2] 优化尽管unique已经可以试下去重功能，但是为了让这个API更加强大，我们来考虑一个需求： 字母的大小写视为一致，比如’a‘和’A‘，保留一个就可以了。 虽然我们可以先处理数组种的所有数据，比如将所有的字母转成小写，然后再传入unique函数，但是有没有方法可以省掉处理数组的这一循环，直接就在去重的循环中做呢？ 1234567891011121314151617181920212223var array3 = [1, 1, 'a', 'A', 2, 2]// 第二版function unique(array, isSorted, iteratee) &#123; var value = array[i] var computed = iteratee ? itertee(value, i, array) : value if (isSorted) &#123; if (!i || seen !== computed) &#123; res.push(value) &#125; seen = computed &#125; else if (iteratee) &#123; if (seen.indexOf(computed) === -1) &#123; seen.push(computed) res.push(value) &#125; &#125; else if (res.indexOf(value) === -1) &#123; res.push(value) &#125; return res&#125;console.log(unique(array3, false, function(item) &#123; return typeof item == 'string' ? item.toLowerCase() : item&#125;)) 在这一版中，函数传递了三个参数： array：表示要去重的数组 isSorted：表示函数传入的数组是否已排过序，如果为true，将会采用更快的方法进行去重 iteratee：传入一个函数，可以对每个函数进行重新的计算，然后根据处理的结果进行去重 filterES5提供了filter方法，我们可以用来简化外层函数： 比如使用indexOf的方法： 12345678910var array = [1, 2, 1, 1, '1']function unique(array) &#123; var res = array.filter(function(item, index, array) &#123; return array.indexOf(item) === index &#125;) return res&#125;console.log(unique(array)) 排序去重的方法： 123456789var array = [1, 2, 1, 1, '1']function unique(array) &#123; return array.concat().sort().filter(function(item, index, array) &#123; return !index || item !== array[index - 1] &#125;)&#125;console.log(unique(array)) Object键值对去重的方法众多，尽管我们写了个uniqueAPI，但是让我们看看其他的方法拓展下视野： 这种方法是利用一个空的Object对象，我们把数组的值存成Object的key值，比如Object[value1] = true，在判断另一个值的时候，如果Object[value2]存在的话，就说明该值是重复的。示例代码如下： 12345678910var array = [1, 2, 1, 1, '1']function unique(array) &#123; var obj = &#123;&#125; return array.filter(function(item, index, array)&#123; return obj.hasOwnProperty(item) ? false : (obj[item] = true) &#125;)&#125;console.log(unique(array)) // [1, 2] 我们可以发现是有问题的，因为1和‘1’是不同的，但是这种方法会判断为同一个值，这是因为对象的键值只能是字符串，所有我们可以使用typeof item + item拼成字符串作为key值来避免这个问题： 12345678910var array = [1, 2, 1, 1, '1']function unique(array) &#123; var obj = &#123;&#125; return array.filter(function(item, index ,array) &#123; return obj.hasOwnProperty(typeof item + item) ? false : (obj[typeof item + item] = true) &#125;)&#125;console.log(unique(array)) // [1, 2, '1'] 然而，即便如此，我们依然无法正确区别两个对象，比如{value: 1}和{value: 2}，因为typeof item + item 的结果都会是 object[object Object]，不过我们可以使用 JSON.stringify 将对象序列化： 1234567891011var array = [&#123;value: 1&#125;, &#123;value: 1&#125;, &#123;value: 2&#125;]function unique(array) &#123; var obj = &#123;&#125; return array.filter(function(item, index, array) &#123; console.log(typeof item + JSON.stringify(item)) return obj.hasOwnProperty(typeof item + JSON.stirngify(item)) ? false : (obj[typeof item + JSON.stringify(item)] = true) &#125;)&#125;console.log(unique(array)) // [&#123;value: 1&#125;, &#123;value: 2&#125;] ES6随着ES6的到来，去重的方法又有了进展，比如我们可以使用Set和Map数据结构，以Set为例，ES6提供了新的数据结构Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。 1234567var array = [1, 2, 1, 1, '1']function unique(array) &#123; return Array.from(new Set(array))&#125;console.log(unique(array)) // [1, 2, '1'] 甚至可以再简化下： 123function unique(array) &#123; return [...new Set(array)]&#125; 还可以再简化下： 1var unique = (a) =&gt; [...new Set(a)] 此外，如果用Map的话： 1234function unique(arr) &#123; const seen = new Map() return arr.filter((a) =&gt; !seen,has(a) &amp;&amp; seen.set(a, 1))&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[节流]]></title>
    <url>%2F2019%2F09%2F10%2F%E8%8A%82%E6%B5%81%2F</url>
    <content type="text"><![CDATA[节流的原理：如果你持续触发事件，每隔一段时间，只执行一次事件。根据首次是否执行以及结束后是否执行，效果有所不同，实现的方式也有所不同。我们用leading代表首次是否执行，trailing代表结束后是否再执行一次。 关于节流的实现，有两种主流的实现方式，一种是使用时间戳，一种是设置时间器。 使用时间戳让我们来看第一种方法：使用时间戳，当触发事件的时候，我们取出当前的时间戳，然后减去之前的事件戳（最一开始设为0），如果大于设置的时间周期就执行函数，然后更新时间戳为当前的时间戳，如果小于，就不执行。 123456789101112131415// 第一版function throttle(func, wait) &#123; var context, args; var previous = 0; return function() &#123; var now = +new Date(); context = this; args = arguments; if (now - previous &gt; wait) &#123; func.apply(context, args); previous = now; &#125; &#125;&#125; 例子依然是用讲 debounce 中的例子，如果你要使用： 1container.onmousemove = throttle(getUserAction, 1000); 效果演示如下： 我们可以看到：当鼠标移入的时候，事件立刻执行，每过 1s 会执行一次，如果在 4.2s 停止触发，以后不会再执行事件。 使用定时器接下来，我们讲讲第二种实现方式，使用定时器。 当触发事件的时候，我们设置一个定时器，再触发事件的时候，如果定时器存在就不执行，直到定时器执行然后执行函数，清空定时器，这样就可以设置下个定时器。 1234567891011121314151617// 第二版function throttle(func, wait) &#123; var timeout; var previous = 0; return function() &#123; context = this; args = arguments; if (!timeout) &#123; timeout = setTimeout(function()&#123; timeout = null; func.apply(context, args) &#125;, wait) &#125; &#125;&#125; 为了让效果更加明显，我们设置wait的时间为3s，效果演示如下： 我们可以看到：当鼠标移入的时候，事件不会立刻执行，晃了3s后终于执行了一次，此后每3s执行一次，当数字显示为3的时候，立刻移除鼠标，相当于大约 9.2s 的时候停止触发，但是依然会在第 12s 的时候执行一次事件。 所以比较两个方法： 第一种事件会立刻执行，第二种事件会在 n 秒后第一次执行 第一种事件停止触发后没有办法再执行事件，第二种事件停止触发后依然会再执行一次事件 双剑合璧那我们想要一个什么样的呢？ 有人就说了：我想要一个有头有尾的！就是鼠标移入能立刻执行，停止触发的时候还能再执行一次！ 所以我们综合两者的优势，然后双剑合璧，写一版代码： 12345678910111213141516171819202122232425262728293031// 第三版function throttle(func, wait) &#123; var timeout, context, args, result; var previous = 0; var later = function() &#123; previous = +new Date(); timeout = null; func.apply(context, args) &#125;; var throttled = function() &#123; var now = +new Date(); //下次触发 func 剩余的时间 var remaining = wait - (now - previous); context = this; args = arguments; // 如果没有剩余的时间了或者你改了系统时间 if (remaining &lt;= 0 || remaining &gt; wait) &#123; if (timeout) &#123; clearTimeout(timeout); timeout = null; &#125; previous = now; func.apply(context, args); &#125; else if (!timeout) &#123; timeout = setTimeout(later, remaining); &#125; &#125;; return throttled;&#125; 效果演示如下： 我们可以看到：鼠标移入，事件立刻执行，晃了3s，事件再一次执行，当数字变成3的时候，也就是6s后，我们立刻移出鼠标，停止触发事件，9s的时候，依然会再执行一次事件。 优化但是如果我们需要无头有尾，或者有头无尾的情况，如何是好？ 那我们设置个options作为第三个参数，然后根据传的值判断到底哪种效果，我们约定： leading：false 表示禁用第一次执行 trailing：false 表示禁用停止触发的回调 我们来改一下代码： 123456789101112131415161718192021222324252627282930313233// 第四版function throttle(func, wait, options) &#123; var timeout, context, args, result; var previous = 0; if (!options) options = &#123;&#125;; var later = function() &#123; previous = options.leading === false ? 0 : new Date().getTime(); timeout = null; func.apply(context, args); if (!timeout) context = args = null; &#125;; var throttled = function() &#123; var now = new Date().getTime(); if (!previous &amp;&amp; options.leading === false) previous = now; var remaining = wait - (now - previous); context = this; args = arguments; if (remaining &lt;= 0 || remaining &gt; wait) &#123; if (timeout) &#123; clearTimeout(timeout); timeout = null; &#125; previous = now; func.apply(context, args); if (!timeout) context = args = null; &#125; else if (!timeout &amp;&amp; options.trailing !== false) &#123; timeout = setTimeout(later, remaining); &#125; &#125;; return throttled;&#125; 取消在 debounce 的实现中，我们加了一个 cancel 方法，throttle 我们也加个 cancel 方法： 1234567891011121314151617181920212223242526272829303132333435363738// 第五版 function throttle(func, wait, options) &#123; var timeout, context, args, result; var previous = 0; if (!options) options = &#123;&#125;; var later = function() &#123; previous = options.leading === false ? 0 : new Date().getTime(); timeout = null; func.apply(context, args); if (!timeout) context = args = null; &#125;; var throttled = function() &#123; var now = new Date().getTime(); if (!previous &amp;&amp; options.leading === false) previous = now; var remaining = wait - (now - previous); context = this; args = arguments; if (remaining &lt;= 0 || remaining &gt; wait) &#123; if (timeout) &#123; clearTimeout(timeout); timeout = null; &#125; previous = now; func.apply(context, args); if (!timeout) context = args = null; &#125; else if (!timeout &amp;&amp; options.trailing !== false) &#123; timeout = setTimeout(later, remaining); &#125; &#125;; throttled.cancel = function() &#123; clearTimeout(timeout); previous = 0; timeout = null; &#125; return throttled;&#125; 注意我们要注意 underscore 的实现中有这样一个问题： 那就是 leading：false 和 trailing: false 不能同时设置。 如果同时设置的话，比如当你将鼠标移出的时候，因为 trailing 设置为 false，停止触发的时候不会设置定时器，所以只要再过了设置的时间，再移入的话，就会立刻执行，就违反了 leading: false，bug 就出来了，所以，这个 throttle 只有三种用法： 1234567container.onmousemove = throttle(getUserAction, 1000);container.onmousemove = throttle(getUserAction, 1000, &#123; leading: false&#125;);container.onmousemove = throttle(getUserAction, 1000, &#123; trailing: false&#125;);]]></content>
  </entry>
  <entry>
    <title><![CDATA[防抖]]></title>
    <url>%2F2019%2F09%2F09%2F%E9%98%B2%E6%8A%96%2F</url>
    <content type="text"><![CDATA[在前端开发中会遇到一些频繁的事件触发，比如： window的resize、scroll mousedown、mousemove keyup、keydown …… 为此，我们举个示例代码来了解事件如何频繁的触发： 我们写个index.html文件： 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang="zh-cmn-Hans"&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta http-equiv="x-ua-compatible" content="IE=edge, chrome=1"&gt; &lt;title&gt;debounce&lt;/title&gt; &lt;style&gt; #container&#123; width: 100%; height: 200px; line-height: 200px; text-align: center; color: #fff; background-color: #444; font-size: 30px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="container"&gt;&lt;/div&gt; &lt;script src="debounce.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; debounce.js文件的代码如下： 12345678var count = 1;var container = document.getElementById('container');function getUserAction() &#123; container.innerHTML = count++;&#125;;container.onmousemove = getUserAction; 我们来看看效果： 从左边滑到右边就触发了165次getUserAction函数！ 因为这个例子很简单，所有浏览器完全反应的过来，可是如果是复杂的回调函数或是ajax请求呢？假设1秒触发了60次，每个回调就必须在1000 / 60 = 16.67ms内完成，否则就会有卡顿出现。 为了解决这个问题，一般有两种解决方案： debounce防抖 throttle节流 防抖防抖的原理是：你尽管触发事件，但是我一定在事件触发n秒后才执行，如果你在一个事件触发的n秒内又触发了这个事件，那我就以新的事件的时间为准，n秒后才执行，总之，就是等你触发完事件n秒内不再触发事件，我才执行，真是任性啊！ 第一版 根据这段表述，我们可以写第一版的代码： 12345678// 第一版function debounce(func, wait) &#123; var timeout; return function () &#123; clearTimeout(timeout) timeout = setTimeout(func, wait); &#125;&#125; 如果我们要使用它，以最开始的例子为例： 1container.onmousemove = debounce(getUserAction, 1000); 现在随你怎么移动，反正你移动完 1000ms 内不再触发，我才执行事件。看看使用效果： 顿时就从 165 次降低成了 1 次! this 如果我们在getUserAction函数中console.log(this)，在不使用debounce函数的时候，this的值为： 1&lt;div id="container"&gt;&lt;/div&gt; 但是如果使用我们的debouce函数，this就会指向Window对象！ 所有我们需要将this指向正确的对象。 12345678910111213// 第二版function debounce(func, wait) &#123; var timeout; return function () &#123; var context = this; clearTimeout(timeout) timeout = setTimeout(function()&#123; func.apply(context) &#125;, wait); &#125;&#125; 现在 this 已经可以正确指向了。让我们看下个问题： event对象 JavaScript在事件处理函数中会提供事件对象event，我们修改下getUserAction函数： 1234function getUserAction(e) &#123; console.log(e); container.innerHTML = count++;&#125;; 如果我们不使用debouce函数，这里会打印MouseEvent对象，如图所示： 但是在我们实现的 debounce 函数中，却只会打印undefined！ 所有我们再修改一下代码： 1234567891011121314// 第三版function debounce(func, wait) &#123; var timeout; return function () &#123; var context = this; var args = arguments; clearTimeout(timeout) timeout = setTimeout(function()&#123; func.apply(context, args) &#125;, wait); &#125;&#125; 到此为止，我们修复了两个小问题： this指向 event对象 立即执行 这个时候，代码已经很完善了，到是为了让这个函数更加完善，我们接下来思考一个新的需求。 这个需求就是： 我不希望非要等到事件停止触发后才执行，我希望立即执行函数，然后等到停止触发n秒后，才可以重新触发执行。 对此我们加个immediate参数判断是否是立刻执行。 12345678910111213141516171819202122232425// 第四版function debounce(func, wait, immediate) &#123; var timeout; return function () &#123; var context = this; var args = arguments; if (timeout) clearTimeout(timeout); if (immediate) &#123; // 如果已经执行过，不再执行 var callNow = !timeout; timeout = setTimeout(function()&#123; timeout = null; &#125;, wait) if (callNow) func.apply(context, args) &#125; else &#123; timeout = setTimeout(function()&#123; func.apply(context, args) &#125;, wait); &#125; &#125;&#125; 再来看看使用效果： 返回值 此时需要注意，就是getUserAction函数可能是有返回值的，所有我们也要返回函数的执行结果，但是但immediate为false的时候，因为使用了setTimeout，我们将func.apply(context, args)的返回值赋给变量，最后再return的时候，值将会一直是undefined，所有我们只在immediate为true的时候返回函数的执行结果。 1234567891011121314151617181920212223242526/ 第五版function debounce(func, wait, immediate) &#123; var timeout, result; return function () &#123; var context = this; var args = arguments; if (timeout) clearTimeout(timeout); if (immediate) &#123; // 如果已经执行过，不再执行 var callNow = !timeout; timeout = setTimeout(function()&#123; timeout = null; &#125;, wait) if (callNow) result = func.apply(context, args) &#125; else &#123; timeout = setTimeout(function()&#123; func.apply(context, args) &#125;, wait); &#125; return result; &#125;&#125; 取消 最后我们再思考一个小需求，我希望能取消debounce函数，比如说我debounce的使劲按间隔是10秒钟，immediate为true，这样的话，我只有的等10秒后重新触发事件，现在我希望有一个按钮，点击后，取消防抖，这样我再去触发，就可以立即执行了。 为了这个需求，我们写最后一版的代码： 123456789101112131415161718192021222324252627282930313233/ 第六版function debounce(func, wait, immediate) &#123; var timeout, result; var debounced = function () &#123; var context = this; var args = arguments; if (timeout) clearTimeout(timeout); if (immediate) &#123; // 如果已经执行过，不再执行 var callNow = !timeout; timeout = setTimeout(function()&#123; timeout = null; &#125;, wait) if (callNow) result = func.apply(context, args) &#125; else &#123; timeout = setTimeout(function()&#123; func.apply(context, args) &#125;, wait); &#125; return result; &#125;; debounced.cancel = function() &#123; clearTimeout(timeout); timeout = null; &#125;; return debounced;&#125; 那么该如何使用这个 cancel 函数呢？依然是以上面的 demo 为例： 1234567891011121314var count = 1;var container = document.getElementById('container');function getUserAction(e) &#123; container.innerHTML = count++;&#125;;var setUseAction = debounce(getUserAction, 10000, true);container.onmousemove = setUseAction;document.getElementById("button").addEventListener('click', function()&#123; setUseAction.cancel();&#125;) 演示效果如下：]]></content>
  </entry>
  <entry>
    <title><![CDATA[透彻掌握Promise]]></title>
    <url>%2F2019%2F09%2F02%2F%E9%80%8F%E5%BD%BB%E6%8E%8C%E6%8F%A1Promise%2F</url>
    <content type="text"><![CDATA[在实际的使用中，有非常多的应用场景我们不能立即知道应该如何继续往下执行。最重要也是最主要的一个场景就是ajax场景。通俗的说，由于网速的不同，可能你得到的返回值时间也是不同的，这个时候我们就需要等待，结果出来了之后才知道怎么样继续下来。 1234567891011121314// 简单的ajax原生实现var url = 'https://hq.tigerbrokers.com/fundamental/finance_calendar/getType/2017-02-26/2017-06-10';var result;var XHR = new XMLHttpRequest();XHR.open('GET', url, true);XHR.send();XHR.onreadystatechange = function() &#123; if (XHR.readyState == 4 &amp;&amp; XHR.status == 200) &#123; result = XHR.response; console.log(result); &#125;&#125; 在ajax的原生实现中，利用了onreadystatechange事件，当该事件触发并且符合一定条件时，才能拿到我们想要的数据，之后我们才能开始处理数据。 这样做看上去并没有什么麻烦，但是如果这个时间，我们还需要做另一个ajax请求，这个新的ajax的其中一个参数，要从上一个ajax请求中获取，这个时间我们就要这样做。 12345678910111213141516171819202122var url = 'https://hq.tigerbrokers.com/fundamental/finance_calendar/getType/2017-02-26/2017-06-10';var result;var XHR = new XMLHttpRequest();XHR.open('GET', url, true);XHR.send();XHR.onreadystatechange = function() &#123; if (XHR.readyState == 4 &amp;&amp; XHR.status == 200) &#123; result = XHR.response; console.log(result); // 伪代码 var url2 = 'http:xxx.yyy.com/zzz?ddd=' + result.someParams; var XHR2 = new XMLHttpRequest(); XHR2.open('GET', url, true); XHR2.send(); XHR2.onreadystatechange = function() &#123; ... &#125; &#125;&#125; 当出现第三个ajax（甚至更多）依然依赖上一个请求的时候，我们的代码就变成了一场灾难。这场灾难往往被称为回调地狱。 因此我们需要一个叫做Promise的东西来解决这个问题。 当然除了回调地狱之外，我们还有一个非常重要的需求：为了我们的代码更具可读性与可维护性，我们需要将数据请求与数据处理明确的区分开来。上面的写法时完全没有区分来，当数据变得复杂时，也许我们自己都无法轻松维护自己的代码了。这也是模块化过程中，必须要掌握的一个重要的技能。 当我们想要确保某代码在谁谁之后执行时，我们可以利用函数调用栈，将我们想要执行的代码放入回调函数中。 12345678910111213// 一个简单的封装function want() &#123; console.log('这是你想要执行的代码');&#125;function fn(want) &#123; console.log('这里表示执行了一大堆各种代码'); // 其他代码执行完毕，最后执行回调函数 want &amp;&amp; want();&#125;fn(want); 利用回调函数封装，是我们在初学JavaScript时常常会使用的技能。 确保我们想要的代码压后执行，除了利用函数调用栈的执行顺序之外，还可以利用事件队列机制。 1234567891011function want() &#123; console.log('这是你想要执行的代码');&#125;function fn(want) &#123; // 将想要执行的代码放入队列中，根据事件循环的机制，我们就不用非得将它放到最后面了，由你自由选择 want &amp;&amp; setTimeout(want, 0); console.log('这里表示执行了一大堆各种代码');&#125;fn(want); 如果浏览器已经支持了原生的Promise对象，那么我们就知道，浏览器的JS引擎里已经有了Promise队列，这样就可以利用Promise将任务放在它的队列中去。 123456789101112131415161718192021222324function want() &#123; console.log('这是你想要执行的代码');&#125;function fn(want) &#123; console.log('这里表示执行了一大堆各种代码'); // 返回Promise对象 return new Promise(function(resolve, reject) &#123; if (typeof want == 'function') &#123; resolve(want); &#125; else &#123; reject('TypeError: '+ want +'不是一个函数') &#125; &#125;)&#125;fn(want).then(function(want) &#123; want();&#125;)fn('1234').catch(function(err) &#123; console.log(err);&#125;) 看上去变得更加复杂了，但是代码变得更加健壮，处理了错误输入的情况。 为了更好的往下扩展Promise的应用，这里需要先跟大家介绍一下Promsie的基础知识。 Promise对象有三种状态，他们分别是： pending: 等待中，或者进行中，表示还没有得到结果 resolved(Fulfilled): 已经完成，表示得到了我们想要的结果，可以继续往下执行 rejected: 也表示得到结果，但是由于结果并非我们所愿，因此拒绝执行 这三种状态不受外界影响，而且状态只能从pending改变为resolved或者rejected，并且不可逆。在Promise对象的构造函数中，将一个函数作为第一个参数。而这个函数，就是用来处理Promise的状态变化。 1234new Promise(function(resolve, reject) &#123; if(true) &#123; resolve() &#125;; if(false) &#123; reject() &#125;;&#125;) 上面的resolved和reject都为一个函数，它们的作用分别是将状态修改为resolved和reject。 Promise对象中的then方法，可以接收构造函数中处理的状态变化，并分别对应执行。then方法有2个参数，第一个函数接收resolved状态的执行，第二个参数接收reject状态的执行。 12345678910111213141516function fn(num) &#123; return new Promise(function(resolve, reject) &#123; if (typeof num == 'number') &#123; resolve(); &#125; else &#123; reject(); &#125; &#125;).then(function() &#123; console.log('参数是一个number值'); &#125;, function() &#123; console.log('参数不是一个number值'); &#125;)&#125;fn('hahha');fn(1234); then方法的执行结果也会返回一个Promise对象。因此我们还可以继续then的链式执行，这也是解决回调地狱的主要方式。 123456789101112131415161718function fn(num) &#123; return new Promise(function(resolve, reject) &#123; if (typeof num == 'number') &#123; resolve(); &#125; else &#123; reject(); &#125; &#125;) .then(function() &#123; console.log('参数是一个number值'); &#125;) .then(null, function() &#123; console.log('参数不是一个number值'); &#125;)&#125;fn('hahha');fn(1234); then(null, function() {}) 就等同于catch(function() {}) Promise中的数据传递 大家自行从下面的例子中领悟： 123456789101112131415161718192021222324252627var fn = function(num) &#123; return new Promise(function(resolve, reject) &#123; if (typeof num == 'number') &#123; resolve(num); &#125; else &#123; reject('TypeError'); &#125; &#125;)&#125;fn(2).then(function(num) &#123; console.log('first: ' + num); return num + 1;&#125;).then(function(num) &#123; console.log('second: ' + num); return num + 1;&#125;).then(function(num) &#123; console.log('third: ' + num); return num + 1;&#125;);// 输出结果first: 2second: 3third: 4 OK，了解了这些基础知识之后，我们再回过头，利用Promise的知识，对最开始的ajax的例子进行一个简单的封装。看看会是什么样子。 123456789101112131415161718192021222324252627var url = 'https://hq.tigerbrokers.com/fundamental/finance_calendar/getType/2017-02-26/2017-06-10';// 封装一个get请求的方法function getJSON(url) &#123; return new Promise(function(resolve, reject) &#123; var XHR = new XMLHttpRequest(); XHR.open('GET', url, true); XHR.send(); XHR.onreadystatechange = function() &#123; if (XHR.readyState == 4) &#123; if (XHR.status == 200) &#123; try &#123; var response = JSON.parse(XHR.responseText); resolve(response); &#125; catch (e) &#123; reject(e); &#125; &#125; else &#123; reject(new Error(XHR.statusText)); &#125; &#125; &#125; &#125;)&#125;getJSON(url).then(resp =&gt; console.log(resp)); 为了健壮性，处理了很多可能出现的异常，总之，就是正确的返回结果，就resolve一下，错误的返回结果，就reject一下。并且利用上面的参数传递的方式，将正确结果或者错误信息通过他们的参数传递出来。 现在所有的库几乎都将ajax请求利用Promise进行了封装，因此我们在使用jQuery等库中的ajax请求时，都可以利用Promise来让我们的代码更加优雅和简单。这也是Promise最常用的一个场景，因此我们一定要非常非常熟悉它，这样才能在应用的时候更加灵活。 Promise.all 当有一个ajax请求，它的参数需要另外2个甚至多个请求都要有返回结果之后才能确定，那么这个时候，就需要用到Promise.all来帮助我们应对这个场景。 Promise.all接收一个Promise对象组成的数组作为参数，当这个数组所有的Promise对象状态都变成resolved或者reject的时候，它才会去调用then方法。 1234567891011var url = 'https://hq.tigerbrokers.com/fundamental/finance_calendar/getType/2017-02-26/2017-06-10';var url1 = 'https://hq.tigerbrokers.com/fundamental/finance_calendar/getType/2017-03-26/2017-06-10';function renderAll() &#123; return Promise.all([getJSON(url), getJSON(url1)]);&#125;renderAll().then(function(value) &#123; // 建议大家在浏览器中看看这里的value值 console.log(value);&#125;) Promise.race 与Promise.all相似的是，Promise.race都是以一个Promise对象组成的数组作为参数，不同的是，只要当数组中的其中一个Promise状态变成resolved或者rejected时，就可以调用then方法了。而传递给then方法的值也会有所不同。 1234567function renderRace() &#123; return Promise.race([getJSON(url), getJSON(url1)]);&#125;renderRace().then(function(value) &#123; console.log(value);&#125;)]]></content>
  </entry>
  <entry>
    <title><![CDATA[详解面向对象、构造函数、原型与原型链]]></title>
    <url>%2F2019%2F09%2F02%2F%E8%AF%A6%E8%A7%A3%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E3%80%81%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%2F</url>
    <content type="text"><![CDATA[## 对象的定义 在ECMAScript-262中，对象被定义为“无无序属性的集合，其属性可以包含基本值、对象或者函数”。 也就是说，在JavaScript中对象无非就是由一些无序的key-value对组成。其中value可以是基本值，对象或者函数。 1234567// 这里的person就是一个对象var person = &#123; name: 'Tom', age: 18, getName: function() &#123;&#125;, parent: &#123;&#125;&#125; 创建对象 我们可以通过构造函数的方式创建一个对象。 1var obj = new Object(); 也可以通过字面量的方式创建一个简单的对象。 1var obj = &#123;&#125;; 当我们想要给我们创建的简单对象添加方法时，可以这样表示。 1234567891011121314// 可以这样var person = &#123;&#125;;person.name = "TOM";person.getName = function() &#123; return this.name;&#125;// 也可以这样var person = &#123; name: "TOM", getName: function() &#123; return this.name; &#125;&#125; 访问对象的属性和方法。 加入我们有一个简单的对象，如下所示。 1234567ar person = &#123; name: 'TOM', age: '20', getName: function() &#123; return this.name &#125;&#125; 当我们想要访问他的name属性时，可以用如下两种方式访问。 1234person.name// 或者person['name'] 如果我们想要访问的属性名是一个变量时，常常会使用第二种方式。例如我们要同时访问person的name与age，可以这样写： 123['name', 'age'].forEach(function(item) &#123; console.log(person[item]);&#125;) 这种方式一定要重视，记住它以后在我们处理复杂数据的时候会有很大的帮助。 工厂模式使用上面的方式创建对象很简单，但是在很多时候并不能满足我们的需求，就以person对象为例。加入我们在实例开发中，不仅仅需要一个名字叫做TOM的person对象，同时还需要另外一个名为Jake的person对象，虽然它们很多相似之处，但是我们不得不重复写两次。 123456789101112131415var perTom = &#123; name: 'TOM', age: 20, getName: function() &#123; return this.name &#125;&#125;;var perJake = &#123; name: 'Jake', age: 22, getName: function() &#123; return this.name &#125;&#125; 但显然这并不是合理的方式，当相似的对象太多时，大家都会崩溃。 所以我们可以使用工厂模式的方式解决这个问题。顾名思义，工厂模式就是我们提供一个模子，然后通过这个模子复制出我们需要的对象。我们需要多少个，就复制多少个。 123456789101112131415161718var createPerson = function(name, age) &#123; // 声明一个中间对象，该对象就是工厂模式的模子 var o = new Object(); // 依次添加我们需要的属性与方法 o.name = name; o.age = age; o.getName = function() &#123; return this.name; &#125; return o;&#125;// 创建两个实例var perTom = createPerson('TOM', 20);var PerJake = createPerson('Jake', 22); 相信上面的代码并不难理解。也不用吧工厂模式看的太过高大上了。很显然。工厂模式帮助我们解决了重复代码上的麻烦，让我们可以写很少的代码，就能够创建很多个person对象。但是这里还有两个麻烦需要我们注意。 第一个就是我们这样处理是无法识别对象实例的类型。使用instanceof可以识别对象的类型，如下例子： 12345var obj = &#123;&#125;;var foo = function() &#123;&#125;console.log(obj instanceof Object); // trueconsole.log(foo instanceof Function); // true 因此在工厂模式的基础上，我们需要使用构造函数的方式来解决这个麻烦。 构造函数在JavaScript中，new关键字 可以让一个函数变得与众不同。通过下面的例子。我们来一探new关键字的神奇之处。 123456function demo() &#123; console.log(this);&#125;demo(); // windownew demo(); // demo 为了能够直观的感受它们的不同，建议大家动手实践观察一下。很显然，使用new之后函数内部发生了一些变化，让this指向改变。那么new关键字到底做了什么事情呢。 1234567891011121314151617181920212223242526272829303132333435363738// 先一本正经的创建一个构造函数，其实该函数与普通函数并无区别var Person = function(name, age) &#123; this.name = name; this.age = age; this.getName = function() &#123; return this.name; &#125;&#125;// 将构造函数以参数形式传入function New(func) &#123; // 声明一个中间对象，该对象为最终返回的实例 var res = &#123;&#125;; if (func.prototype !== null) &#123; // 将实例的原型指向构造函数的原型 res.__proto__ = func.prototype; &#125; // ret为构造函数执行的结果，这里通过apply，将构造函数内部的this指向修改为指向res，即为实例对象 var ret = func.apply(res, Array.prototype.slice.call(arguments, 1)); // 当我们在构造函数中明确指定了返回对象时，那么new的执行结果就是该返回对象 if ((typeof ret === "object" || typeof ret === "function") &amp;&amp; ret !== null) &#123; return ret; &#125; // 如果没有明确指定返回对象，则默认返回res，这个res就是实例对象 return res;&#125;// 通过new声明创建实例，这里的p1，实际接收的正是new中返回的resvar p1 = New(Person, 'tom', 20);console.log(p1.getName());// 当然，这里也可以判断出实例的类型了console.log(p1 instanceof Person); // true JavaScript内部再通过其他的一些特殊处理，将var p1 = New(Person, &#39;tom&#39;, 20); 等效于var p1 = new Person(&#39;tom&#39;, 20);。就是我们认识的new关键字了。具体怎么处理的，我也不知道，别刨根问底了，一直回答下去太难 - -！ 为了能够判断实例与对象的关系，我们就使用构造函数来搞定。 123456789101112var Person = function(name, age) &#123; this.name = name; this.age = age; this.getName = function() &#123; return this.name; &#125;&#125;var p1 = new Person('Ness', 20);console.log(p1.getName()); // Nessconsole.log(p1 instanceof Person); // true 关于构造函数，如果你暂时不能够理解new的具体实现，就先记住下面这几个结论吧。 与普通函数相比，构造函数并没有任何特别的地方，首字母大写只是我们约定的小规定，用于区分普通函数； new关键字让构造函数具有了与普通函数不同的许多特点，而new的过程中，执行了如下过程： 声明一个中间对象； 将该中间对象的原型指向构造函数的原型； 将构造函数的this，指向该中间对象； 返回该中间对象，即返回实例对象。 原型虽然构造函数解决了判断实例类型的问题，但是说到底，这还是一个对象的复制过程。跟工厂模式颇有相似之处。也就是说。当我们声明了100个person对象，那么就有100个getName方法被重新生成。 这里的每一个getName方法实现的原理其实是一模一样的。但是由于分别属于不同的实例，就不得不一直为getName分配空间。这就是工厂模式存在的第二个麻烦。 对此，我们需要使用原型对象帮我们解决。 我们创建的每一个函数，都可以由一个prototype属性，该属性指向一个对象。这个对象就是我们这里说的原型。 当我们在创建对象时，可以根据自己的需求，选择性的将一些属性和方法通过prototype属性，挂载到原型对象上。而每一个new出来的实例，都有一个__proto__属性，该属性指向构造函数的原型对象，通过这个对象，让实例对象也能够访问原型对象上的方法。因此，当所有的实例都能够通过__proto__访问到原型对象时，原型对象的方法与属性就变成了共有方法与属性。 我们通过一个简单的例子与图示，来了解构造函数、实例与原型三者之间的关系。 1234567891011121314// 声明构造函数function Person(name, age) &#123; this.name = name; this.age = age;&#125;// 通过prototye属性，将方法挂载到原型对象上Person.prototype.getName = function() &#123; return this.name;&#125;var p1 = new Person('tim', 10);var p2 = new Person('jak', 22);console.log(p1.getName === p2.getName); // true 通过图示我们可以看出，构造函数的prototype与所有实例对象的__proto__都指向原型对象。而原型对象的constructor指向构造函数。 除此之外，还可以从图中看出，实例对象实际上对前面我们所说的中间对象的复制，而中间对象中的属性与方法都在构造函数中添加。于是根据构造函数与原型的特性，我们就可以将在构造函数中，通过this声明的属性与方法称为私有变量与方法，它们被当前被某一个实例对象所独有。而通过原型声明的属性与方法，我们可以称之为共有属性与方法，它们可以被所有的实例对象访问。 当我们访问实例对象中的属性或者方法时，会优先访问实例对象自身的属性与方法。 123456789101112131415function Person(name, age) &#123; this.name = name; this.age = age; this.getName = function() &#123; console.log('this is constructor.'); &#125;&#125;Person.prototype.getName = function() &#123; return this.name;&#125;var p1 = new Person('tim', 10);p1.getName(); // this is constructor. 在这个例子中，我们同时在原型与构造函数中都声明了一个getName函数，运行代码的结果表示原型中的访问并没有被访问。 我们还可以通过in来判断。一个对象是否拥有某一个属性或者方法，无论时该属性/方法存在与实例对象还是原型对象。 123456789101112function Person(name, age) &#123; this.name = name; this.age = age;&#125;Person.prototype.getName = function() &#123; return this.name;&#125;var p1 = new Person('tim', 10);console.log('name' in p1); // true in的这种特性最常用的场景之一，就是判断当前页面是否在移动端打开。 123isMobile = 'ontouchstart' in document;// 很多人喜欢用浏览器UA的方式来判断，但并不是很好的方式 更简单的原型写法 根据前面的例子的写法，如果我们要在原型上添加更多的方法，可以这样写， 123456unction Person() &#123;&#125;Person.prototype.getName = function() &#123;&#125;Person.prototype.getAge = function() &#123;&#125;Person.prototype.sayHello = function() &#123;&#125;... ... 除此之外，我还可以使用更为简单的写法。 12345678function Person() &#123;&#125;Person.prototype = &#123; constructor: Person, getName: function() &#123;&#125;, getAge: function() &#123;&#125;, sayHello: function() &#123;&#125;&#125; 这种字面量的写法看上去简单很多，但是有一个需要特别注意的地方。Person.prototype = {}实际上是重新创建了一个{}对象并赋值给Person.prototype，这里的{}并不是最初的那个原型对象。因此它里面并不包含constructor属性。为了保证正确性，我们必须在新创建的{}对象中显示的设置constructor的指向。即上面的constructor: Person。 原型链原型对象其实也是普通的对象。几乎所有的对象都可能是原型对象，也可能是实例对象。而且还可以同时是原型对象与实例对象。这样的一个对象，正是构成原型链的一个节点。因此理解了原型。那么原型链并不是一个多么复杂的概念。 我们知道所有的函数都有一个叫做toString的方法。那么这个方法到底是在那里的呢？ 先随意声明一个函数 1function add() &#123;&#125; 那么我们可以用如下的图来表示这个函数的原型链。 原型链 其中add是Function对象的实例。而Function的原型对象同时又是Object原型的实例。这样就构成了一条原型链。原型链的访问，其实跟作用域链有很大的相似之处，他们都是一次单向的查找过程。因此实例对象能够通过原型链，访问到处于原型链上对象的所有属性与方法。这也是foo最终能够访问到处于Object原型对象上的toString方法的原因。 基于原型链的特性，我们可以很轻松的实现继承。 继承我们常常结合构造函数与原型来创建一个对象，因为构造函数与原型的不同特性，分别解决了我们不同的困扰。因此当我们想要实现继承时，就必须根据构造函数与原型的不同而采取不同的策略。 我们声明一个Person对象，该对象将作为父级，而子级cPerson将要继承Person的所有属性与方法。 12345678function Person(name, age) &#123; this.name = name; this.age = age;&#125;Person.prototype.getName = function() &#123; return this.name;&#125; 首先我们来看构造函数的继承，在上面我们已经了解了构造函数的本质，它其实是在new内部实现的一个复制过程。而我们在继承时想要的是，让父级构造函数中的操作在子级的构造函数中重现一遍即可。我们可以通过call方法来达到目的。 12345// 构造函数的继承function cPerson(name, age, job) &#123; Person.call(this, name, age); this.job = job;&#125; 而原型的继承，则只需要将子级的原型对象设置为父级的一个实例，加入到原型链中即可。 12345// 继承原型cPerson.prototype = new Person(name, age);// 添加更多方法cPerson.prototype.getLive = function() &#123;&#125; 当然关于继承还有更好的方式。 更好的继承假设原型链的终点Object.prototype为原型链的E（end）端，原型链的起点为S（start）端。 通过前面原型链的学习我们知道，处于S端的对象，可以通过S-&gt;E的单向查找，访问到原型链上的所有方法与属性。因此这给继承提够了理论基础。我们只需要在S端添加新的对象，那么新对象就能够通过原型链访问到父级的方法与属性。 因为封装一个对象由构造函数与原型共同组成，因此继承也分别由构造函数的继承与原型的继承。 假设我们已经封装好了一个父类对象Person，如下。 123456789101112var Person = function(name, age) &#123; this.name = name; this.age = age;&#125;Person.prototype.getName = function() &#123; return this.name;&#125;Person.prototype.getAge = function() &#123; return this.age;&#125; 构造函数的继承比较简单，我们可以借助call/apply来实现。假设我们要通过继承封装一个Student的子类对象，那么构造函数可以如下实现。 12345678910111213var Student = function(name, age, grade) &#123; // 通过call方法还原Person构造函数中的所有处理逻辑 Student.call(Person, name, age); this.grade = grade;&#125;// 等价于var Student = function(name, age, grade) &#123; this.name = name; this.age = age; this.grade = grade;&#125; 原型的继承则稍微需要一点思考，首先我们应该考虑，如何将子类对象的原型加入到原型链中？我们只需要让子类对象的原型，成为父类对象的一个实例，然后通过_proto_就可以访问父类对象的原型。这样就继承了父类原型中的方法与属性了。 因此我们可以先封装一个方法，该方法根据父类对象的原型创建一个实例。该实例将会作为子类对象的原型。 1234567891011unction create(proto, options) &#123; // 创建一个空对象 var tmp = &#123;&#125;; // 让这个新的空对象成为父类对象的实例 tmp.__proto__ = proto; // 传入的方法都挂载到新对象上，新的对象将作为子类对象的原型 Object.defineProperties(tmp, options); return tmp;&#125; 简单封装了create对象之后，我们就可以使用该方法来实现原型的继承了。 1234567891011Student.prototype = create(Person.prototype, &#123; // 不要忘了重新指定构造函数 constructor: &#123; value: Student &#125; getGrade: &#123; value: function() &#123; return this.grade &#125; &#125;&#125;) 那么我们来验证一下我们这里实现的继承是否正确。 12345var s1 = new Student('ming', 22, 5);console.log(s1.getName()); // mingconsole.log(s1.getAge()); // 22console.log(s1.getGrade()); // 5 全部都能正常访问，没问题。在ECMAScript5中直接提供了Object.create方法来完成我们上面自己封装的create的功能。因此我们可以直接使用Object.create. 1234567891011tudent.prototype = create(Person.prototype, &#123; // 不要忘了重新指定构造函数 constructor: &#123; value: Student &#125; getGrade: &#123; value: function() &#123; return this.grade &#125; &#125;&#125;) 完整代码如下： 123456789101112131415161718192021222324252627282930313233343536function Person(name, age) &#123; this.name = name; this.age = age;&#125;Person.prototype.getName = function() &#123; return this.name&#125;Person.prototype.getAge = function() &#123; return this.age;&#125;function Student(name, age, grade) &#123; // 构造函数继承 Person.call(this, name, age); this.grade = grade;&#125;// 原型继承Student.prototype = Object.create(Person.prototype, &#123; // 不要忘了重新指定构造函数 constructor: &#123; value: Student &#125; getGrade: &#123; value: function() &#123; return this.grade &#125; &#125;&#125;)var s1 = new Student('ming', 22, 5);console.log(s1.getName()); // mingconsole.log(s1.getAge()); // 22console.log(s1.getGrade()); // 5 属性类型在上面的继承实现上，使用了一个大家可能不太熟悉的方法defineProperties。并且在定义getGrade时使用了一个很奇怪的方式。 12345getGrade: &#123; value: function() &#123; return this.grade &#125;&#125; 这其实是对象中的属性类型。在我们平常的使用中，给对象添加一个属性时，直接使用object.param的方式就可以了，或者直接在对象中挂载。 123var person = &#123; name: 'TOM'&#125; 在ECMAScript5中，对每个属性都添加几个属性类型，来描述这些属性的特点。 configurable: 表示该属性是否能被delete删除。当其值为false时，其他的特性也不能被改变。默认值为true enumerable: 是否能枚举。也就是是否能被for-in遍历。默认值为true writable: 是否能修改值。默认为true value: 该属性的具体值是多少。默认为undefined get: 当我们通过person.name访问name的值时，get将被调用。该方法可以自定义返回的具体值时多少。get默认值为undefined set: 当我们通过person.name = &#39;Jake&#39;设置name的值时，set方法将被调用。该方法可以自定义设置值的具体方式。set默认值为undefined 需要注意的是，不能同时设置value、writable 与 get、set的值。 我们可以通过Object.defineProperty方法来修改这些属性类型。 下面我们用一些简单的例子来演示一下这些属性类型的具体表现。 onfigurable 1234567891011121314151617181920212223// 用普通的方式给person对象添加一个name属性，值为TOMvar person = &#123; name: 'TOM'&#125;// 使用delete删除该属性delete person.name; // 返回true 表示删除成功// 通过Object.defineProperty重新添加name属性// 并设置name的属性类型的configurable为false，表示不能再用delete删除Object.defineProperty(person, 'name', &#123; configurable: false, value: 'Jake' // 设置name属性的值&#125;)// 再次delete，已经不能删除了delete person.name // falseconsole.log(person.name) // 值为Jake// 试图改变valueperson.name = "alex";console.log(person.name) // Jake 改变失败 enumerable 123456789101112131415161718192021222324252627var person = &#123; name: 'TOM', age: 20&#125;// 使用for-in枚举person的属性var params = [];for(var key in person) &#123; params.push(key);&#125;// 查看枚举结果console.log(params); // ['name', 'age']// 重新设置name属性的类型，让其不可被枚举Object.defineProperty(person, 'name', &#123; enumerable: false&#125;)var params_ = [];for(var key in person) &#123; params_.push(key)&#125;// 再次查看枚举结果console.log(params_); // ['age'] writable 12345678910111213141516171819var person = &#123; name: 'TOM'&#125;// 修改name的值person.name = 'Jake';// 查看修改结果console.log(person.name); // Jake 修改成功// 设置name的值不能被修改Object.defineProperty(person, 'name', &#123; writable: false&#125;)// 再次试图修改name的值person.name = 'alex';console.log(person.name); // Jake 修改失败 value 12345678var person = &#123;&#125;// 添加一个name属性Object.defineProperty(person, 'name', &#123; value: 'TOM'&#125;)console.log(person.name) // TOM get/set 12345678910111213141516171819202122var person = &#123;&#125;// 通过get与set自定义访问与设置name属性的方式Object.defineProperty(person, 'name', &#123; get: function() &#123; // 一直返回TOM return 'TOM' &#125;, set: function(value) &#123; // 设置name属性时，返回该字符串，value为新值 console.log(value + ' in set'); &#125;&#125;)// 第一次访问name，调用getconsole.log(person.name) // TOM// 尝试修改name值，此时set方法被调用person.name = 'alex' // alex in set// 第二次访问name，还是调用getconsole.log(person.name) // TOM 请尽量同时设置get、set。如果仅仅只设置了get，那么我们将无法设置该属性值。如果仅仅只设置了set，我们也无法读取该属性的值。 1234567891011121314151617181920Object.defineProperty`只能设置一个属性的属性特性。当我们想要同时设置多个属性的特性时，需要使用我们之前提到过的`Object.definePropertiesvar person = &#123;&#125;Object.defineProperties(person, &#123; name: &#123; value: &apos;Jake&apos;, configurable: true &#125;, age: &#123; get: function() &#123; return this.value || 22 &#125;, set: function(value) &#123; this.value = value &#125; &#125;&#125;)person.name // Jakeperson.age // 22 读取属性的特性值我们可以使用Object.getOwnPropertyDescriptor方法读取某一个属性的特性值。 123456789101112131415161718var person = &#123;&#125;Object.defineProperty(person, 'name', &#123; value: 'alex', writable: false, configurable: false&#125;)var descripter = Object.getOwnPropertyDescriptor(person, 'name');console.log(descripter); // 返回结果如下descripter = &#123; configurable: false, enumerable: false, value: 'alex', writable: false&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[深入理解函数的柯里化]]></title>
    <url>%2F2019%2F09%2F02%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%87%BD%E6%95%B0%E7%9A%84%E6%9F%AF%E9%87%8C%E5%8C%96%2F</url>
    <content type="text"><![CDATA[柯里化是函数的一个比较高级的应用，想要理解它并不简单。 柯里化是指一个函数（假设叫做createCurry），它接收函数A作为参数，运行后能够返回一个新的函数。并且这个新的函数能够处理函数A的剩余参数。 这样的定义可能不太好理解，我们先从下面的例子配合理解。 如果有一个接收三个参数的函数A： 123function A(a, b, c) &#123; // do something&#125; 又假如我们有一个已经封装好了的柯里化createCurry。它接收bar作为参数，能够将A转化为柯里化函数，返回结果就是这个被转化之后的函数。 1var _A = createCurry(A); 那么_A作为createCurry运行的返回函数，它能够处理A的剩余参数。因此下面的运行结果都是等价的。 12345_A(1, 2, 3);_A(1, 2)(3);_A(1)(2, 3);_A(1)(2)(3);A(1, 2, 3); 函数A被createCurry转化之后得到柯里化函数A，A能够处理A的所有剩余参数。因此柯里化也被成为部分求值。 在简单的场景下，我们可以不用借助柯里化通用式来转化得到柯里化函数，我们可以凭借眼力自己封装。 例如有一个简单的加法函数，他能够将自身的三个参数加起来并返回计算结果。 123function add(a, b, c) &#123; return a + b + c;&#125; 那么add函数的柯里化函数_add则可以如下： 1234567function _add(a) &#123; return function(b) &#123; return function(c) &#123; return a + b + c; &#125; &#125;&#125; 因此下面的运算方式是等价的。 12add(1, 2, 3);_add(1)(2)(3); 当然，柯里化通用式具备更加强大的能力，我们靠眼力自己封装的柯里化函数则自由度偏低。因此我们仍然需要知道自己如何去封装这样一个柯里化的通用式。 首先通过_add可以看出，柯里化函数的运行过程其实是一个参数的收集过程，我们将每一次传入的参数收集起来，并在最里层里面处理。因此我们在实现createCurry时，可以借助这个思路来进行封装。 封装如下: 12345678910111213141516171819// 简单实现，参数只能从右到左传递function createCurry(func, args) &#123; var arity = func.length; var args = args || []; return function() &#123; var _args = [].slice.call(arguments); [].push.apply(_args, args); // 如果参数个数小于最初的func.length，则递归调用，继续收集参数 if (_args.length &lt; arity) &#123; return createCurry.call(this, func, _args); &#125; // 参数收集完毕，则执行func return func.apply(this, _args); &#125;&#125; 尽管我已经做了足够详细的注解，但是我想理解起来也并不是那么容易，因此建议大家用点耐心多阅读几遍。这个createCurry函数的封装借助闭包与递归，实现了一个参数收集，并在收集完毕之后执行所有参数的一个过程。 因此聪明的读者可能已经发现，把函数经过createCurry转化为一个柯里化函数，最后执行的结果，不是正好相当于执行函数自身吗？柯里化是不是把简单的问题复杂化了？ 如果你能够提出这样的问题，那么说明你确实已经对柯里化有了一定的了解。柯里化确实是把简答的问题复杂化了，但是复杂化的同时，我们在使用函数时拥有了更加多的自由度。而这里对于函数参数的自由处理，正是柯里化的核心所在。 我们来举一个非常常见的例子。 如果我们想要验证一串数字是否是正确的手机号，那么按照普通的思路来做，大家可能是这样封装，如下： 123function checkPhone(phoneNumber) &#123; return /^1[34578]\d&#123;9&#125;$/.test(phoneNumber);&#125; 而如果我们想要验证是否是邮箱呢？这么封装： 123function checkEmail(email) &#123; return /^(\w)+(\.\w+)*@(\w)+((\.\w+)+)$/.test(email);&#125; 我们还可能会遇到验证身份证号，验证密码等各种验证信息，因此在实践中，为了统一逻辑，，我们就会封装一个更为通用的函数，将用于验证的正则与将要被验证的字符串作为参数传入。 123function check(targetString, reg) &#123; return reg.test(targetString);&#125; 但是这样封装之后，在使用时又会稍微麻烦一点，因为会总是输入一串正则，这样就导致了使用时的效率低下。 12check(/^1[34578]\d&#123;9&#125;$/, '14900000088');check(/^(\w)+(\.\w+)*@(\w)+((\.\w+)+)$/, 'test@163.com'); 那么这个时候，我们就可以借助柯里化，在check的基础上再做一层封装，以简化使用。 1234var _check = createCurry(check);var checkPhone = _check(/^1[34578]\d&#123;9&#125;$/);var checkEmail = _check(/^(\w)+(\.\w+)*@(\w)+((\.\w+)+)$/); 最后在使用的时候就会变得更加直观与简洁了。 12checkPhone('183888888');checkEmail('xxxxx@test.com'); 经过这个过程我们发现，柯里化能够应对更加复杂的逻辑封装。当情况变得多变，柯里化依然能够应付自如。 虽然柯里化确实在一定程度上将问题复杂化了，也让代码更加不容易理解，但是柯里化在面对复杂情况下的灵活性却让我们不得不爱。 当然这个案例本身情况还算简单，所以还不能够特别明显的凸显柯里化的优势，我们的主要目的在于借助这个案例帮助大家了解柯里化在实践中的用途。 我们继续来思考一个例子。这个例子与map有关。在高阶函数的章节中，我们分析了封装map方法的思考过程。由于我们没有办法确认一个数组在遍历时会执行什么操作，因此我们只能将调用for循环的这个统一逻辑封装起来，而具体的操作则通过参数传入的形式让使用者自定义。这就是map函数。 但是，这是针对了所有的情况我们才会这样想。 实践中我们常常会发现，在我们的某个项目中，针对于某一个数组的操作其实是固定的，也就是说，同样的操作，可能会在项目的不同地方调用很多次。 于是，这个时候，我们就可以在map函数的基础上，进行二次封装，以简化我们在项目中的使用。假如这个在我们项目中会调用多次的操作是将数组的每一项都转化为百分比 1 –&gt; 100%。 普通思维下我们可以这样来封装。 1234567function getNewArray(array) &#123; return array.map(function(item) &#123; return item * 100 + '%' &#125;)&#125;getNewArray([1, 2, 3, 0.12]); // ['100%', '200%', '300%', '12%']; 而如果借助柯里化来二次封装这样的逻辑，则会如下实现： 123456789101112function _map(func, array) &#123; return array.map(func);&#125;var _getNewArray = createCurry(_map);var getNewArray = _getNewArray(function(item) &#123; return item * 100 + '%'&#125;)getNewArray([1, 2, 3, 0.12]); // ['100%', '200%', '300%', '12%'];getNewArray([0.01, 1]); // ['1%', '100%'] 如果我们的项目中的固定操作是希望对数组进行一个过滤，找出数组中的所有Number类型的数据。借助柯里化思维我们可以这样做。 123456789101112131415161718192021222324252627282930function _filter(func, array) &#123; return array.filter(func);&#125;var _find = createCurry(_filter);var findNumber = _find(function(item) &#123; if (typeof item == 'number') &#123; return item; &#125;&#125;)findNumber([1, 2, 3, '2', '3', 4]); // [1, 2, 3, 4]// 当我们继续封装另外的过滤操作时就会变得非常简单// 找出数字为20的子项var find20 = _find(function(item, i) &#123; if (typeof item === 20) &#123; return i; &#125;&#125;)find20([1, 2, 3, 30, 20, 100]); // 4// 找出数组中大于100的所有数据var findGreater100 = _find(function(item) &#123; if (item &gt; 100) &#123; return item; &#125;&#125;)findGreater100([1, 2, 101, 300, 2, 122]); // [101, 300, 122] 我采用了与check例子不一样的思维方向来想大家展示我们在使用柯里化时的想法。目的是想告诉大家，柯里化能够帮助我们应对更多更复杂的场景。 当然不得不承认，这些例子都太简单了，简单到如果使用柯里化的思维来处理他们显得有一点多此一举，而且变得难以理解。因此我想读者朋友们也很难从这些例子中感受到柯里化的魅力。不过没关系，如果我们能够通过这些例子掌握到柯里化的思维，那就是最好的结果了。在未来你的实践中，如果你发现用普通的思维封装一些逻辑慢慢变得困难，不妨想一想在这里学到的柯里化思维，应用起来，柯里化足够强大的自由度一定能给你一个惊喜。 当然也并不建议在任何情况下以炫技为目的的去使用柯里化，在柯里化的实现中，我们知道柯里化虽然具有了更多的自由度，但同时柯里化通用式里调用了arguments对象，使用了递归与闭包，因此柯里化的自由度是以牺牲了一定的性能为代价换来的。只有在情况变得复杂时，才是柯里化大显身手的时候。 额外知识补充无限参数的柯里化。 该部分内容可忽略 在前端面试中，你可能会遇到这样一个涉及到柯里化的题目。 1234// 实现一个add方法，使计算结果能够满足如下预期：add(1)(2)(3) = 6;add(1, 2, 3)(4) = 10;add(1)(2)(3)(4)(5) = 15; 这个题目的目的是想让add执行之后返回一个函数能够继续执行，最终运算的结果是所有出现过的参数之和。而这个题目的难点则在于参数的不固定。我们不知道函数会执行几次。因此我们不能使用上面我们封装的createCurry的通用公式来转换一个柯里化函数。只能自己封装，那么怎么办呢？在此之前，补充2个非常重要的知识点。 一个是ES6函数的不定参数。假如我们有一个数组，希望把这个数组中所有的子项展开传递给一个函数作为参数。那么我们应该怎么做？ 12345// 大家可以思考一下，如果将args数组的子项展开作为add的参数传入function add(a, b, c, d) &#123; return a + b + c + d;&#125;var args = [1, 3, 100, 1]; 在ES5中，我们可以借助之前学过的apply来达到我们的目的。 1add.apply(null, args); // 105 而在ES6中，提供了一种新的语法来解决这个问题，那就是不定参。写法如下： 1add(...args); // 105 这两种写法是等效的。OK，先记在这里。在接下的实现中，我们会用到不定参数的特性。 第二个要补充的知识点是函数的隐式转换。当我们直接将函数参与其他的计算时，函数会默认调用toString方法，直接将函数体转换为字符串参与计算。 12function fn() &#123; return 20 &#125;console.log(fn + 10); // 输出结果 function fn() &#123; return 20 &#125;10 但是我们可以重写函数的toString方法，让函数参与计算时，输出我们想要的结果。 1234function fn() &#123; return 20; &#125;fn.toString = function() &#123; return 30 &#125;console.log(fn + 10); // 40 除此之外，当我们重写函数的valueOf方法也能够改变函数的隐式转换结果。 1234function fn() &#123; return 20; &#125;fn.valueOf = function() &#123; return 60 &#125;console.log(fn + 10); // 70 当我们同时重写函数的toString方法与valueOf方法时，最终的结果会取valueOf方法的返回结果。 12345function fn() &#123; return 20; &#125;fn.valueOf = function() &#123; return 50 &#125;fn.toString = function() &#123; return 30 &#125;console.log(fn + 10); // 60 补充了这两个知识点之后，我们可以来尝试完成之前的题目了。add方法的实现仍然会是一个参数的收集过程。当add函数执行到最后时，仍然返回的是一个函数，但是我们可以通过定义toString/valueOf的方式，让这个函数可以直接参与计算，并且转换的结果是我们想要的。而且它本身也仍然可以继续执行接收新的参数。实现方式如下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445function add() &#123; // 第一次执行时，定义一个数组专门用来存储所有的参数 var _args = [].slice.call(arguments); // 在内部声明一个函数，利用闭包的特性保存_args并收集所有的参数值 var adder = function () &#123; var _adder = function() &#123; // [].push.apply(_args, [].slice.call(arguments)); _args.push(...arguments); return _adder; &#125;; // 利用隐式转换的特性，当最后执行时隐式转换，并计算最终的值返回 _adder.toString = function () &#123; return _args.reduce(function (a, b) &#123; return a + b; &#125;); &#125; return _adder; &#125; // return adder.apply(null, _args); return adder(..._args);&#125;var a = add(1)(2)(3)(4); // f 10var b = add(1, 2, 3, 4); // f 10var c = add(1, 2)(3, 4); // f 10var d = add(1, 2, 3)(4); // f 10// 可以利用隐式转换的特性参与计算console.log(a + 10); // 20console.log(b + 20); // 30console.log(c + 30); // 40console.log(d + 40); // 50// 也可以继续传入参数，得到的结果再次利用隐式转换参与计算console.log(a(10) + 100); // 120console.log(b(10) + 100); // 120console.log(c(10) + 100); // 120console.log(d(10) + 100); // 120// 其实上栗中的add方法，就是下面这个函数的柯里化函数，只不过我们并没有使用通用式来转化，而是自己封装function add(...args) &#123; return args.reduce((a, b) =&gt; a + b);&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[函数与函数式编程]]></title>
    <url>%2F2019%2F09%2F01%2F%E5%87%BD%E6%95%B0%E4%B8%8E%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[纵观JavaScript中所有必须需要掌握的重点知识中，函数时我们在初学的时候最容易忽视的一个知识点。在学习的过程中，可能会有很多人、很多文章告诉你面向对象很重要，原型很重要，可是却很少有人告诉你，面向对象中所有的重点难点，几乎都与函数息息相关。 函数声明、函数表达式、匿名函数与自执行函数关于函数在实际开发中的应用，大体可以总结为函数声明、函数表达式、匿名函数、自执行函数。 函数声明 我们知道JavaScript中，有两种声明方式，一个是使用var的变量声明，另一个是使用function的函数声明。 变量对象的创建过程中，函数声明比变量声明具有更优先的执行顺序，即我们常常提到的函数声明提前。因此我们在执行上下文中，无论在任何位置声明了函数，我们都可以在同一个执行上下文直接使用该函数。 12345fn(); // functionfunction fn() &#123; console.log('function');&#125; 函数表达式 与函数声明不同，函数表达式使用var声明，那么我们在确认他是否可以正确使用的时候就必须依照var的规则进行判断，即变量声明。我们知道使用var进行变量声明，其实是进行了两边操作。 123456// 变量声明var a = 20;// 实际执行顺序var a = undefined; // 变量声明，初始值undefined，变量提升，提升顺序次于function声明a = 20; // 变量赋值，该操作不会提升 同样的道理，当我们使用变量声明的方式来声明函数时，就是我们常常说的函数表达式。函数表达式的提升方式与变量声明一致。 1234fn(); // 报错var fn = function() &#123; console.log('function');&#125; 上面例子的执行顺序为： 12345var fn = undefined; // 变量声明提升fn(); // 执行报错fn = function() &#123; // 赋值操作，此时将后边函数的引用赋值给fn console.log('function');&#125; 因此，由于声明方式的不同，导致了函数声明与函数表达式在使用上的一些差异需要我们注意，除此之外，这两种形式的函数在使用上并无不同。 对于上面例子中，函数表达式中的赋值操作，在其他一些地方也会被经常使用，我们清楚其中的关系即可。 12345678910111213141516171819202122// 在构造函数中添加方法function Person(name) &#123; this.name = name; this.age = age; // 在构造函数内部中添加方法 this.getAge = function() &#123; return this.age; &#125; this.&#125;// 给原型添加方法Person.prototype.getName = function() &#123; return this.name;&#125;// 在对象中添加方法var a = &#123; m: 20, getM: function() &#123; return this.m; &#125;&#125; 匿名函数 在上面我们大概讲述了函数表达式中的赋值操作。而匿名函数，顾名思义，就是指没有被显示进行赋值操作的函数。它的使用场景，多作为一个参数传入另一个函数中。 12345678var a = 10;var fn = function(bar, num) &#123; return bar() + num;&#125;fn(function() &#123; return a;&#125;, 20) 在上面的例子中，fn的第一个参数传入了一个匿名函数。虽然该匿名函数没有显示的进行赋值操作，我们没有办法再外部执行上下文中引用它。但是在fn函数内部，我们将该匿名函数赋值给了变量bar，保存在了fn变量对象的arguments对象中。 1234567891011121314151617181920// 变量对象在fn上下文执行过程中的创建阶段VO(fn) = &#123; arguments: &#123; bar: undefined, num: undefined, length: 2 &#125;&#125;// 变量对象在fn上下文执行过程中的执行阶段// 变量对象变为活动对象，并完成赋值操作与执行可执行代码VO -&gt; AOAO(fn) = &#123; arguments: &#123; bar: function() &#123; return a &#125;, num: 20, length: 2 &#125;&#125; 由于匿名函数传入另一个函数之后，最终会在另一个函数中执行，因此我们也常常称这个匿名函数为回调函数。匿名函数的这个应用场景几乎承担了函数的所有难以理解的知识点。 函数自执行与块级作用域 在ES5中，没有块级作用域，因此我们常常使用函数自执行的方式来模仿块级作用域，这样就提供了一个独立的执行上下文，结合闭包，就为模块化提供了基础。而函数自执行，其实就是匿名函数的一种应用。 123(function() &#123; // ...&#125;)(); 一个模块往往可以包括：私有变量、私有方法、公有变量和公有方法。 根据作用域链的单向访问，外面可能很容易在这个独立二点模块中，外部执行环境是无法访问内部的任何变量与方法的，因此我们可以很容易的创建属于这个模块的私有变量与私有方法。 12345678910(function() &#123; // 私有变量 var age = 20; var name = 'Tom'; // 私有方法 function getName() &#123; return `your name is ` + name; &#125;&#125;)(); 但是公有方法与变量应该怎么办？利用闭包，我们可以访问到执行上下文内部的变量和方法，因此，我们只需要根据闭包的定义，创建一个闭包，将你认为需要公开的变量和方法开放出来即可。 123456789101112131415161718(function() &#123; // 私有变量 var age = 20; var name = 'Tom'; // 私有方法 function getName() &#123; return `your name is ` + name; &#125; // 共有方法 function getAge() &#123; return age; &#125; // 将引用保存在外部执行环境的变量中，形成闭包，防止该执行环境被垃圾回收 window.getAge = getAge;&#125;)(); 闭包在模块中有着重要作用，为了让大家更进一步的理解闭包，我们看看jQuery是如何利用模块与闭包的。 123456789101112131415161718192021222324// 使用函数自执行的方式创建模块(function(window, undefined) &#123; // 声明jQuery构造函数 var jQuery = function(name) &#123; // 主动在构造函数中，返回一个jQuery实例 return new jQuery.fn.init(name); &#125; // 添加原型方法 jQuery.prototype = jQuery.fn = &#123; constructor: jQuery, init:function() &#123; ... &#125;, css: function() &#123; ... &#125; &#125; jQuery.fn.init.prototype = jQuery.fn; // 将jQuery改名为$，并将引用保存在window上，形成闭包，对外开发jQuery构造函数，这样我们就可以访问所有挂载在jQuery原型上的方法了 window.jQuery = window.$ = jQuery; &#125;)(window);// 在使用时，我们直接执行了构造函数，因为在jQuery的构造函数中通过一些手段，返回的是jQuery的实例，所以我们就不用再每次用的时候在自己new了$('#div1'); 函数参数传递方式：按值传递基本数据类型复制，是直接值发生了复制，因此改变后，各自相互不影响。但是引用数据类型的复制，是保存在变量对象中的引用发生了复制，因此复制之后的这两个引用实际访问的实际是同一个堆内存中的值。当改变其中一个时，另外一个自然也被改变。如下例。 123456789var a = 20;var b = a;b = 10;console.log(a); // 20var m = &#123; a: 1, b: 2 &#125;var n = m;n.a = 5;console.log(m.a) // 5 当值作为函数的参数传递到函数内部时，也有同样的差异。我们知道，函数的参数在进入函数后，实际时被保存在函数的变量对象中，因此这个时候相当于发送了一次复制。 12345678var a = 20;function fn(a) &#123; a = a + 10; return a;&#125;fn(a);console.log(a); // 20 正是由于这样的不同，导致了许多人在理解函数参数的传递方式时，就有许多困惑。到底是按值传递还是按引用传递？实际上结论仍然是按值传递，只不过当我们期望传递一个引用类型时，真正传递的，只是这个引用类型保存在变量对象中的引用而已。为了说明这个问题，我们看看下面这个例子。 123456789101112var person = &#123; name: 'Nicholas', age: 20&#125;function setName(obj) &#123; // 传入一个引用 obj = &#123;&#125;; // 将传入的引用指向另外的值 obj.name = 'Greg'; // 修改引用的name属性&#125;setName(person);console.log(person.name); // Nicholas 未被改变 在上面的例子中，如果person是按引用传递，那么person就会自动被修改为指向其name属性值为Gerg的新对象。但是我们从结果中看到，person对象并未发生任何改变，因此只是在函数内部引用被修改而已。 函数式编程虽然JavaScript并不是一门纯函数式编程语言，但是它使用了许多函数式编程的特性。因此了解这些特性可以让我们更加了解自己的代码。 当我们需要使用一个函数时，通常情况下就是想要将一些功能、逻辑等封装起来。相信大家对封装这个概念并不陌生。 我们通常通过函数封装来完成一个事情，例如我想要计算任何三个数的和，我们就可以将这三个数作为参数，封装一个简单的函数。 封装一个简单的函数。 123function add(a, b, c) &#123; return a + b + c;&#125; 当我们想要计算三个数的和时，直接调用该方法即可。 1add(1, 2, 3); // 6 当然，当我们想要做的事情比较简单的时候，可能还看不出来封装成为函数之后带来的便利。如果我们想要做的事情稍微复杂一点呢。例如我想要计算一个数组中的所有子项目的和。 12345function mergeArr(arr) &#123; var result = 0; for(var i = 0; i &lt; arr.length; i++) &#123; result += arr[i] &#125; return result;&#125; 如果我们不通过函数封装的方式，那么再每次想要实现这个功能时，就不得不重新使用一次for循环，这样的后果就是我们的代码中充斥着越来越多的重复代码。而封装之后，当我们想要再次做这件事情的时候，只需要一句话就可以了。 1mergeArr([1, 2, 3, 4, 5]); 当然，我相信大家对于函数封装的意义都应该有非常明确的认知，但是我们要面临的问题是，当我们想要去封装一个函数时，如何做才是最佳实践呢？ 函数式编程能给我们答案。 我们在初学时，往往会不由自主的使用命令式编程的风格来完成我们想要干的事情。因为命令式编程更加的简单，直白。例如我们现在有一个数组，array = [1, 3, &#39;h&#39;, 5, &#39;m&#39;, &#39;4&#39;]，现在想要找出这个数组中的所有类型为number的子项。当我们使用命令式编程思维时，可能就会直接这样做。 1234567var array = [1, 3, 'h', 5, 'm', '4'];var res = [];for(var i = 0; i &lt; array.length; i ++) &#123; if (typeof array[i] === 'number') &#123; res.push(array[i]); &#125;&#125; 在这种实现方式中，我们平铺直叙的实现了我们的目的。这样做的问题在于，当我们在另外的时刻，想要找出另外一个数组中所有的子项时，我们不得不把同样的逻辑再写一次。当出现次数变多时，我们的代码也变得更加糟糕且难以维护。 而函数式编程的思维则建议我们将这种会多次出现的功能封装起来以备调用。 123456789101112131415function getNumbers(array) &#123; var res = []; array.forEach(function(item) &#123; if (typeof item === 'number') &#123; res.push(item); &#125; &#125;) return res;&#125;// 以上是我们的封装，以下是功能实现var array = [1, 3, 'h', 5, 'm', '4'];var res = getNumbers(array); 因此当我们将功能封装之后，我们实现同样的功能时，只需要写一行代码。而如果未来需求变动，或者稍作修改，我们只需要对getNumbers方法进行调整就可以了。而且我们在使用时，只需要关心这个方法能做什么，而不用关心他具体是怎么实现的。这也是函数式编程思维与命令式不同的地方之一。 函数式编程思维还具有以下几个特征。 函数时第一等公民 所谓“第一等公民（first class）”，指的时函数与其他数据类型一样，处于平等地位，可以赋值给其他变量，也可以作为参数，传入另一个函数，或者作为别的函数的返回值。这些场景，我们应该见过很多。 123456789var a = function foo() &#123;&#125; // 赋值function fn(function() &#123;&#125;, num) &#123;&#125; // 函数作为参数// 函数作为返回值function var() &#123; return function() &#123; ... ... &#125;&#125; 当然，这都是JavaScript的基本概念。但是我想很多人，甚至包括正在阅读的你自己都可能会无视这些概念。可以用一个简单的例子来验证一下。 我们先自定义这样一个函数。 123function delay() &#123; console.log('5000ms之后执行该方法.');&#125; 现在要做的是，如果要求你结合setTimeout方法，让delay方法延迟5000ms执行，应该怎么做？ 其实很简单，对不对，直接这样就可以了。 123var timer = setTimeout(function() &#123; delay();&#125;, 5000); 那么现在问题来了，如果你对函数是一等公民有一个深刻的认知，我想你会发现上面这种写法其实是有一些问题的。所以思考一下，问题出在哪里？ 函数既然能够作为一个参数传入另外一个函数，那么我们是不是可以直接将delay作为setTimeout的第一个参数，而不用额外的多加一层匿名函数呢？ 因此，其实最正确的解法应该这样写。 1var timer = setTimeout(delay, 5000); 当然，如果你已经提前想到这样做了，那么恭喜你，说明你在JavaScript上比普通人更有天赋。其实第一种糟糕的方式很多人都在用，包括有多年工作经验的人也没有完全避免。而他们甚至还不知道自己问题出在什么地方。 在未来的实践中，你还会遇到更多类似的场景。为了验证读者朋友们的理解，我们不妨来思考一下如何如何优化下面的代码。 12345678910function getUser(path, callback) &#123; return $.get(path, function(info) &#123; return callback(info); &#125;)&#125;getUser('/api/user', function(resp) &#123; // resp为成功请求之后返回的数据 console.log(resp);&#125;) 优化的原理和setTimeout的例子一模一样，我这里卖个关子，不打算告诉大家结论，仅提示一句，getUser优化之后，仅有一句代码。考验大家学习成果的时候到了 ^ ^。 只用”表达式”，不用”语句” “表达式”（expression）是一个单纯的运算过程，总是有返回值；”语句”（statement）是执行某种操作，没有返回值。函数式编程要求，只使用表达式，不使用语句。也就是说，每一步都是单纯的运算，而且都有返回值。 假如我们的项目中，多处需要改变某个元素的背景色。因此我们可以这样封装一下。 12345678var ele = document.querySelector('.test');function setBackgroundColor(color) &#123; ele.style.backgroundColor = color;&#125;// 多处使用setBackgroundColor('red');setBackgroundColor('#ccc'); 我们可以很明显的感受到，setBackgroundColor封装的仅仅只是一条语句。这并不是理想的效果。函数式编程期望一个函数有输入，也有输出。因此良好的习惯应该如下做。 123456789function setBackgroundColor(ele, color) &#123; ele.style.backgroundColor = color; return color;&#125;// 多处使用var ele = document.querySelector('.test');setBackgroundColor(ele, 'red');setBackgroundColor(ele, '#ccc'); 了解这一点，可以让我们自己在封装函数的时候养成良好的习惯。 纯函数 相同的输入总会得到相同的输出，并且不会产生副作用的函数，就是纯函数。 所谓”副作用”（side effect），指的是函数内部与外部互动（最典型的情况，就是修改全局变量的值），产生运算以外的其他结果。 函数式编程强调没有”副作用”，意味着函数要保持独立，所有功能就是返回一个新的值，没有其他行为，尤其是不得修改外部变量的值。 即所谓的只要是同样的参数传入，返回的结果一定是相等的。 例如我们期望封装一个函数，能够得到传入数组的最后一项。那么可以通过下面两种方式来实现。 123456789101112function getLast(arr) &#123; return arr[arr.length];&#125;function getLast_(arr) &#123; return arr.pop();&#125;var source = [1, 2, 3, 4];var last = getLast(source); // 返回结果4 原数组不变var last_ = getLast_(source); // 返回结果4 原数据最后一项被删除 getLast与getLast_虽然同样能够获得数组的最后一项值，但是getLast_改变了原数组。而当原始数组被改变，那么当我们再次调用该方法时，得到的结果就会变得不一样。这样不可预测的封装方式，在我们看来是非常糟糕的。它会把我们的数据搞得非常混乱。在JavaScript原生支持的数据方法中，也有许多不纯的方法，我们在使用时需要非常警惕，我们要清晰的知道原始数据的改变是否会留下隐患。 12345678910111213141516var source = [1, 2, 3, 4, 5];source.slice(1, 3); // 纯函数 返回[2, 3] source不变source.splice(1, 3); // 不纯的 返回[2, 3, 4] source被改变source.pop(); // 不纯的source.push(6); // 不纯的source.shift(); // 不纯的source.unshift(1); // 不纯的source.reverse(); // 不纯的// 我也不能短时间知道现在source被改变成了什么样子，干脆重新约定一下source = [1, 2, 3, 4, 5];source.concat([6, 7]); // 纯函数 返回[1, 2, 3, 4, 5, 6, 7] source不变source.join('-'); // 纯函数 返回1-2-3-4-5 source不变 闭包 闭包是函数式编程语言的重要特性，我也在前面几篇文章中说了很多关于闭包的内容。这里不再赘述。]]></content>
  </entry>
  <entry>
    <title><![CDATA[全方位解读this]]></title>
    <url>%2F2019%2F09%2F01%2F%E5%85%A8%E6%96%B9%E4%BD%8D%E8%A7%A3%E8%AF%BBthis%2F</url>
    <content type="text"><![CDATA[我们在学习JavaScript的过程中，由于对一些概念理解得不是很清楚，但是又想要通过一些方式把它记下来，于是就很容易草率的给这些概念定下一些方便自己记忆的有偏差的结论.有的不准确的结论在网上还广为流传。 比如对于this指向的理解中，有这样一种说法：谁调用它，this就指向谁。在我刚开始学习this的时候，我是非常相信这句话的。因为在一些情况下，这样理解也还算说得通。可是我常常会在开发中遇到一些不一样的情况，一个由于this的错误调用，可以让我懵逼一整天。那个时候我也查资料，在群里问大神，可是我仍然搞不清楚“我特么到底错哪里了”。其实只是因为我心中有一个不太准确的结论。 所以，我认为需要有这样一篇文章，来帮助大家全方位的解读this。让大家对this，有一个正确的，全面的认知。 首先我们需要得到一个非常重要的、一定要牢记在心的结论，this的指向，是在函数被调用的时候确定的。也就是执行上下文被创建时确定的。因此，一个函数中this指向，可以是非常灵活的。比如下面的例子中，同一个函数由于调用方式的不同，this指向了不一样的对象。 1234567891011ar a = 10;var obj = &#123; a: 20&#125;function fn () &#123; console.log(this.a);&#125;fn(); // 10fn.call(obj); // 20 除此之外，在函数执行过程中，this一旦被确定，就不可更改了。 1234567891011var a = 10;var obj = &#123; a: 20&#125;function fn () &#123; this = obj; // 这句话试图修改this，运行后会报错 console.log(this.a);&#125;fn(); 全局对象中的this对于全局对象的this，我之前在总结变量对象的时候提到过，它是一个比较特殊的存在。全局环境中的this，指向它本身。因此，这也相对简单，没有那么多复杂的情况需要考虑。 12345678910111213// 通过this绑定到全局对象this.a2 = 20;// 通过声明绑定到变量对象，但在全局环境中，变量对象就是它自身var a1 = 10;// 仅仅只有赋值操作，标识符会隐式绑定到全局对象a3 = 30;// 输出结果会全部符合预期console.log(a1);console.log(a2);console.log(a3); 函数中的this在总结函数中this指向之前，我们先来体验一下函数中this的不定态。 不定。 123456// demo01var a = 20;function fn() &#123; console.log(this.a);&#125;fn(); 123456789// demo02var a = 20;function fn() &#123; function foo() &#123; console.log(this.a); &#125; foo();&#125;fn(); 123456789101112// demo03var a = 20;var obj = &#123; a: 10, c: this.a + 20, fn: function () &#123; return this.a; &#125;&#125;console.log(obj.c);console.log(obj.fn()); 这几个例子需要花点时间仔细感受一下，如果你暂时没想明白怎么回事，也不用着急，我们一点一点来分析。 在分析前，我们先直接了当的抛出结论。 在一个函数上下文，this由调用者提供，由调用函数的方式来决定。如果调用的函数，被某一个对象所拥有，那么该函数在调用时，内部的this指向该对象。如果函数独立调用，那么该函数内部的this，则指向undefined。但是在非严格模式中，当this指向undefined时，它会被自动指向全局对象。 从结论中我们可以看出，想要准确确定this指向，找到函数的调用者以及区分他是否是独立调用就变得十分关键。 12345678// 为了能够准确判断，我们在函数内部使用严格模式，因为非严格模式会自动指向全局function fn() &#123; 'use strict'; console.log(this);&#125;fn(); // fn是调用者，独立调用window.fn(); // fn是调用者，被window所拥有 在上面的简单例子中，fn()作为独立调用者，按照定义的理解，它内部的this指向就为undefined。而window.fn()则因为fn被window所拥有，内部的this就指向了window对象。 那么掌握了这个规则，现在回过头去看看上面的三个例子，通过添加/去除严格模式，那么你就会发现，原来this已经变得不那么虚无缥缈，已经有迹可循了。 但是我们需要特别注意的是demo03。在demo03中，对象obj中的c属性使用this.a + 20来计算。这里我们需要明确的一点是，单独的{}是不会形成新的作用域的，因此这里的this.a，由于并没有作用域的限制，所以它仍然处于全局作用域之中。所以这里的this其实是指向的window对象。 那么我们修改一下demo03的代码，大家可以思考一下会发生什么变化。 12345678910111213141516'use strict';var a = 20;function foo () &#123; var a = 1; var obj = &#123; a: 10, c: this.a + 20, fn: function () &#123; return this.a; &#125; &#125; return obj.c;&#125;console.log(foo()); // ？console.log(window.foo()); // ? 实际开发中，并不推荐这样使用this； 上面多次提到的严格模式，需要大家认真对待，因为在实际开发中，现在基本已经全部采用严格模式了，而最新的ES6，也是默认支持严格模式。 再来看一些容易理解错误的例子，加深一下对调用者与是否独立运行的理解。 1234567891011var a = 20;var foo = &#123; a: 10, getA: function () &#123; return this.a; &#125;&#125;console.log(foo.getA()); // 10var test = foo.getA;console.log(test()); // 20 foo.getA()中，getA是调用者，他不是独立调用，被对象foo所拥有，因此它的this指向了foo。而test()作为调用者，尽管他与foo.getA的引用相同，但是它是独立调用的，因此this指向undefined，在非严格模式，自动转向全局window。 稍微修改一下代码，大家自行理解。 123456789var a = 20;function getA() &#123; return this.a;&#125;var foo = &#123; a: 10, getA: getA&#125;console.log(foo.getA()); // 10 灵机一动，再来一个。如下例子。 123456789101112131415function foo() &#123; console.log(this.a)&#125;function active(fn) &#123; fn(); // 真实调用者，为独立调用&#125;var a = 20;var obj = &#123; a: 10, getA: foo&#125;active(obj.getA); 使用call，apply显示指定thisJavaScript内部提供了一种机制，让我们可以自行手段设置this的指向。它们就是call与apply。所有的函数都具有两个方法，它们除了参数略有不同，其功能完全一样。它们的第一个参数都为this将要指向的对象。 如下例子，fn并非属于对象obj的方法，但是通过call，我们将fn内部的this绑定obj，因此就可以使用this.a访问obj的a属性，这就是call/apply的用法。 12345678function fn() &#123; console.log(this.a);&#125;var obj = &#123; a: 20&#125;fn.call(obj); 而call与apply后面的参数，都是向将要执行的函数传递参数。其中call以一个个的形式传递，apply以数组的形式传递，这也是它们唯一的不同点。 123456789function fn(num1, num2) &#123; console.log(this.a + num1 + num2);&#125;var obj = &#123; a: 20&#125;fn.call(obj, 100, 10); // 130fn.apply(obj, [20, 10]); // 50 因为call/apply的存在，这让JavaScript变得十分灵活。因此就让call/apply拥有了很多有用处的场景。简单总结几点，也欢迎大家补充。 将类数组对象转换为数组 12345678910111213141516171819function exam(a, b, c, d, e) &#123; // 先看看函数的自带属性 arguments 什么是样子的 console.log(arguments); // 使用call/apply将arguments转换为数组, 返回结果为数组，arguments自身不会改变 var arg = [].slice.call(arguments); console.log(arg);&#125;exam(2, 8, 9, 10, 3);// result:// &#123; '0': 2, '1': 8, '2': 9, '3': 10, '4': 3 &#125;// [ 2, 8, 9, 10, 3 ]//// 也常常使用该方法将DOM中的nodelist转换为数组// [].slice.call( document.getElementsByTagName('li') ); 根据自己的需要灵活修改this指向 12345678910var foo = &#123; name: 'joker', showName: function() &#123; console.log(this.name); &#125;&#125;var bar = &#123; name: 'rose'&#125;foo.showName.call(bar); 实现继承 1234567891011121314151617181920212223// 定义父级的构造函数var Person = function(name, age) &#123; this.name = name; this.age = age; this.gender = ['man', 'woman'];&#125;// 定义子类的构造函数var Student = function(name, age, high) &#123; // use call Person.call(this, name, age); this.high = high;&#125;Student.prototype.message = function() &#123; console.log('name:'+this.name+', age:'+this.age+', high:'+this.high+', gender:'+this.gender[0]+';');&#125;new Student('xiaom', 12, '150cm').message();// result// ----------// name:xiaom, age:12, high:150cm, gender:man; 简单给有面向对象基础的朋友解释一下。在Student的构造函数中，借助call方法，将父级的构造函数执行了一次，相当于将Person中的代码，在Sudent中复制了一份，其中的this指向为从Student中new出来的实例对象。call方法保证了this的指向正确，因此就相当于实现了继承。Student的构造函数等同于下。 1234567var Student = function(name, age, high) &#123; this.name = name; this.age = age; this.gender = ['man', 'woman']; // Person.call(this, name, age); 这一句话，相当于上面三句话，因此实现了继承 this.high = high;&#125; 在向其他执行上下文的传递中，确保this的指向保持不变 如下面的例子中，我们期待的是getA被obj调用时，this指向obj，但是由于匿名函数的存在导致了this指向的丢失，在这个匿名函数中this指向了全局，因此我们需要想一些办法找回正确的this指向。 12345678910var obj = &#123; a: 20, getA: function() &#123; setTimeout(function() &#123; console.log(this.a) &#125;, 1000) &#125;&#125;obj.getA(); 常规的解决办法很简单，就是使用一个变量，将this的引用保存起来。我们常常会用到这方法，但是我们也要借助上面讲到过的知识，来判断this是否在传递中被修改了，如果没有被修改，就没有必要这样使用了。 123456789var obj = &#123; a: 20, getA: function() &#123; var self = this; setTimeout(function() &#123; console.log(self.a) &#125;, 1000) &#125;&#125; 另外就是借助闭包与apply方法，封装一个bind方法。 12345678910111213141516function bind(fn, obj) &#123; return function() &#123; return fn.apply(obj, arguments); &#125;&#125;var obj = &#123; a: 20, getA: function() &#123; setTimeout(bind(function() &#123; console.log(this.a) &#125;, this), 1000) &#125;&#125;obj.getA(); 当然，也可以使用ES5中已经自带的bind方法。它与我上面封装的bind方法是一样的效果。 12345678var obj = &#123; a: 20, getA: function() &#123; setTimeout(function() &#123; console.log(this.a) &#125;.bind(this), 1000) &#125;&#125; 构造函数与原型方法上的this在封装对象的时候，我们几乎都会用到this，但是，只有少数人搞明白了在这个过程中的this指向，就算我们理解了原型，也不一定理解了this。所以这一部分，我认为将会为这篇文章最重要最核心的部分。理解了这里，将会对你学习JS面向对象产生巨大的帮助。 结合下面的例子，我在例子抛出几个问题大家思考一下。 1234567891011121314151617function Person(name, age) &#123; // 这里的this指向了谁? this.name = name; this.age = age; &#125;Person.prototype.getName = function() &#123; // 这里的this又指向了谁？ return this.name;&#125;// 上面的2个this，是同一个吗，他们是否指向了原型对象？var p1 = new Person('Nick', 20);p1.getName(); 我们已经知道，this，是在函数调用过程中确定，因此，搞明白new的过程中到底发生了什么就变得十分重要。 通过new操作符调用构造函数，会经历以下4个阶段。 创建一个新的对象； 将构造函数的this指向这个新对象； 指向构造函数的代码，为这个对象添加属性，方法等； 返回新对象。 因此，当new操作符调用构造函数时，this其实指向的是这个新创建的对象，最后又将新的对象返回出来，被实例对象p1接收。因此，我们可以说，这个时候，构造函数的this，指向了新的实例对象，p1。 而原型方法上的this就好理解多了，根据上边对函数中this的定义，p1.getName()中的getName为调用者，他被p1所拥有，因此getName中的this，也是指向了p1。]]></content>
  </entry>
  <entry>
    <title><![CDATA[图解作用域链与闭包]]></title>
    <url>%2F2019%2F09%2F01%2F%E5%9B%BE%E8%A7%A3%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E4%B8%8E%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[初学JavaScript的时候，我在学习闭包上，走了很多弯路。而这次重新回过头来对基础知识进行梳理，要讲清楚闭包，也是一个非常大的挑战。 作用域与作用域链作用域 在JavaScript中，我们可以将作用域定义为一套规则，这套规则用来管理引擎如何在当前作用域以及嵌套的子作用域中根据标识符进行变量查询。 JavaScript中只有全局作用域与函数作用域（因为eval我们平时开发中几乎不会用到它，这里不讨论）。 作用域与执行上下文是完全不同的两个概念。 JavaScript代码的整个执行过程，分为两个阶段，代码编译阶段与代码执行阶段。编译阶段有编译器完成，将代码翻译成可执行代码，这个阶段作用域规则会确定。执行阶段由引擎完成，主要任务是执行可执行代码，执行上下文在这个阶段创建。 作用域链 回顾之前我们分析的执行上下文的生命周期，如下图。 我们直到函数在调用激活时，会创建对应的执行上下文，在执行上下文生成的过程中，变量对象、作用域链和this的值会分别被去顶。 作用域链，是由当前环境与上层环境的一系列变量对象组成，它保证了当前执行环境对符合访问权限的变量和函数的有序访问。 为了帮助大家理解作用域链。我们结合一个例子，以及相应的图示来说明。 1234567891011121314var a = 20;function test() &#123; var b = a + 10; function innerTest() &#123; var c = 10; return b + c; &#125; return innerTest();&#125;test(); 在上面的列子中，全局、函数test、函数innerTest的执行上下文先后创建，我们设定它们的变量对象分别为VO(global),VO(test)和VO(innerTest)。而innerTest的作用域链则包含了这三个变量对象，所以innerTest的执行上下文可如下表示。 1234innerTestEC = &#123; VO: &#123;...&#125;, // 变量对象 scopeChain: [VO(innerTest), VO(test), VO(global)], // 作用域链&#125; 我们可以直接用一个数组来表示作用域链，数组的第一项scopeChain[0]为作用域链的最前端，而数组的最后一项，为作用域链的最末端，所有的最末端都为全局变量对象。 哼多人会误解为当前作用域与上层作用域为包含关系，但其实并不是。而是以最前端为起点，最末端为终点的单方向通道。 注意：因为变量对象在执行上下文进入执行阶段时，变成了活动对象，所以用AO表示。 闭包对于那些有一点 JavaScript 使用经验但从未真正理解闭包概念的人来说，理解闭包可以看作是某种意义上的重生，突破闭包的瓶颈可以使你功力大增。 闭包是一种特殊的对象。 它由两部分组成，执行上下文（代号A），以及在该上下文中创建的函数（代号B）。 当B执行时，如果访问了A中变量对象的值，那么闭包就产生了。 在大多数理解中，包括许多书中，文章里都以函数B的名字代指这里产生的闭包。而在chrome中，则以执行上下文A的函数名代指闭包。 因此我们只需要知道，一个闭包对象，由A、B共同组成，在以后的篇幅中，我将以chrome的标准来称呼。 1234567891011121314// demo01function foo() &#123; var a = 20; var b = 30; function bar() &#123; return a + b; &#125; return bar;&#125;var bar = foo();bar(); 上面的例子，首先有执行上下文foo，在foo中定义了函数bar，而通过对外返回bar的方式让bar得以执行。当bar执行时，访问了foo内部的变量a，b。因此这个时候闭包产生。 我们知道，函数的执行上下文，在执行完毕之后也就是生命周期结束，该函数的执行上下文就会失去引用。其占用的内存空间很快就会被垃圾回收器释放。可是闭包的存在，会阻止这一过程。 先来一个简单的例子。 123456789101112131415var fn = null;function foo() &#123; var a = 2; function innnerFoo() &#123; console.log(a); &#125; fn = innnerFoo; // 将 innnerFoo的引用，赋值给全局变量中的fn&#125;function bar() &#123; fn(); // 此处的保留的innerFoo的引用&#125;foo();bar(); // 2 在上面的例子中，foo()执行完毕之后，按照常理、其执行环境生命周期结束，所占内存被垃圾收集器释放，但是通过fn = innerFoo，函数innerFoo的引用被保留了下来，复制给了全局变量fn。这个行为，导致了foo的变量对象，也被保留了下来。于是，函数fn在函数bar内部执行时，依然可以访问这个被保留下来的变量对象。所以此刻仍然能够访问到变量a的值。 这样，我们就可以称为foo为闭包。 下面展示闭包foo的作用域链。 我们可以在chrome浏览器的开发者工具中查看这段代码运行时产生的函数调用栈与作用域链的生成情况。 在上面的图上，红色箭头所指的正是闭包。其中Call Stack为当前的函数调用栈，Scope为当前正在被执行的函数的作用域链，Local为当前的局部变量。 所以通过闭包，我们可以在其他的执行上下文中访问函数的内部变量。比如上面例子中。我们在函数bar的执行环境中访问到了函数foo的变量a。个人认为，从应用层面，这是闭包的重要特性。利用这个特性，我们可以实现很多有意思的东西。 不过读者朋友们需要注意的是，虽然例子中的闭包被保存在了全局变量中，但是闭包的作用域链并不会发生任何改变。在闭包中，能访问到的变量，仍然是作用域链上能够查询到的变量。 对上面的例子稍作修改，如果我们在函数bar中声明一个变量c，并在闭包fn中试图访问该变量，运行结果会抛出错误。 1234567891011121314151617var fn = null;function foo() &#123; var a = 2; function innnerFoo() &#123; console.log(c); // 在这里，试图访问函数bar中的c变量，会抛出错误 console.log(a); &#125; fn = innnerFoo; // 将 innnerFoo的引用，赋值给全局变量中的fn&#125;function bar() &#123; var c = 100; fn(); // 此处的保留的innerFoo的引用&#125;foo();bar(); 闭包的应用场景 除了面试，在实践中，闭包有两个非常重要的应用场景。分别是模块化与柯里化。 柯里化 在函数式编程中，利用闭包能够实现很多炫酷的功能，柯里化便是其中很重要的一种。 模块 在我看来，模块是闭包最强大的一个应用场景。如果你是初学者，对于模块的了解可以暂时不用放在心上，因为理解模块需要更多的基础知识。但是如果你已经有了很多JavaScript的使用经验，在彻底了解了闭包之后，不妨借助本文介绍的作用域链与闭包的思路，重新理一理关于模块的知识。这对于我们理解各种各样的设计模式具有莫大的帮助。 123456789101112131415(function () &#123; var a = 10; var b = 20; function add(num1, num2) &#123; var num1 = !!num1 ? num1 : a; var num2 = !!num2 ? num2 : b; return num1 + num2; &#125; window.add = add;&#125;)();add(10, 20); 在上面的例子中，我使用函数自执行的方式，创建了一个模块。add是模块对外暴露的一个公共方法。而变量a，b被作为私有变量。在面向对象的开发中，我们常常需要考虑是将变量作为私有变量，还是放在构造函数中的this中，因此理解闭包，以及原型链是一个非常重要的事情。模块十分重要，因此我会在以后的文章专门介绍，这里就暂时不多说啦。 为了验证自己有没有搞懂作用域链与闭包，这里留下一个经典的思考题，常常也会在面试中被问到。 利用闭包，修改下面的代码，让循环输出的结果依次为1， 2， 3， 4， 5 12345for (var i=1; i&lt;=5; i++) &#123; setTimeout( function timer() &#123; console.log(i); &#125;, i*1000 );&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[变量对象图解]]></title>
    <url>%2F2019%2F09%2F01%2F%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1%E5%9B%BE%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[在JavaScript中，我们肯定不可避免需要声明变量和函数，可是JS解析器是如何找到这些变量的呢？我们还得对执行上下文有个更进一步的了解。 一个执行上下文的什么周期分为两个阶段： 创建阶段：在这个阶段中，执行上下文会分别创建变量对象，建立作用域链，以及确定this的指向。 代码执行阶段：创建完成之后，就会开始执行代码。这个时候，会完成变量赋值，函数引用，以及执行其他代码。 从这里我们就可以看出详细了解执行上下文几位重要，，因为其中涉及到了变量对象，作用域链，this等很多人没弄明白，但是却极为重要的概念。它关系到我们能不能真正理解JavaScript。 变量对象（Variable Object）变量对象的创建，依次经历了一下几个过程。 建立arguments对象，检查当前上下文的参数，建立该对象下的属性与属性值。 建立当前上下文的函数声明，也就是使用function关键字声明的函数。在变量对象中以函数名建立一个属性，属性值为指向该函数所在内存地址的引用。如果函数名的属性已经存在，那么该属性将会被新的引用所覆盖。 检查当前上下文中的变量声明，每找到一个变量声明，就在变量对象中以变量名建立一个属性，属性值为undefined。如果该变量名的属性已经存在，为了防止同名的函数被修改为undefined，则会直接跳过，原属性不会被修改。 许多读者在阅读到这的时候会因为下面的这样场景对于“跳过”一词产生疑问。既然变量声明的foo遇到函数声明的foo会跳过，可是为什么最后foo的输出结果仍然是被覆盖了？ 1234function foo() &#123; console.log('function foo') &#125;var foo = 20;console.log(foo); // 20 其实只是大家在阅读的时候不够仔细，因为上面的三条规则仅仅适用于变量对象的创建过程。也就是执行上下文的创建过程。而foo = 20是在执行上下文的执行过程中运行的，输出结果自然会是20。对比下例。 1234567891011121314console.log(foo); // function foofunction foo() &#123; console.log('function foo') &#125;var foo = 20;// 上栗的执行顺序为// 首先将所有函数声明放入变量对象中function foo() &#123; console.log('function foo') &#125;// 其次将所有变量声明放入变量对象中，但是因为foo已经存在同名函数，因此此时会跳过undefined的赋值// var foo = undefined;// 然后开始执行阶段代码的执行console.log(foo); // function foofoo = 20; 根据这个规则，理解变量提升就变得十分简单了。在很多文章中虽然提到了变量提升，但是具体是怎么回事还真的很多人都说不出来，以后在面试中用变量对象的创建过程跟面试官解释变量提升，保证瞬间提升逼格。 在上面的规则中，function声明会比var声明优先级更高一点。 123456789101112// demo01function test() &#123; console.log(a); console.log(foo()); var a = 1; function foo() &#123; return 2; &#125;&#125;test(); 在上例中，我们直接从test()的执行上下文开始理解。全局作用域中运行test()时，test()的执行上下文开始创建。为了便于理解，我们用如下形式来表示。 123456789101112131415// 创建过程testEC = &#123; // 变量对象 VO: &#123;&#125;, scopeChain: &#123;&#125;&#125;// 因为本文暂时不详细解释作用域链，所以把变量对象专门提出来说明// VO 为 Variable Object的缩写，即变量对象VO = &#123; arguments: &#123;...&#125;, //注：在浏览器的展示中，函数的参数可能并不是放在arguments对象中，这里为了方便理解，我做了这样的处理 foo: &lt;foo reference&gt; // 表示foo的地址引用 a: undefined&#125; 未进入执行阶段之前，变量对象中的属性都不能访问！但是进入执行阶段之后，变量对象转变为了活动对象，里面的属性都能被访问了，然后开始进行执行阶段的操作。 如果在面试的时候被问到变量对象和活动对象有什么区别，就可以自如应答了。它们其实就是同一个对象，只是处于执行上下文的不同生命周期。不过只有处于函数调用栈栈顶的执行上下文的变量对象，才会变成活动对象。 12345678// 执行阶段VO -&gt; AO // Active ObjectAO = &#123; arguments: &#123;...&#125;, foo: &lt;foo reference&gt;, a: 1, this: Window&#125; 因此，上面的例子demo1，执行顺序就变成了这样 1234567891011function test() &#123; function foo() &#123; return 2; &#125; var a; console.log(a); console.log(foo()); a = 1;&#125;test(); 再来一个例子，巩固一下我们的理解。 1234567891011121314151617181920212223242526272829303132// demo2function test() &#123; console.log(foo); console.log(bar); var foo = 'Hello'; console.log(foo); var bar = function () &#123; return 'world'; &#125; function foo() &#123; return 'hello'; &#125;&#125;test();// 创建阶段VO = &#123; arguments: &#123;...&#125;, foo: &lt;foo reference&gt;, bar: undefined&#125;// 这里有一个需要注意的地方，因为var声明的变量当遇到同名的属性时，会跳过而不会覆盖// 执行阶段VO -&gt; AOVO = &#123; arguments: &#123;...&#125;, foo: 'Hello', bar: &lt;bar reference&gt;, this: Window&#125; 需要结合上面的知识，仔细对比这个例子中变量对象从创建阶段到执行阶段的变化，如果你已经理解了，说明变量对象相关的东西都已经难不倒你了。 全局上下文的变量对象以浏览器为例，全局对象为window。 全局上下文有个特殊的地方，它的变量对象，就是window对象。而这个特殊，在this指向上也同样适用，this也是指向window。 1234567// 以浏览器中为例，全局对象为window// 全局上下文windowEC = &#123; VO: Window, scopeChain: &#123;&#125;, this: Window&#125; 除此之外，全局上下文的生命周期，与程序额生命周期一致，只要程序运行不结束。比如关闭浏览器窗口，全局上下文就会一直存在，其它所有的上下文环境，都能直接访问全局上下文的属性。]]></content>
  </entry>
  <entry>
    <title><![CDATA[执行上下文图解]]></title>
    <url>%2F2019%2F09%2F01%2F%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%9B%BE%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[在JavaScript学习初期或者面试的时候常常会遇到考核变量提升的思考题。先来一个简单的。 12console.log(a); // 这里会打印出什么？var a = 20; 暂时先不管这个例子，我们先引入一个JavaScript中最基础，但同时也是最重要的一个概念：执行上下文（Execution Context）。 每当控制器转到可执行代码的时候，会进入一个执行上下文。执行上下文可以被理解为当前代码的环境，他会形成一个作用域。JavaScript中的运行环境大概包括三种情况。 全局环境：JavaScript代码运行起来会首先进入该环境； 函数环境：当函数被调用执行时，会进入当前函数中执行代码； eval(不建议使用)； 因此一个JavaScript程序，在它的执行过程中会产生多个执行上下文，JavaScript引擎会以栈的方式来处理它们，这个栈我们称其为函数调用栈（call stack）。栈底永远都是全局上下文，而栈顶就是当前正在执行的上下文。 当代码在执行过程中，遇到以上三个情况，都会生成一个执行上下文，放入栈中，而处于栈顶的上下文执行完毕后，会自动出栈。为了更加清晰的理解这个过程，根据下面的例子，结合图示给大家展示。 执行上下文可以被理解为函数执行的环境，每一个函数执行时，都会给对应的函数创建这样一个执行环境。 123456789101112131415var color = 'blue';function changeColor() &#123; var anotherColor = 'red'; function swapColors() &#123; var tempColor = anotherColor; anotherColor = color; color = tempColor; &#125; swapColors();&#125;changeColor(); 我们可以用ECStack来表示处理执行上下文组的栈。第一步，首先是全局上下文入栈。 全局上下文入栈之后，其中的可执行代码开始执行，直到遇到changeColor()，这一句激活函数changeColor()创建它自己的执行上下文，因此第二部就是changeColor()的执行上下文入栈。 changeColor()的上下文入栈之后，控制器开始执行其中的可执行代码，遇到swapColors()之后又激活了一个执行上下文。因此第三步是swapColors()的执行上下文入栈。 在swapColors()的可执行代码中，再没有遇到其他能生成执行上下文的情况，因此这段代码顺利执行完毕，swapColors()的上下文从栈中弹出。 swapColors的执行上下文弹出之后，继续执行changeColor的可执行代码，也没有再遇到其他执行上下文，顺利执行完毕之后弹出。这样，ECStack中就只身下全局上下文了。 全局上下文在浏览器窗口关闭后出栈。 注意：函数中，遇到return能直接终止可执行代码的执行，因此会直接将当前上下文弹出栈。 详细了解了这个过程，我们就可以对执行上下文总结一些结论了。 单线程 同步执行，只有栈顶的上下文处于执行中，其它上下文需要等待； 全局上下文只有唯一的一个，它在浏览器关闭时出栈。 函数的执行上下文没有限制； 每次某个函数被调用，就会有个新的执行上下文为其创建，即使是调用的自身函数，也是如此； 为了巩固一下执行上下文的理解，我们再来绘制一个例子的演变过程，这是一个简单的闭包问题。 123456789function f1()&#123; var n=999; function f2()&#123; alert(n); &#125; return f2;&#125;var result=f1();result(); // 999 因为f1中的函数f2在f1的可执行代码中，并没有被调用执行，因此执行f1时，f2不会创建新的上下文，而直到result执行时，才创建了一个新的。具体演变过程如下。]]></content>
  </entry>
  <entry>
    <title><![CDATA[内存空间详细图解]]></title>
    <url>%2F2019%2F08%2F31%2F%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E8%AF%A6%E7%BB%86%E5%9B%BE%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[因为JavaScript具有自动垃圾回收机制，所以对前端开发来说，内存空间并不是一个经常被提及的概念。但想要对JS理解更加深刻，就必须对内存空间有一个清晰的认知。 在学习内存空间之前，我们需要对这三种数据结构有个直观的认知，堆（heap）、栈（stack）和队列（queue）。 栈（Stack）与C/C++不同，JavaScript中没有严格意义上区分栈内存与堆内存。因此我们可以简单粗暴的理解为JavaScript的所有数据都保持在堆内存中。但是在某些场景，我们依然需要基于堆栈数据结构的思维来实现一些功能，比如JavaScript的执行上下文。执行上下文的执行顺序借用了栈的存取方式，因此了解栈数据结构的原理与特点是十分重要。 我们可以通过类比乒乓球盒子来分析栈的存取方式，如下图： 这种乒乓球的存放方式与栈中存取数据的方式如出一辙。处于盒子中最顶层的乒乓球5，它一定是最后被放进去的，但是最先被使用的。而我们想要使用底层的乒乓球1，就必须将上面的4个乒乓球取出来，让乒乓球1处于盒子顶层。这就是栈空间先进后出，后进先出的特点。 堆（heap）堆是一种树状结构，它的存取数据的方式与书架取书是十分相似的。 书虽然也整齐的存放在书架上，但是我们只要知道书的名字，我们就可以很方便的取出我们想要的书，而不用像从乒乓球盒子里取乒乓一样，非得将上面的所有乒乓球拿出来才能取到中间的某一个乒乓球。好比在JSON格式的数据中，我们存储的key-value是可以无序的，因为顺序的不同并不影响我们的使用，我们只需要关心书的名字。 队列（queue）在JavaScript中理解队列的目的主要是为了清晰的明白事件循环（Event Loop）的机制。 队列是一种先进先出（FIFO）的数据结构。正如排队过安检一样，排在队伍前面的人一定是最先过安检的。用下面的图示可以清晰显示队列的存取过程。 变量对象与基础数据类型JavaScript的执行上下文生成之后，会创建一个叫做变量对象的特殊对象，JavaScript的基础数据类型往往都会保存在变量对象中。 严格意义上说，变量对象也是存放于堆内存中，但是由于变量对象的特殊职能，我们在理解时仍需要将其与对内存区分开来。 基础数据类型都是一些简单的数据段，JavaScript中有6中基础数据类型，分别是ndefined、Null、Boolean、Number、String、Symbol。基础数据类型都是按值访问，因为我们可以直接操作保存在变量中的实际值。 引用数据类型与堆内存与其他语言不同，JavaScript的引用类型比如数组Array，它们的值的大小时不固定的。引用数据类型的值时保存至堆内存中的对象。JavaScript不允许直接访问堆内存中的位置。因此我们不能直接操作对象的堆内存空间。在操作对象时，实际上时在操作对象的引用而不是实际的对象。因此，引用类型的值都是按引用访问的。这里的引用，我们可以理解为保存在变量对象中的一个地址，该地址与堆内存的实际值相关联。 为了更好的搞懂变量对象与堆内存，我们可以结合以下例子与图解进行理解。 123456var a1 = 0; // 变量对象var a2 = 'this is string'; // 变量对象var a3 = null; // 变量对象var b = &#123; m: 20 &#125;; // 变量b存在于变量对象中，&#123;m: 20&#125; 作为对象存在于堆内存中var c = [1, 2, 3]; // 变量c存在于变量对象中，[1, 2, 3] 作为对象存在于堆内存中 因此当我们要访问堆内存中的引用数据类型时，实际上我们首先时从变量对象中获取该对象的地址引用，再从堆内存中取得我们需要的数据。 理解了JavaScript的内存空间，我们就可以借助内存空间的特性来验证一下引用类型的一些特点。 在前端面试中我们常常会遇到这样一个类似的题目 123456// demo01.jsvar a = 20;var b = a;b = 30;// 这时a的值是多少？ 123456// demo02.jsvar m = &#123; a: 10, b: 20 &#125;var n = m;n.a = 15;// 这时m.a的值是多少 在变量对象中的数据发生复制行为时，系统会自动为新的变量分配一个新值。var b = a执行之后，a与b虽然值都等于20，但是他们其实已经是相互独立互不影响的值了。具体如图。所以我们修改了b的值以后，a的值并不会发生变化。 在demo02中，我们通过var n = m执行一次复制引用类型的操作。引用类型的复制同样也会为新的变量自动分配一个新的值保存在变量对象中，但不同的是，这个新的值，仅仅只是引用类型的一个地址指针。当地址指针相同时，尽管他们相互独立，但是在变量对象中访问到的具体对象实际上是同一个。如图所示。 因此当我改变n时，m也发生了变化。这就是引用类型的特性. 通过内存的角度来理解，是不是感觉要轻松很多？除此之外，我们还可以以此为基础，一步一步的理解JavaScript的执行上下文，作用域链，闭包，原型链等重要概念。 内存空间管理因为JavaScript具有自动垃圾收集机制，所以我们在开发时不需要关心内存的使用问题，内存的分配与回收都完全实现了自动管理。 JavaScript的内存生命周期 1231. 分配你所需要的内存2. 使用分配到的内存（读、写）3. 不需要时将其释放、归还 为了便于理解，我们使用一个简单的例子来解释这个周期。 123var a = 20; // 在内存中给数值变量分配空间alert(a + 100); // 使用内存a = null; // 使用完毕之后，释放内存空间 第一步和第二步我们都很好理解，JavaScript在定义变量时就完成了内存分配。第三步释放内存空间则是我们需要重点理解的一个点。 JavaScript有自动垃圾收集机制，那么这个自动垃圾收集机制的原理是什么呢？其实很简单，就是找出那些不再继续使用的值，然后释放其占用的内存。垃圾收集器会每隔固定的时间段就执行一次释放操作。 在JavaScript中，最常用的是通过标记清除的算法来找到哪些对象是不再继续使用的，因此a = null其实仅仅只是做了一个释放引用的操作，让 a 原本对应的值失去引用，脱离执行环境，这个值会在下一次垃圾收集器执行操作时被找到并释放。而在适当的时候解除引用，是为页面获得更好性能的一个重要方式。 在局部作用域中，当函数执行完毕，局部变量也就没有存在的必要了，因此垃圾收集器很快做出判断回收。但全局变量什么时候需要自动释放内存空间就很难判断，因此在我们的开发中，需要尽量避免使用全局变量。]]></content>
  </entry>
  <entry>
    <title><![CDATA[手写实现call()、apply()、bind()]]></title>
    <url>%2F2019%2F08%2F31%2F%E6%89%8B%E5%86%99%E5%AE%9E%E7%8E%B0call()%E3%80%81apply()%E3%80%81bind()%2F</url>
    <content type="text"><![CDATA[apply()和call()这两个方法的用途都是在特定的作用域中调用函数，实际上等于设置函数体内this对象的值。bind()方法会创建一个函数的实例，其this值会被绑定到传来的参数。总的来说是用来改变函数运行时this的指向。 call() 用法 call方法将需要参数按顺序传递。 12345678function sum(num1, num2)&#123; return num1 + num2;&#125;function callSum(num1, num2)&#123; return sum.call(this, num1, num2);&#125;alert(callSum(10,10)); //20 实现原理 1234567891011Function.prototype.call2 = function (context) &#123; context = context || window context.fn = this var args = []; for(var i = 1, len = arguments.length; i &lt; len; i++) &#123; args.push('arguments[' + i + ']'); &#125; var result = eval('context.fn(' + args +')'); delete context.fn return result; &#125; apply() 用法 apply()方法接收两个参数：一个是在其中运行函数的作用域，另一个是参数数组，可以是Array的实例，也可以是arguments对象。 1234567891011121314function sum(num1, num2)&#123; return num1 + num2;&#125;function callSum1(num1, num2)&#123; return sum.apply(this, arguments);&#125;function callSum2(num1, num2)&#123; return sum.apply(this, [num1, num2]);&#125;alert(callSum1(10,10)); //20alert(callSum2(10,10)); //20 其中this是你想指定的上下文，它可以是任何一个JavaScript对象（JavaScript中一切皆对象）。apply()和call()的用法，接收参数的方式不一样，使用call()和apply()来扩充作用域的最大好处，就是对象不需要与方法有任何耦合关系，如果你传的 context 就 null 或者 undefined，那么 window 对象就是默认的 context（严格模式下默认 context 是 undefined)。 实现原理 12345678910111213141516171819Function.prototype.apply = function (context, arr) &#123; context = Object(context) || window; context.fn = this; var result; if (!arr) &#123; result = context.fn(); &#125; else &#123; var args = []; for (var i = 0, len = arr.length; i &lt; len; i++) &#123; args.push('arr[' + i + ']'); &#125; result = eval('context.fn(' + args + ')') &#125; delete context.fn return result; &#125; bind() 用法 bind()用法：第一个参数是this的指向，从第二个参数开始接收的参数列表 12345678910111213window.color = "red";var o = &#123; color: "blue" &#125;;function sayColor()&#123; alert(this.color);&#125;var objectSayColor = sayColor.bind(o);objectSayColor(); //blue 实现原理 1234567891011121314151617181920212223Function.prototype.bind = function (oThis) &#123; if (typeof this !== "function") &#123; throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable"); &#125; var aArgs = Array.prototype.slice.call(arguments, 1), fToBind = this, fNOP = function () &#123;&#125;, fBound = function () &#123; // 当作为构造函数时，this 指向实例，此时结果为 true，将绑定函数的 this 指向该实例，可以让实例获得来自绑定函数的值 // 以上面的是 demo 为例，如果改成 `this instanceof fBound ? null : context`，实例只是一个空对象，将 null 改成 this ，实例会具有 habit 属性 // 当作为普通函数时，this 指向 window，此时结果为 false，将绑定函数的 this 指向 context return fToBind.apply( this instanceof fNOP &amp;&amp; oThis ? this : oThis || window, aArgs.concat(Array.prototype.slice.call(arguments)) ); &#125;; fNOP.prototype = this.prototype; fBound.prototype = new fNOP(); return fBound;&#125;; 总结call、apply和bind函数存在的区别： bind()不会立即执行，而是返回一个改变了上下文this的函数，便于稍后调用； apply，call则是立即调用； call比apply的性能要好，平常可以多用call。call传入参数的格式正式内部所需要的格式； 需要注意的一点的是： 在ES6的箭头函数下，call和apply将失效，对于箭头函数来说，函数内部的this对象，就是定义时所在的对象； 箭头函数不可以当作构造函数，也就是说不可以使用new关键字，否则会抛出一个错误。 箭头函数不可以使用arguments对象，该对象在函数中不存在；]]></content>
  </entry>
  <entry>
    <title><![CDATA[JavaScript之工厂模式]]></title>
    <url>%2F2019%2F08%2F31%2FJavaScript%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[工厂模式类似现实生活种的工厂可以产生大量相似的商品，去做同样的事情，实现相同的效果； 简单的工厂模型可以理解为解决多个相似的问题，这也是它的优点。相关代码如下： 1234567891011121314151617181920212223242526function CreatePerson(name,age,sex) &#123; var obj = new Object(); obj.name = name; obj.age = age; obj.sex = sex; obj.sayName = function()&#123; return this.name; &#125; return obj;&#125;var p1 = CreatePerson("longen",'28','男');var p2 = CreatePerson("tugenhua",'27','女');console.log(p1.name); // longenconsole.log(p1.age); // 28console.log(p1.sex); // 男console.log(p1.sayName()); // longenconsole.log(p2.name); // tugenhuaconsole.log(p2.age); // 27console.log(p2.sex); // 女console.log(p2.sayName()); // tugenhua// 返回都是object 无法识别对象的类型 不知道他们是哪个对象的实列console.log(typeof p1); // objectconsole.log(typeof p2); // objectconsole.log(p1 instanceof Object); // true 函数CreatePerson接收三个参数name、age和sex，在无数次的调用下，这个函数都会返回包含这三个属性和一个sayName方法的对象。 工厂模式是为了解决多个类似对象声明的问题，也是为了解决实例化对象产生重复的问题。 优点：能解决多个相似的问题。 缺点：无法识别对象的类型。 复杂的工厂模式：将其成员对象的实例化推迟到子类中，子类可以重写父类接口方法以便创建的时候指定自己的对象类型。 父类只对创建过程中的一般性问题进行处理，这些处理会被子类继承，子类之间是相互独立的，具体的业务逻辑会放在子类中进行编写。 父类就变成了一个抽象类，但是符类可以执行子类中相同类似的方法，具体的业务逻辑需要放在子类中去实现。比如我现在开了几个自行车店，那么每个店都有几种型号的自行车出售。我们现在来使用工厂模式来编写这些代码。 父类的构造函数： 12345678910111213141516171819202122// 定义自行车的构造函数var BicycleShop = function()&#123;&#125;;BicycleShop.prototype = &#123; constructor: BicycleShop, /* * 买自行车这个方法 * @param &#123;model&#125; 自行车型号 */ sellBicycle: function(model)&#123; var bicycle = this.createBicycle(mode); // 执行A业务逻辑 bicycle.A(); // 执行B业务逻辑 bicycle.B(); return bicycle; &#125;, createBicycle: function(model)&#123; throw new Error(&quot;父类是抽象类不能直接调用，需要子类重写该方法&quot;); &#125;&#125;; 上面是定义一个自行车抽象类来编写工厂模式的实列，定义了createBicycle这个方法，但是如果直接实例化父类，调用父类中的这个createBicycle 方法,会抛出一个error，因为父类是一个抽象类，他不能被实列化，只能通过子类来实现这个方法，实现自己的业务逻辑，下面我们来定义子类，我们学会如何使用工厂模式重新编写这个方法，首先我们需要继承父类中的成员，然后编写子类 ;如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// 定义自行车的构造函数var BicycleShop = function(name)&#123; this.name = name; this.method = function()&#123; return this.name; &#125;&#125;;BicycleShop.prototype = &#123; constructor: BicycleShop, /* * 买自行车这个方法 * @param &#123;model&#125; 自行车型号 */ sellBicycle: function(model)&#123; var bicycle = this.createBicycle(model); // 执行A业务逻辑 bicycle.A(); // 执行B业务逻辑 bicycle.B(); return bicycle; &#125;, createBicycle: function(model)&#123; throw new Error("父类是抽象类不能直接调用，需要子类重写该方法"); &#125; &#125;; // 实现原型继承 function extend(Sub,Sup) &#123; //Sub表示子类，Sup表示超类 // 首先定义一个空函数 var F = function()&#123;&#125;; // 设置空函数的原型为超类的原型 F.prototype = Sup.prototype; // 实例化空函数，并把超类原型引用传递给子类 Sub.prototype = new F(); // 重置子类原型的构造器为子类自身 Sub.prototype.constructor = Sub; // 在子类中保存超类的原型,避免子类与超类耦合 Sub.sup = Sup.prototype; if(Sup.prototype.constructor === Object.prototype.constructor) &#123; // 检测超类原型的构造器是否为原型自身 Sup.prototype.constructor = Sup; &#125; &#125; var BicycleChild = function(name)&#123; this.name = name;// 继承构造函数父类中的属性和方法 BicycleShop.call(this,name); &#125;; // 子类继承父类原型方法 extend(BicycleChild,BicycleShop);// BicycleChild 子类重写父类的方法BicycleChild.prototype.createBicycle = function()&#123; var A = function()&#123; console.log("执行A业务操作"); &#125;; var B = function()&#123; console.log("执行B业务操作"); &#125;; return &#123; A: A, B: B &#125;&#125;var childClass = new BicycleChild("龙恩");console.log(childClass); 实例化子类，然后打印出该实例： 上面只是”龙恩”自行车这么一个型号的，如果需要生成其他型号的自行车的话，可以编写其他子类，工厂模式最重要的优点是：可以实现一些相同的方法，这些相同的方法我们可以放在父类中编写代码，那么需要实现具体的业务逻辑，那么可以放在子类中重写该父类的方法，去实现自己的业务逻辑；使用专业术语来讲的话有 2点：第一：弱化对象间的耦合，防止代码的重复。在一个方法中进行类的实例化，可以消除重复性的代码。第二：重复性的代码可以放在父类去编写，子类继承于父类的所有成员属性和方法，子类只专注于实现自己的业务逻辑。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Base64的原理与实现]]></title>
    <url>%2F2019%2F08%2F30%2FBase64%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[我们知道在计算机中一个字节有256种组合，对应的就是ASCII码。而ASCII码的128~255之间的值属于不可见字符。有些网络传送渠道并不支持所有的字节，例如传统的邮件只支持可见字符的传送，而ASCII码的控制字符就不能通过邮件传送。图片二进制流的每一个字节也都不可能都是可见字符，因此它们也不能传送。对此最好的办法就是在不改变传统协议的情况下，做一种拓展方案来支持二进制文件的传送，将不可见的字符用可见字符来表示。Base64编码应运而生。 Base64编码原理Base64编码是基于64个可见字符“A-Z、a-z、0-9、+、/”的编码方式，因为Base64的码表只有64个字符，想要完全表达这些字符，只需要6bit即可（2的6次方为64）。 Base64编码本质上是一种将二进制数据转成文本数据的方案。对于非二进制数据，是先将其转换成二进制形式，，然后每连续6bit计算其十进制值，根据该值在码表上找到对应的字符，最后得到一个文本字符串。基本规则如下： 标准Base64只有64个可见字符（A-Z、a-z、0-9、+、/）以及用作后缀等号； Base64是将3个字节变成4个可见字符； 严格来说Base64不能算是一种加密，只能说是编码转换。 Base64应用 实现简单的数据加密，使用户一眼望去看不出真实数据内容，Base64算法的复杂程度较低，而效率就较高些。 Base64编码的主要的作用不在于安全性，而是让内容能在各个网关间无错的传输，这才是Base64编码的核心作用。]]></content>
  </entry>
  <entry>
    <title><![CDATA[HTTP常见的状态码]]></title>
    <url>%2F2019%2F08%2F30%2FHTTP%E5%B8%B8%E8%A7%81%E7%9A%84%E7%8A%B6%E6%80%81%E7%A0%81%2F</url>
    <content type="text"><![CDATA[状态码的职责是当客户端向服务器发送请求时，描述返回的请求结果。借助状态码，用户可以知道服务端时正常处理了请求还是出现了错误。 状态码的类别： 123 类别 原因短语 1XX Informational (信息性状态码) 接受的请求正在处理 2XX Success (成功状态码) 请求正常处理完毕 3XX Redirection (重定向状态码) 需要进行附加操作以完成请求 4XX Client Error (客户端错误状态码) 客户端请求出错 5XX Server Error (服务器错误状态码) 服务器处理请求出错 1XX——表明请求正在被处理 100 Continue：客户端应继续其请求。 101 Switching Protocols：服务器根据客户端请求切换协议。 2XX——表明请求被正常处理了 200 OK：请求已正常处理。 201 Created：成功请求并创建了新的资源。 202 Accepted：已经接收请求，但未处理完成。 203 Non-Authoritative Information：请求成功，但返回的meta信息不在原始的服务器，而是一个副本。 204 No Content：请求处理成功，但没有任何资源可以返回给客户端。 205 Reset Content：服务器处理成功，用户终端应重置文档视图。 206 Partial Content：服务器成功处理了部分GET请求。 3XX——表明要完成请求，需要进一步操作 300 Multiple Choices ：针对请求，服务器可执行多种操作。服务器可根据请求者选择一项操作。或提供操作列表供请求者选择。 301 Moved Permanently：请求的资源已被永远的移动到新URL，返回信息会包括新的URI，浏览器会自动定向到新URI。 302 Found：与301类似，但是资源只是临时被移动，客户端应继续使用原URI。 303 See Other：查看其他地址。 304 Not Modified：所请求的资源未修改，服务器返回此状态码，不会返回任何资源。 305 Use Proxy：所请求的资源必须通过代理访问。 307 Temporary Redirect：临时重定向，与302类似，使用FET请求重定向。 4XX——表明请求出错 400 Bad Request：客户端请求的语法错误，服务器无法理解。 401 Unauthorized：请求要求用户的身份认证。 403 Forbidden：服务器理解请求客户端的请求，但是拒绝执行此请求。 404 Not Found：服务器无法根据客户端的请求找到资源。 405 Method Not Allowed：客户端请求中的方法被禁止。 406 Not Acceptable：服务器无法根据客户端请求的内容特性完成请求。 407 Proxy Authentication Required：请求要求代理的身份认证，与401类似。但请求者应当使用代理进行授权。 408 Request Time-out：服务器等待客户端发送的请求时间过长，超时。 409 Conflict：服务器完成客户端的PUT请求时可能返回此代码，服务器处理请求时发送了冲突。 410 Cone：客户端请求的资源已经不存在。 411 Length Required：服务器无法处理客户端发送的不带Content-Length的请求信息。 412 Precondition Failed：客户端请求信息的先决条件错误。 413 Request Entity Too Large：由于请求的实体过大，服务器无法处理，因此拒绝请求。 414 Request-URI Too Large：请求的URI过长，服务器无法处理。 415 Unsupported Media Type：服务器无法处理请求附带的媒体格式。 416 Requested range not satisfiable：客户端请求的范围无效。 417 Expectation Failed：服务器无法满足Expect的请求头信息。 5XX——表明服务器处理请求错误 500 Internal Server Error：服务器内部错误，无法完成请求。 501 Not Implemented：服务器不支持请求的功能，无法完成请求。 502 Bad Gateway：作为网关或者代理工作的服务器尝试执行请求时，从远处服务器接收到了一个无效的响应。 503 Service Unavailable：由于超载或系统维护，服务器暂时的无法处理客户端的请求。 504 Gateway Time-out：充当网关或者代理的服务器未及时从远端服务器获取请求。 505 HTTP Version not supported：服务器不支持请求的HTTP协议的版本，无法完成处理。]]></content>
  </entry>
  <entry>
    <title><![CDATA[常见六大Web安全按攻防解析]]></title>
    <url>%2F2019%2F08%2F29%2F%E5%B8%B8%E8%A7%81%E5%85%AD%E5%A4%A7Web%E5%AE%89%E5%85%A8%E6%8C%89%E6%94%BB%E9%98%B2%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[在互联网时代，数据安全与个人隐私受到了前所未有的挑战，各种新奇的攻击技术层出不穷。如何才能更好地保护我们的数据？ XSSXSS（Cross-Site Scripting），跨站脚本攻击，因为缩写和CSS重叠，所有只能叫XSS。跨站脚本攻击时指通过存在安全漏洞的Web网站注册用户的浏览器内运行非法的HTML标签或JavaScript进行的一种攻击。 跨站脚本攻击有可能造成以下影响： 利用脚本输入表单骗取用户个人信息； 利用脚本窃取用户的Cookie值，被害者在不知情的情况下，帮助攻击者发送恶意请求； 显示伪造的文章或图片； XSS的原理是恶意攻击者往Web页面里插入恶意可执行网页脚本代码，当用户浏览该页之时，嵌入其中Web里面的脚本代码会被执行，从而可以达到攻击者盗取用户信息或其他侵犯用户安全隐私的目的。 XSS的攻击方式千变万化，但还是可以大致细分为几种类型。 非持久型XSS（反射型XSS） 非持久型XSS漏洞，一般是通过给别人发送带有恶意脚本代码参数的URL，当URL地址被打开时，特有的恶意代码参数被HTML解析、执行。 举个例子，比如页面中包含以下代码： 12345678910&lt;select&gt; &lt;script&gt; document.write('' + '&lt;option value=1&gt;' + location.href.substring(location.href.indexOf('default=') + 8) + '&lt;/option&gt;' ); document.write('&lt;option value=2&gt;English&lt;/option&gt;'); &lt;/script&gt;&lt;/select&gt; 攻击者可以直接通过 URL (类似：https://xxx.com/xxx?default=&lt;script&gt;alert(document.cookie)&lt;/script&gt;) 注入可执行的脚本代码。不过一些浏览器如Chrome其内置了一些XSS过滤器，可以防止大部分反射型XSS攻击。 非持久型 XSS 漏洞攻击有以下几点特征： 即时性，不经过服务器存储，直接通过HTTP的GET和POST请求就能完成一次攻击，拿到用户隐私数据； 攻击者需要诱骗点击，必须要通过用户点击链接才能发起； 反馈率低，所以较难发现和响应修复； 盗取用户敏感保密信息； 为了防止出现非持久型XSS漏洞，需要确保这么几件事情： Web页面渲染的所以内容或者渲染的数据都必须来自服务端； 尽量不要从URL、document.referrer、document.forms 等这种 DOM API 中获取数据直接渲染； 尽量不要使用 eval, new Function()，document.write()，document.writeln()，window.setInterval()，window.setTimeout()，innerHTML，document.createElement() 等可执行字符串的方法。 如果做不到以上几点，也必须对涉及 DOM 渲染的方法传入的字符串参数做 escape 转义。 前端渲染的时候对任何的字段都需要做 escape 转义编码。 持久型XSS（存储型XSS） 持久型 XSS 漏洞，一般存在于 Form 表单提交等交互功能，如文章留言，提交文本信息等，黑客利用的 XSS 漏洞，将内容经正常功能提交进入数据库持久保存，当前端页面获得后端从数据库中读出的注入代码时，恰好将其渲染执行。 举个例子，对于评论功能来说，就得防范持久型XSS攻击，因为我可以在评论中输入以下内容。 主要注入页面方式和非持久型XSS漏洞类似，只不过持久型的不是来源于URL、referrer、forms等，而是来源于后端从数据库中读取来的数据。持久型XSS攻击不需要诱骗点击，黑客只需要在提交表单的地方完成注入即可，但是这种XSS攻击的成本相对还是很高。 攻击成功需要同时满足以下几个条件： POST请求提交表单后端没有做转义直接入库； 后端从数据库中取出数据没有做转义直接输出给前端； 前端拿到后端数据没做转义直接渲染成DOM； 持久型XSS有以下几个特点： 持久型，植入在数据库中； 盗取用户敏感私密信息； 危害面广； 如何防御 对于XSS攻击来说，通常有两者方式可以用来防御。 （1）CSP CSP本质上就是建立白名单，开发者明确告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截时由浏览器自己实现的。我们可以通过这种方式来尽量减少XSS攻击。 通常可以通过两种方式来开启CSP： 设置HTTP Header中的Content-Security-Policy； 设置meta标签的方式； 这里以设置HTTP Header来举例： 只允许加载本站资源 1Content-Security-Policy: default-src 'self' 只允许加载HTTPS协议图片 1Content-Security-Policy: img-src https://* 允许加载任何来源框架 1Content-Security-Policy: child-src 'none' 如需了解更多属性，请参考Content-Security-Policy文档 对于这种方式来说，只能开发者配置了正确的规则，那么即使网站存在漏洞，攻击者也不能执行它的攻击代码，并且CSP的兼容性也不错。 （2）转义字符 用户的输入永远不可信任的，最普遍的做法就是转义输入输出的内容，对于引号、尖括号、斜杠进行转义。 12345678910function escape(str) &#123; str = str.replace(/&amp;/g, '&amp;amp;') str = str.replace(/&lt;/g, '&amp;lt;') str = str.replace(/&gt;/g, '&amp;gt;') str = str.replace(/"/g, '&amp;quto;') str = str.replace(/'/g, '&amp;#39;') str = str.replace(/`/g, '&amp;#96;') str = str.replace(/\//g, '&amp;#x2F;') return str&#125; 但是对于显示富文本来说，显然不通过上面的办法来转义所以字符，因为这样会把需要的格式也过滤掉。对于这种情况，通常采用白名单过滤的办法，当然也可以通过黑名单过滤，但是考虑到需要过滤的标签和标签属性实在太多，更加推荐使用白名单的方式。 1234const xss = require('xss')let html = xss('&lt;h1 id="title"&gt;XSS Demo&lt;/h1&gt;&lt;script&gt;alert("xss");&lt;/script&gt;')// -&gt; &lt;h1&gt;XSS Demo&lt;/h1&gt;&amp;lt;script&amp;gt;alert("xss");&amp;lt;/script&amp;gt;console.log(html) （3）HttpOnly Cookie 这是预防XSS攻击窃取用户Cookie最有效的防御手段。Web应用程序在设置Cookie时，将其属性设为HttpOnly，就可以避免该网页的Cookie被客户端被恶意JavaScript窃取，保护用户Cookie信息。 CSRFCSRF（Cross Site Request Forgery），即跨站请求伪造，是一种常见的Web攻击，它利用用户已登录的身份，在用户毫不知情的情况下，以用户的命运完成非法操作。 CSRF攻击的原理 下面先介绍一下CSRF攻击的原理： 完成CSRF攻击必须要有三个条件： 用户已经登录了站点A，并在本地记录了Cookie； 在用户没有登出站点A的情况下（也就是Cookie生效的情况下），访问了恶意攻击者提供的引诱危险站点B（B站点要求访问站点A）； 站点A没有做任何CSRF防御； 我们来看一个例子：当我们登入转账页面后，突然眼前一亮惊现”XXX隐私照片，不看后悔一辈子”的链接，耐不住内心躁动，立马点击了该危险的网站（页面代码如下图所示），但当这页面一加载，便会执行submitForm这个方法来提交转账请求，从而将10块转给黑客。 如何防御 防范CSRF攻击可以遵循以下几种规则： Get请求不对数据进行修改； 不让第三方网站访问用户Cookie 阻止第三方网站请求接口 请求时附带验证信息，比如验证码或者Token （1）SameSite 可以对Cookie设置SameSite属性，该属性表示Cookie不随着跨域请求发送，可以很大程度减少CSRF的攻击，但是该属性目前并不是所有浏览器都兼容。 （2）Referer Check HTTP Referer是header的一部分，当浏览器向Web服务器发送请求时，一般会带上Referer信息告诉服务器是从哪个页面的链接过来的，服务器借此可以获得一些信息用于处理。可以通过检测请求的来源来防御CSRF攻击。正常请求的referer具有一定规律，如在提交表单的referer必定实在该页面发送的请求。所以通过检查http header referer的值是不是这个页面，来判断是不是CSRF攻击。 但当某些情况下如此从https跳转到http，浏览器处于安全考虑，不会发送referer，服务器就无法进行check了。若与该网站同域的其他网站有XSS漏洞，那么攻击者可以在其他网站注入恶意脚本，受害者进入了此类同域的网址，也会遭受攻击。处于以上原因，无法完全依赖Referer Check作为防御CSRF的主要手段。但是可以通过Referer Check来监控CSRF攻击的发生。 （3）Anti CSRF Token 目前比较完善的解决方案是加入Anti-CSRF-Token。即发送请求时在HTTP请求中以参数的形式加入一个随机产生的Token，并在服务器建立一个拦截器来验证这个Token。服务器读取浏览器当前域Cookie值，会进行校验该请求当中的Token和Cookie当中的Token值是否都存在且相等，才认为这是合法的请求。否则认为这次请求是违法的，拒绝该次服务。 这种方法相比Referer检查要安全很多，token可以在用户登陆后产生并放于session或cookie中，然后在每次请求时服务器把token从session或cookie中拿出，与本次请求中的token 进行比对。由于token的存在，攻击者无法再构造出一个完整的URL实施CSRF攻击。但在处理多个页面共存问题时，当某个页面消耗掉token后，其他页面的表单保存的还是被消耗掉的那个token，其他页面的表单提交时会出现token错误。 （4）验证码 应用程序和用户进行交互过程中，特别是账户交易这种核心步骤，强制用户输入验证码，才能完成最终请求。在通常情况下，验证码够很好地遏制CSRF攻击。但增加验证码降低了用户的体验，网站不能给所有的操作都加上验证码。所以只能将验证码作为一种辅助手段，在关键业务点设置验证码。 点击劫持点击劫持是一种视觉欺骗的攻击手段。攻击者将需要攻击的网站通过 iframe 嵌套的方式嵌入自己的网页中，并将 iframe 设置为透明，在页面中透出一个按钮诱导用户点击。 特点 隐蔽性较高，骗取用户操作； “UI-覆盖攻击”； 利用iframe或者其它标签的属性； 点击劫持的原理 用户在登录A网站的系统后，被攻击者诱惑打开第三方网站，而第三方网站通过iframe引入了A网站的页面内容，用户在第三方网站中点击某个按钮（被装饰的按钮），实际上是点击了A网站的按钮。接下来我们举个例子：我在有空发布了很多视频，想让更多的人关注它，就可以通过点击劫持来实现。 123456789101112131415161718192021222324iframe &#123;width: 1440px;height: 900px;position: absolute;top: -0px;left: -0px;z-index: 2;-moz-opacity: 0;opacity: 0;filter: alpha(opacity=0);&#125;button &#123;position: absolute;top: 270px;left: 1150px;z-index: 1;width: 90px;height:40px;&#125;&lt;/style&gt;......&lt;button&gt;点击脱衣&lt;/button&gt;&lt;img src="http://pic1.win4000.com/wallpaper/2018-03-19/5aaf2bf0122d2.jpg"&gt;&lt;iframe src="http://i.youku.com/u/UMjA0NTg4Njcy" scrolling="no"&gt;&lt;/iframe&gt; 从上图可知，攻击者通过图片作为页面背景，隐藏了用户操作的真实界面，当你按耐不住好奇点击按钮以后，真正的点击的其实是隐藏的那个页面的订阅按钮，然后就会在你不知情的情况下订阅了。 如何防御 （1）X-FRAME-OPTIONS X-FRAME-OPTIONS是一个HTTP响应头，在现代浏览器有一个很好的支持。这个HTTP响应头就是为了防御用iframe嵌套的点击劫持攻击。 该响应头有三个值可选，分别是： DENY，表示页面不允许通过 iframe 的方式展示 SAMEORIGIN，表示页面可以在相同域名下通过 iframe 的方式展示 ALLOW-FROM，表示页面可以在指定来源的 iframe 中展示 （2）JavaScript防御 对于某些远古浏览器来说，并不能支持上面的这种方式，那我们只有通过 JS 的方式来防御点击劫持了。 1234567891011121314151617&lt;head&gt; &lt;style id="click-jack"&gt; html &#123; display: none !important; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; if (self == top) &#123; var style = document.getElementById('click-jack') document.body.removeChild(style) &#125; else &#123; top.location = self.location &#125; &lt;/script&gt;&lt;/body&gt; 以上代码的作用就是当通过 iframe 的方式加载页面时，攻击者的网页直接不显示所有内容了。 URL跳转漏洞定义：借助未验证的URL跳转，将应用程序引导到不安全的第三方区域，从而导致的安全问题。 URL跳转漏洞原理 黑客利用URL跳转漏洞来诱导安全意识低的用户点击，导致用户信息泄露或者资金的流失。其原理是黑客构建恶意链接（链接需要进行伪装，尽可能迷惑），发在QQ群或者浏览量多的贴吧/论坛中，安全意识低的用户点击后，经过服务器或者浏览器解析后，跳到恶意的网站中。 诸如伪装成像如下的网址，你是否能够识别出来是恶意网址呢？ 123http://gate.baidu.com/index?act=go&amp;url=http://t.cn/RVTatrdhttp://qt.qq.com/safecheck.html?flag=1&amp;url=http://t.cn/RVTatrdhttp://tieba.baidu.com/f/user/passport?jumpUrl=http://t.cn/RVTatrd 实现方式： Header跳转 JavaScript跳转； meta标签跳转； 这里我们举个Header跳转实现： 1234&lt;?php$url=$_GET['jumpto'];header("Location: $url");?&gt; 1http://www.wooyun.org/login.php?jumpto=http://www.evil.com 这里用户会认为www.wooyun.org都是可信的，但点击上述链接将导致用户最终访问www.evil.com这个恶意网址。 如何防御 （1）referer的限制 如果确定传递URL参数进入的来源，我们可以通过该方式实现安全限制，保证该URL的有效性，避免恶意用户自己生成跳转链接。 （2）加入有效性验证Token 我们保证所有生成的链接都是来自于我们可信域的，通过在生成的链接里加入用户不可控的Token对生成的链接进行校验，可以避免用户生成自己的恶意链接从而被利用，但是如果功能本身要求比较开发，可能导致有一定的限制。 SQL注入SQL注入是一种常见的Web安全漏洞，攻击者利用这个漏洞，可以访问或修改数据，或者利用潜在的数据库漏洞进行攻击。 SQL注入的原理 我们先举个万能钥匙的例子来说明其原理： 12345&lt;form action="/login" method="POST"&gt; &lt;p&gt;Username: &lt;input type="text" name="username" /&gt;&lt;/p&gt; &lt;p&gt;Password: &lt;input type="password" name="password" /&gt;&lt;/p&gt; &lt;p&gt;&lt;input type="submit" value="登陆" /&gt;&lt;/p&gt;&lt;/form&gt; 后端的SQL语句可能是如下这样的： 1234567let querySQL = ` SELECT * FROM user WHERE username='$&#123;username&#125;' AND psw='$&#123;password&#125;'`;// 接下来就是执行 sql 语句... 这是我们经常见到的登录页面，但如果有一个恶意攻击者输入的用户名是 admin&#39; --，密码随意输入，就可以直接登入系统了。why! —-这就是SQL注入。 我们之前预想的SQL 语句是: 1SELECT * FROM user WHERE username='admin' AND psw='password' 但是恶意攻击者用奇怪用户名将你的 SQL 语句变成了如下形式： 1SELECT * FROM user WHERE username='admin' --' AND psw='xxxx' 在 SQL 中,&#39; --是闭合和注释的意思，– 是注释后面的内容的意思，所以查询语句就变成了： 1SELECT * FROM user WHERE username='admin' 所谓的万能密码的本质，就是SQL注入的一种利用方式 一次SQL注入的过程包括以下几个过程 获取用户请求参数； 拼接到代码当中； SQL语句按照我们构造参数的语义执行成功； SQL注入的必备条件：1. 可以控制输入的数据。2. 服务器要执行的代码拼接了控制的数据 我们会发现SQL注入流程中与正常请求服务器类似，只是黑客控制了数据，构造了SQL查询，而正常的请求不会SQL查询这一步，SQL注入的本质:数据和代码未分离，即数据当做了代码来执行。 危害 获取数据库信息 管理员后台用户名和密码 获取其他数据库敏感信息：用户名、密码、手机号码、身份证、银行卡信息…… 整个数据库：脱库 获取服务器权限 植入WebShell，获取服务器后面 读取服务器敏感文件 如何防御 严格限制Web应用的数据库的操作权限，给此用户提供仅仅能够满足其工作的最低权限，从而最大限度的减少注入攻击对数据库的危害； 后端代码检查输入的数据是否符合预期，严格限制变量的类型，例如使用正则表达式进行一些匹配处理； 对进行数据库的特殊字符（’，”，\，&lt;，&gt;，&amp;，*，; 等）进行转义处理，或编码转换。基本上所有的后端语言都有对字符串进行转义处理的方法，比如lodash 的 lodash._escapehtmlchar 库。 所有的查询语句建议使用数据库提供的参数化查询接口，参数化的语句使用参数而不是将用户输入变量嵌入到SQL语句中，即不要直接拼接SQL语句。例如Node.js中的mysqljs库的query方法中的？占位参数。 OS命令注入攻击OS命令注入和SQL注入差不多，只不过SQL注入是针对数据库的，而OS命令注入是针对操作系统的。OS命令注入攻击指通过Web应用，执行非法的操作系统命令达到攻击的目的。只要在能调用Shell函数的地方久有存在被攻击的风险。倘若调用Shell存在疏漏，就可以执行插入的非法命令。 命令注入攻击可以向Shell发送命令，让Windows或Linux操作系统的命令行启动程序，也就是说，通过命令注入攻击可执行操作系统上安装着的各种程序。 原理 黑客构造命令提交给Web应用程序，Web应用程序提取黑客构造的命令，拼接到被执行的命令中，因黑客注入的命令打破了原有命令结构，导致Web应用执行了额外的命令，最后Web应用程序将执行的结果输出到响应页面中。 我们通过一个例子来说明其原理，假如需要实现一个需求：用户提交一些内容到服务器，然后在服务器执行一些系统命令去返回一个结果给用户。 1234// 以 Node.js 为例，假如在接口中需要从 github 下载用户指定的 repoconst exec = require('mz/child_process').exec;let params = &#123;/* 用户输入的参数 */&#125;;exec(`git clone $&#123;params.repo&#125; /some/path`); 如果 params.repo 传入的是 https://github.com/admin/admin.github.io.git 确实能从指定的 git repo 上下载到想要的代码。 但是如果 params.repo 传入的是 https://github.com/xx/xx.git &amp;&amp; rm -rf /* &amp;&amp; 恰好你的服务是用 root 权限起的就糟糕了。 如何防御 后端对前端提交内容进行规则限制（比如正则表达式）； 在调用系统命令前对所有传入参数进行命令行参数转义过滤； 不要直接拼接命令语句，借助一些工具做拼接、转义预处理，例如 Node.js 的 shell-escape npm包；]]></content>
  </entry>
  <entry>
    <title><![CDATA[HTTPS工作原理]]></title>
    <url>%2F2019%2F08%2F27%2FHTTPS%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[近几年，互联网发送着翻天覆地的变化，尤其是我们一直习以为常的HTTP协议，在逐渐的被HTTPS协议所取代，在浏览器、搜索引擎、CA机构、大型互联网企业的共同促进下，互联网迎来了“HTTPS加密时代”，HTTPS将在未来的几年内全面取代HTTP成为传输协议的主流。 什么是HTTPSHTTPS是在HTTP上建立SSL加密层，并对传输数据进行加密，是HTTP协议的完全版。现在它被广泛用于万维网上安全敏感的通讯，例如交易支付方面。 HTTPS主要作用是： 对数据进行加密，并建立一个信息安全通道，来保证传输过程中的数据安全。 对网站服务器进行真实身份认证。 我们经常会在Web的登录页面和购物结算界面等使用HTTPS通信。使用HTTPS通信时，不再用http://，而是改用https://。另外，当浏览器访问HTTPS通信有效的Web网站时，浏览器的地址栏内会出现一个带锁的标志。对HTTPS的显示方式会因浏览器的不同而有所改变。 为什么需要HTTPS在HTTP协议中有可能存在信息窃取或身份伪装等安全问题。使用HTTPS通信机制可以有效地防止这些问题，接下来，我们先来了解下HTTP协议存在的哪些问题： 通信使用明文（不加密），内容可能被窃取。 由于HTTP本身不具备加密的功能，所以也无法做到对通信整体（使用HTTP协议通信的请求和响应的内容）进行加密，即，HTTP报文使用明文（指未经过加密的报文）方式发送。 HTTP明文协议的缺陷是导致数据泄露、数据篡改、流量劫持、钓鱼攻击等安全问题的重要原因。HTTP协议无法加密数据，所以通信数据都在网络中明文“裸奔”。通过网络的嗅探设备及一些技术手段，就可还原HTTP保温内容。 无法证明报文的完整性，所以可能遭篡改。 所谓完整性是指信息的准备度。若无法证明其完整性，通常也就意味着无法判断信息是否准确。由于HTTP协议无法证明 通信的报文完整性，因此，在请求或响应送出之后直到对方接收之前的这段时间内，即使请求或响应的内容遭到篡改，也没有办法获悉。换句话说，没有任何办法确认，发送的请求/响应和接收到的请求/响应是前后相同的。 不验证通信方的身份，因此有可能遭遇伪装。 HTTP协议中的请求和响应不会对通信方进行确认。在HTTP协议通信时，由于不存在确认通信方的处理步骤，任何人都可以发送请求。另外，服务器只要接收到请求，不管对方是谁都会返回一个响应（但也仅源于发送端的IP地址和端口号没有被Web服务器限定限制访问的前提下） 反观HTTPS协议，它比HTTP协议相比多了以下优势（下文会详细介绍）： 数据隐私性：内容经过对称加密，每个连接生成一个唯一的加密密钥。 数据完整性：内容传输经过完整性校验。 身份认证：第三方无法伪造服务器（客户端）身份。 HTTPS如何解决HTTP上述问题HTTPS并非时应用层的一种新协议。只是HTTP通信接口部分使用SSL和TLS协议代替而已。 通常，HTTP直接和TCP通信。当使用SSL时，则演变成先和SSL通信，再由SSL和TCP通信了。简言之，所谓HTTPS，其实就是身披SSL协议这层外壳的HTTP。 在采用SSL后，HTTP就拥有了HTTPS的加密、证书和完整性保护这些功能。也就是说HTTP加上加密处理和认证以及完整性保护后就是HTTPS。 HTTPS协议的主要功能基本都依赖于TLS/SSL协议，TLS/SSL的功能实现主要依赖于三类基本算法：散列函数、对此加密和非对称加密，其利用非对称加密实现身份认证和密钥协商，对称加密算法采用协商的密钥对数据加密，基于散列函数验证信息的完整性。 解决内容可能被窃听的问题——加密 对称加密 这种方式加密和解密同用一个密钥。加密和解密都会用到密钥。没有密钥就无法对密码解密，反过来说，任何人只要持有密钥就能解密了。 以对称加密方式加密时必须将密钥也发给对方。可究竟怎样才能完全地转交？在互联网上转发密钥时，如果通信被监听那么密钥就可会落人攻击者之手，同时也就失去了加密的意义。另外还得设法安全地保管接收到的密钥。 非对称加密 公开密钥加密使用一对非对称的密钥。一把叫做私有密钥，另一把叫做公开密钥。顾名思义，私有密钥不能让其他任何人知道，而公开密钥则可以随意发布，任何人都可以获得。 使用公开密钥加密方式，发送密文的一方使用对方的公开密钥进行加密处理，对方收到被加密的信息后，再使用自己的私有密钥进行解密。利用 这种方式，不需要发送用来解密的私有密钥，也不必担心密钥被攻击者窃听而盗走。 非对称加密的特点是信息传输一对多，服务器只需要维持一个私钥就能够和多个客户端加密通信。 这种方式有以下缺点： 公钥是公开的，所以针对私钥加密的信息，黑客截获后可以使用公钥进行解密，获取其中的内容； 公钥并不包含服务器的信息，使用非对称加密算法无法确保服务器身份的合法性，存在中间人攻击的风险，服务器发送给客户端的公钥可能在传送过程中被中间人截获并篡改； 使用非对称加密在数据加密解密过程需要消耗一定时间，降低了数据传输效率； 对称加密+非对称加密(HTTPS采用这种方式) 使用对称密钥的好处是解密的效率比较快，使用非对称密钥的好处是可以使得传输的内容不能被破解，因为就算你拦截到了数据，但是没有对应的私钥，也是不能破解内容的。就比如说你抢到了一个保险柜，但是没有保险柜的钥匙也不能打开保险柜。那我们就将对称加密与非对称加密结合起来,充分利用两者各自的优势，在交换密钥环节使用非对称加密方式，之后的建立通信交换报文阶段则使用对称加密方式。 具体做法是：发送密文的一方使用对方的公钥进行加密处理“对称的密钥”，然后对方用自己的私钥解密拿到“对称的密钥”，这样可以确保交换的密钥是安全的前提下，使用对称加密方式进行通信。所以，HTTPS采用对称加密和非对称加密两者并用的混合加密机制。 解决报文可能遭篡改问题——数字签名 网络传输过程中需要经过很多中间节点，虽然数据无法被解密，但可能被篡改，那如何校验数据的完整性呢？——校验数字签名 数字签名有两种功效： 能确定消息确定是由发送方签名并发出来的，因为别人假冒不了发送方的签名； 数字签名能确定消息的完整性，证明数据是否未被篡改； 数字签名如何生成： 将一段文本先用Hash函数生成消息摘要，然后用发送者的私钥加密生成数字签名，与原文一起传送给接收者。接下来就是接收者校验数字签名的流程了。 接收者只有用发送者的公钥才能解密被加密的摘要信息，然后用Hash函数对收到的原文产生一个摘要信息，与上一步得到的摘要信息对比。如果相同，则说明收到的信息是完整的，在传输过程中没有被修改，否则说明信息被修改过，因此数字签名能检验信息的完整性。 假设消息传递在Kobe，James两人之间发生。James将消息连同数字签名一起发送给Kobe，Kobe接收到消息后，通过校验数字签名，就可以验证接收到的消息就是James发送的。当然，这个过程的前提是Kobe知道James的公钥。问题的关键的是，和消息本身一样，公钥不能在不安全的网络中直接发送给Kobe,或者说拿到的公钥如何证明是James的。 此时就需要引入了证书颁发机构（Certificate Authority，简称CA），CA数量并不多，Kobe客户端内置了所有受信任CA的证书。CA对James的公钥（和其他信息）数字签名后生成证书。 解决通信方身份可能被伪装的问题——数字证书 数字证书认证机构处于客户端与服务器双方都可信赖的第三方机构的立场上。 我们来介绍一下数字证书认证机构的业务流程 服务器的运营人员向第三方机构CA提交公钥、组织信息、个人信息(域名)等信息并申请认证; CA通过线上、线下等多种手段验证申请者提供信息的真实性，如组织是否存在、企业是否合法，是否拥有域名的所有权等; 如信息审核通过，CA会向申请者签发认证文件-证书。证书包含以下信息：申请者公钥、申请者的组织信息和个人信息、签发机构 CA的信息、有效时间、证书序列号等信息的明文，同时包含一个签名。 其中签名的产生算法：首先，使用散列函数计算公开的明文信息的信息摘要，然后，采用 CA的私钥对信息摘要进行加密，密文即签名; 客户端 Client 向服务器 Server 发出请求时，Server 返回证书文件; 客户端 Client 读取证书中的相关的明文信息，采用相同的散列函数计算得到信息摘要，然后，利用对应 CA的公钥解密签名数据，对比证书的信息摘要，如果一致，则可以确认证书的合法性，即服务器的公开密钥是值得信赖的。 客户端还会验证证书相关的域名信息、有效时间等信息; 客户端会内置信任CA的证书信息(包含公钥)，如果CA不被信任，则找不到对应 CA的证书，证书也会被判定非法。 HTTPS工作流程 Client发起一个HTTPS（比如https://juejin.im/user/5a9a9cdcf265da238b7d771c）的请求，根据RFC2818的规定，Client知道需要连接Server的443（默认）端口。 Server把事先配置好的公钥证书（public key certificate）返回给客户端。 Client验证公钥证书：比如是否在有效期间，证书的用途是不是匹配Client请求的站点，是不是在CRL吊销列表里面，它的上一级证书是否有效，这是一个递归的过程，直到验证到根证书（操作系统内置的Root证书或者Client内置的Root证书）。如果验证通过则继续，不通过则显示警告信息。 CLient使用伪随机数生成器生成加密所使用的对称密钥，然后用证书的公钥加密这个对称密钥，发给Server。 Server使用自己的私钥解密这个消息，得到对称密钥。至此，Client和Server双方都持有了相同的对称密钥。 Server使用对称密钥加密“明文内容A”，发送给Client。 Client使用对称密钥解密相应的密文，得到“明文内容A”。 Client再次发起HTTPS的请求，使用对称密钥加密请求的“明文内容B”，然后Server使用对称密钥解密密文，得到“明文内容B”。 HTTP与HTTPS的区别 HTTP是明文传输协议，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输，身份认证的网络协议，比HTTP协议安全。 关于安全性，用最简单的比喻形容两者的关系就是卡车运货，HTTP下的运货车是敞篷的，货物都是暴露的。而HTTPS则是封闭集装箱车，安全性自然提升不少。 HTTPS比HTTP更加安全，对搜索引擎更友好，利于SEO,谷歌、百度优先索引HTTPS网页; HTTPS需要用到SSL证书，而HTTP不用; HTTPS标准端口443，HTTP标准端口80; HTTPS基于传输层，HTTP基于应用层; HTTPS在浏览器显示绿色安全锁，HTTP没有显示; 为何不所有的网站都使用HTTPS既然HTTPS那么安全可靠，那为何所有的Web网站都使用HTTPS？ 首先，很多人还是会觉得HTTPS实施有门槛，这个门槛在于需要权威CA颁发的SSL证书。从证书的选择、购买到部署，传统的模式下都会比较耗时耗力。 其次，HTTPS普遍认为性能消耗要大于HTTP，因为与纯文本通信相比，加密通信会消耗更多的CPU及内存资源。如果每次通信都加密，会消耗相当多的资源，平摊到一台计算机上时，能够处理的请求数量必定也会随之减少。但事实并非如此，用户可以通过性能优化、把证书部署在SLB或CDN，来解决此问题。举个实际的例子，“双十一”期间，全站HTTPS的淘宝、天猫依然保证了网站和移动端的访问、浏览、交易等操作的顺畅、平滑。通过测试发现，经过优化后的许多页面性能与HTTP持平甚至还有小幅提升，因此HTTPS经过优化之后其实并不慢。 除此之外，想要节约购买证书的开销也是原因之一。要进行HTTPS通信，证书是必不可少的。而使用的证书必须向认证机构（CA）购买。 最后是安全意识。相比国内，国外互联网行业的安全意识和技术应用相对成熟，HTTPS部署趋势是由社会、企业、政府共同去推动的。]]></content>
  </entry>
  <entry>
    <title><![CDATA[九种跨域方式实现原理]]></title>
    <url>%2F2019%2F08%2F27%2F%E4%B9%9D%E7%A7%8D%E8%B7%A8%E5%9F%9F%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[前后端数据交互经常会碰到请求跨域，什么是跨域，以及有哪几种跨域方式，这是本文要探讨的内容。 什么是跨域 什么是同源策略及其限制内容 同源策略是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS，CSRF等攻击。所谓同源是指“协议+域名+端口”三者相同，即便两个不同的域名指向同一个ip地址，也非同源。 同源策略限制内容有： Cookie、LocalStorage、IndexedDB等存储性内容 DOM节点 AJAX请求发送后，结果被浏览器拦截了 但是有三个标签是允许跨域加载资源： &lt;img scr=XXX&gt; &lt;link href=XXX&gt; &lt;script src=XXX&gt; 常见跨域场景 当协议、子域名、主域名、端口号中有任意一个不相同时，都算作不同域。不同域之间相互请求资源，就算作“跨域”。常见跨域场景如下图所示： 特别说明两点： 第一：如果时协议和端口造成的跨域问题，“前台”时无能为力的 第二：在跨域问题上，仅仅是通过“URL的首部”来识别而不会根据域名对应的IP地址是否相同来判断。“URL的首部”可以理解为“协议，域名和端口必须匹配”。 这里你或许有个疑问：请求跨域了，那请求到底发出去没有？ 跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了。你可能会疑问明明通过表单的方式可以发送跨域请求，为什么Ajax就不会？因为归根结底，跨域是为了阻止用户读取到另一个域名下的内容，Ajax可以获取响应，浏览器认为这不安全，所以拦截了响应。但是表单并不会获取新的内容，所以可以发起跨域请求。同时也说明了跨域并不能完全阻止CSRF，因为请求毕竟是发出去了。 跨域解决方案 jsonp JSONP原理 利用&lt;script&gt;标签没有跨域限制的漏洞，网页可以得到从其他来源动态产生JSON数据。JSONP请求一定需要对方的服务器做支持才可以。 JSONP和AJAX对比 JSONP和AJAX相同，都是客户端向服务器端发送请求，从服务器端获取数据的方式。但AJAX属于同源策略，JSONP属于非同源策略（跨域请求）。 JSONP的优缺点 JSONP优点是简单兼容性好，可用于解决主流浏览器的跨域s数据访问的问题。缺点是仅支持get方法具有局限性，不安全可能会遭受XSS攻击。 JSONP的实现流程 声明一个回调函数，其函数名（如show）当做参数值，要传递给跨域请求数据的服务器，函数形参为要获取目标数据（服务器返回的data） 创建一个&lt;script&gt;标签，把哪个跨域的API数据接口地址，赋值给script的src，还要在这个地址中向服务器传递该函数名（可以通过问好传参：?callback=show）。 服务器接收到请求后，需要进行特殊的处理：把传递进来的函数名和它需要给你的数据拼接成一个字符串，例如：传递进来的函数名是show，它准备好的数据是show(‘我不爱你’)。 最后服务器把准备的数据通过HTTP协议返回给客户端，客户端再调用执行之前按声明的会点函数（show）,对返回的数据进行操作。 在开发中可能会遇到多个JSONP请求的回电函数名是相同的，这时候就需要自己封装一个JSONP函数。 123456789101112131415161718192021222324// index.htmlfunction jsonp(&#123; url, params, callback &#125;) &#123; return new Promise((resolve, reject) =&gt; &#123; let script = document.createElement('script') window[callback] = function(data) &#123; resolve(data) document.body.removeChild(script) &#125; params = &#123; ...params, callback &#125; // wd=b&amp;callback=show let arrs = [] for (let key in params) &#123; arrs.push(`$&#123;key&#125;=$&#123;params[key]&#125;`) &#125; script.src = `$&#123;url&#125;?$&#123;arrs.join('&amp;')&#125;` document.body.appendChild(script) &#125;)&#125;jsonp(&#123; url: 'http://localhost:3000/say', params: &#123; wd: 'Iloveyou' &#125;, callback: 'show'&#125;).then(data =&gt; &#123; console.log(data)&#125;) 上面这段代码相当于向http://localhost:3000/say?wd=Iloveyou&amp;callback=show这个地址请求数据，然后后台返回show(&#39;我不爱你&#39;)，最后会运行show()这个函数，打印出’我不爱你’。 jQuery的hsonp形式 JSONP都是GET和异步请求的，不存在其他的请求方式和同步请求，且jQuery默认就会给JSONP的请求清除缓存。 123456789$.ajax(&#123; url:"http://crossdomain.com/jsonServerResponse", dataType:"jsonp", type:"get",//可以省略 jsonpCallback:"show",//-&gt;自定义传递给服务器的函数名，而不是使用jQuery自动生成的，可省略 jsonp:"callback",//-&gt;把传递函数名的那个形参callback，可省略 success:function (data)&#123; console.log(data);&#125;&#125;); CORS CORS需要浏览器和后端同时支持。IE８和９需要通过XDomainRequest来实现。 浏览器会自动进行CORS通信，实现CORS通信的关键是后端，只要后端实现了CORS，就实现了跨域。 服务器设置Access-Control-Allow-Origin就可以开启CORS。该属性表示哪些域名可以访问资源，如果设置通配符则表示所以网站都可以访问资源。 虽然设置CORS和前端没什么关系，但是通过这种方式解决跨域问题的话，胡在发送请求时出现两种情况，分别为简单请求和复杂请求。 简单请求 只要同时满足以下两大条件，就属于简单请求 条件1：使用下列方法之一： GET HEAD POST 条件2：Content-Type的值仅限于下列三者之一： text/plain multipart/form-data application/x-www-form-urlencoded 请求中的任意XMLHttpRequestUpload对象均没有注册任何事件监听器； XMLHttpRequestUpload 对象可以使用 XMLHttpRequest.upload 属性访问。 复杂请求 不符合以上条件的请求就肯定是复杂请求了，复杂请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为“预检”请求，该请求是option方法的，通过该请求来知道服务端是否允许跨域请求。 我们用PUT向后台请求时，属于复杂请求，后台需做如下配置： 12345678910111213// 允许哪个方法访问我res.setHeader('Access-Control-Allow-Methods', 'PUT')// 预检的存活时间res.setHeader('Access-Control-Max-Age', 6)// OPTIONS请求不做任何处理if (req.method === 'OPTIONS') &#123; res.end() &#125;// 定义后台返回的内容app.put('/getData', function(req, res) &#123; console.log(req.headers) res.end('我不爱你')&#125;) 接下来我们看一下完整复杂请求的例子，并且介绍CORS请求相关的字段 12345678910111213141516// index.htmllet xhr = new XMLHttpRequest()document.cookie = 'name=xiamen' // cookie不能跨域xhr.withCredentials = true // 前端设置是否带cookiexhr.open('PUT', 'http://localhost:4000/getData', true)xhr.setRequestHeader('name', 'xiamen')xhr.onreadystatechange = function() &#123; if (xhr.readyState === 4) &#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status === 304) &#123; console.log(xhr.response) //得到响应头，后台需设置Access-Control-Expose-Headers console.log(xhr.getResponseHeader('name')) &#125; &#125;&#125;xhr.send() 12345//server1.jslet express = require('express');let app = express();app.use(express.static(__dirname));app.listen(3000); 123456789101112131415161718192021222324252627282930313233343536//server2.jslet express = require('express')let app = express()let whitList = ['http://localhost:3000'] //设置白名单app.use(function(req, res, next) &#123; let origin = req.headers.origin if (whitList.includes(origin)) &#123; // 设置哪个源可以访问我 res.setHeader('Access-Control-Allow-Origin', origin) // 允许携带哪个头访问我 res.setHeader('Access-Control-Allow-Headers', 'name') // 允许哪个方法访问我 res.setHeader('Access-Control-Allow-Methods', 'PUT') // 允许携带cookie res.setHeader('Access-Control-Allow-Credentials', true) // 预检的存活时间 res.setHeader('Access-Control-Max-Age', 6) // 允许返回的头 res.setHeader('Access-Control-Expose-Headers', 'name') if (req.method === 'OPTIONS') &#123; res.end() // OPTIONS请求不做任何处理 &#125; &#125; next()&#125;)app.put('/getData', function(req, res) &#123; console.log(req.headers) res.setHeader('name', 'jw') //返回一个响应头，后台需设置 res.end('我不爱你')&#125;)app.get('/getData', function(req, res) &#123; console.log(req.headers) res.end('我不爱你')&#125;)app.use(express.static(__dirname))app.listen(4000) 上述代码由http://localhost:3000/index.html向http://localhost:4000/跨域请求，正如我们上面所说的，后端是实现 CORS 通信的关键。 postMessage postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题： 页面和其打开的新窗口的数据传递 多窗口之间消息传递 页面与嵌套的iframe消息传递 上面三个场景的跨域数据传递 postMessage()方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递。 otherWindows.oistMessage(message, targetOrigin, [transfer]); message: 将要发送到其他 window的数据。 targetOrigin:通过窗口的origin属性来指定哪些窗口能接收到消息事件，其值可以是字符串”*”（表示无限制）或者一个URI。在发送消息的时候，如果目标窗口的协议、主机地址或端口这三者的任意一项不匹配targetOrigin提供的值，那么消息就不会被发送；只有三者完全匹配，消息才会被发送。 transfer(可选)：是一串和message 同时传递的 Transferable 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。 接下来我们看个例子： http://localhost:3000/a.html页面向http://localhost:4000/b.html传递“我爱你”,然后后者传回”我不爱你”。 123456789101112// a.html &lt;iframe src="http://localhost:4000/b.html" frameborder="0" id="frame" onload="load()"&gt;&lt;/iframe&gt; //等它加载完触发一个事件 //内嵌在http://localhost:3000/a.html &lt;script&gt; function load() &#123; let frame = document.getElementById('frame') frame.contentWindow.postMessage('我爱你', 'http://localhost:4000') //发送数据 window.onmessage = function(e) &#123; //接受返回数据 console.log(e.data) //我不爱你 &#125; &#125; &lt;/script&gt; 12345// b.html window.onmessage = function(e) &#123; console.log(e.data) //我爱你 e.source.postMessage('我不爱你', e.origin) &#125; WebSocket WebSocket是HTML5的一个持久化的协议，它实现了浏览器与服务器的全双工通信，同时也是跨域的一种解决方案。WebSocket和HTTP都是应用层协议，都基于TCP协议。但是WebSocket是一种双向通信协议，在建立连接之后，WebSocket的server与client都能主动向对方发送或接收数据。同时，WebSocket在建立连接时需要HTTP协议，连接建立好了之后client与server之间的双向通信就与HTTP无关了。 原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好地封装了WebSocket接口，提供了更简单、灵活的接口，也对不支持WebSocket的浏览器提供向下兼容。 我们先来看个例子：本地文件socket.html向localhost:3000发生数据和接受数据 12345678910// socket.html&lt;script&gt; let socket = new WebSocket('ws://localhost:3000'); socket.onopen = function () &#123; socket.send('我爱你');//向服务器发送数据 &#125; socket.onmessage = function (e) &#123; console.log(e.data);//接收服务器返回的数据 &#125;&lt;/script&gt; 1234567891011// server.jslet express = require('express');let app = express();let WebSocket = require('ws');//记得安装wslet wss = new WebSocket.Server(&#123;port:3000&#125;);wss.on('connection',function(ws) &#123; ws.on('message', function (data) &#123; console.log(data); ws.send('我不爱你') &#125;);&#125;) Node中间件代理（两次跨域） 实现原理：同源策略是浏览器需要遵循的标准，而如果是服务器向服务器请求就无需遵循同源策略。代理服务器，需要做以下几个步骤： 接收客户端请求。 将请求转发给服务器 拿到服务器响应数据。 将响应数据转发给客户端 我们先来看个例子：本地文件index.html文件，通过代理服务器http://localhost:3000向目标服务器http://localhost:4000请求数据。 12345678910111213141516// index.html(http://127.0.0.1:5500) &lt;script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"&gt;&lt;/script&gt; &lt;script&gt; $.ajax(&#123; url: 'http://localhost:3000', type: 'post', data: &#123; name: 'xiamen', password: '123456' &#125;, contentType: 'application/json;charset=utf-8', success: function(result) &#123; console.log(result) // &#123;"title":"fontend","password":"123456"&#125; &#125;, error: function(msg) &#123; console.log(msg) &#125; &#125;) &lt;/script&gt; 1234567891011121314151617181920212223242526272829303132333435363738// server1.js 代理服务器(http://localhost:3000)const http = require('http')// 第一步：接受客户端请求const server = http.createServer((request, response) =&gt; &#123; // 代理服务器，直接和浏览器直接交互，需要设置CORS 的首部字段 response.writeHead(200, &#123; 'Access-Control-Allow-Origin': '*', 'Access-Control-Allow-Methods': '*', 'Access-Control-Allow-Headers': 'Content-Type' &#125;) // 第二步：将请求转发给服务器 const proxyRequest = http .request( &#123; host: '127.0.0.1', port: 4000, url: '/', method: request.method, headers: request.headers &#125;, serverResponse =&gt; &#123; // 第三步：收到服务器的响应 var body = '' serverResponse.on('data', chunk =&gt; &#123; body += chunk &#125;) serverResponse.on('end', () =&gt; &#123; console.log('The data is ' + body) // 第四步：将响应结果转发给浏览器 response.end(body) &#125;) &#125; ) .end()&#125;)server.listen(3000, () =&gt; &#123; console.log('The proxyServer is running at http://localhost:3000')&#125;) 1234567891011// server2.js(http://localhost:4000)const http = require('http')const data = &#123; title: 'fontend', password: '123456' &#125;const server = http.createServer((request, response) =&gt; &#123; if (request.url === '/') &#123; response.end(JSON.stringify(data)) &#125;&#125;)server.listen(4000, () =&gt; &#123; console.log('The server is running at http://localhost:4000')&#125;) 上述代码经过两次跨域，值得注意的是浏览器向代理服务器发送请求，也遵循同源策略，最后在index.html文件打印出{&quot;title&quot;:&quot;fontend&quot;,&quot;password&quot;:&quot;123456&quot;} nginx反向代理 实现原理类似于Node中间件代理，需要你搭建一个中转nginx服务器，用于转发请求。 使用nginx反向代理实现跨域，是最简单的跨域方式。只需要修改nginx的配置即可解决跨域问题，支持所有浏览器，支持session，不需要修改任何代码，并且不会影响服务器性能。 实现思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。 先下载nginx，然后将nginx目录下的nginx.com修改如下： 1234567891011121314// proxy服务器server &#123; listen 81; server_name www.domain1.com; location / &#123; proxy_pass http://www.domain2.com:8080; #反向代理 proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名 index index.html index.htm; # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用 add_header Access-Control-Allow-Origin http://www.domain1.com; #当前端只跨域不带cookie时，可为* add_header Access-Control-Allow-Credentials true; &#125;&#125; 最后通过命令行nginx-sreload启动nginx 1234567// index.htmlvar xhr = new XMLHttpRequest();// 前端开关：浏览器是否读写cookiexhr.withCredentials = true;// 访问nginx中的代理服务器xhr.open('get', 'http://www.domain1.com:81/?user=admin', true);xhr.send(); 123456789101112131415// server.jsvar http = require('http');var server = http.createServer();var qs = require('querystring');server.on('request', function(req, res) &#123; var params = qs.parse(req.url.substring(2)); // 向前台写cookie res.writeHead(200, &#123; 'Set-Cookie': 'l=a123456;Path=/;Domain=www.domain2.com;HttpOnly' // HttpOnly:脚本无法读取 &#125;); res.write(JSON.stringify(params)); res.end();&#125;);server.listen('8080');console.log('Server is running at port 8080...'); window.name + iframewindow.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。 其中a.html和b.html是同域的，都是http://localhost:3000;而c.html是http://localhost:4000 12345678910111213141516&lt;iframe src="http://localhost:4000/c.html" frameborder="0" onload="load()" id="iframe"&gt;&lt;/iframe&gt; &lt;script&gt; let first = true // onload事件会触发2次，第1次加载跨域页，并留存数据于window.name function load() &#123; if(first)&#123; // 第1次onload(跨域页)成功后，切换到同域代理页面 let iframe = document.getElementById('iframe'); iframe.src = 'http://localhost:3000/b.html'; first = false; &#125;else&#123; // 第2次onload(同域b.html页)成功后，读取同域window.name中数据 console.log(iframe.contentWindow.name); &#125; &#125; &lt;/script&gt; b.html为中间代理页，与a.html同域，内容为空。 1234// c.html(http://localhost:4000/c.html) &lt;script&gt; window.name = '我不爱你' &lt;/script&gt; 总结：通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。 location.hash + iframe实现原理： a.html欲与c.html跨域相互通信，通过中间页b.html来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。 具体实现步骤：一开始a.html给c.html传一个hash值，然后c.html收到hash值后，再把hash值传递给b.html，最后b.html将结果放到a.html的hash值中。 同样的，a.html和b.html是同域的，都是http://localhost:3000;而c.html是http://localhost:4000 1234567// a.html &lt;iframe src="http://localhost:4000/c.html#iloveyou"&gt;&lt;/iframe&gt; &lt;script&gt; window.onhashchange = function () &#123; //检测hash的变化 console.log(location.hash); &#125; &lt;/script&gt; 12345// b.html &lt;script&gt; window.parent.parent.location.hash = location.hash //b.html将结果放到a.html的hash值中，b.html可通过parent.parent访问a.html页面 &lt;/script&gt; 12345// c.htmlconsole.log(location.hash); let iframe = document.createElement('iframe'); iframe.src = 'http://localhost:3000/b.html#idontloveyou'; document.body.appendChild(iframe); document.domain + iframe该方式只能用于二级域名相同的情况下，比如 a.test.com 和 b.test.com 适用于该方式。 只需要给页面添加 document.domain =&#39;test.com&#39; 表示二级域名都相同就可以实现跨域。 实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。 我们看个例子：页面a.zf1.cn:3000/a.html获取页面b.zf1.cn:3000/b.html中a的值 1234567891011// a.html&lt;body&gt; helloa &lt;iframe src="http://b.zf1.cn:3000/b.html" frameborder="0" onload="load()" id="frame"&gt;&lt;/iframe&gt; &lt;script&gt; document.domain = 'zf1.cn' function load() &#123; console.log(frame.contentWindow.a); &#125; &lt;/script&gt;&lt;/body&gt; 12345678// b.html&lt;body&gt; hellob &lt;script&gt; document.domain = 'zf1.cn' var a = 100; &lt;/script&gt;&lt;/body&gt;总结 CORS支持所有类型的HTTP请求，是跨域HTTP请求的根本解决方案 JSONP只支持GET请求，JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。 不管是Node中间件代理还是nginx反向代理，主要是通过同源策略对服务器不加限制。 日常工作中，用得比较多的跨域方案是cors和nginx反向代理]]></content>
  </entry>
  <entry>
    <title><![CDATA[浏览器渲染原理]]></title>
    <url>%2F2019%2F08%2F21%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[浏览器的内核是指支持浏览器运行的最核心的程序，分为两个部分的，一是渲染引擎，二是JS引擎。渲染引擎在不同的浏览器中也不是都相同的。目前市面上常见的柳然其内核可以分为这四种：Trident（IE）、Gecko（Firefox)、Blink（Chrome、Opera）、Webkit（Safari）。这里面大家最耳熟能详的应该是Webkit内核了，Webkit内核时当下浏览器最好的内核。 本文我就以Webkit为例，对现代浏览器的渲染过程进行一个深度的剖析。 页面加载过程在介绍浏览器渲染过程之前，我们简明扼要介绍下页面的加载过程，有助于更好理解后续渲染过程。 要点如下： 浏览器根据 DNS 服务器得到域名的 IP 地址。 向这个 IP 的机器发送 HTTP 请求 服务器收到、处理并返回 HTTP 请求 浏览器得到返回内容例如在浏览器输入https://juejin.im/timeline，然后经过 DNS 解析，juejin.im对应的 IP 是36.248.217.149（不同时间、地点对应的 IP 可能会不同）。然后浏览器向该 IP 发送 HTTP 请求。 服务端接收到 HTTP 请求，然后经过计算（向不同的用户推送不同的内容），返回 HTTP 请求，返回的内容如下：其实就是一堆 HMTL 格式的字符串，因为只有 HTML 格式浏览器才能正确解析，这是 W3C 标准的要求。接下来就是浏览器的渲染过程。 浏览器渲染过程 浏览器渲染过程大体分为如下三部分： 浏览器会解析三个东西： 一是HTML/SVG/XHTML，HTML字符串描述了一个页面的结构，浏览器会把HTML结构字符串解析转换DOM树形结构。 二是CSS，解析CSS会产生CSS规则树，它和DOM结构比较像。 三是Javascript脚本，等到Javascript 脚本文件加载后， 通过 DOM API 和 CSSOM API 来操作 DOM Tree 和 CSS Rule Tree。 解析完成后，浏览器引擎会通过DOM Tree和CSS Rule Tree来构造Rendering Tree。 Render Tree渲染树并不等同于DOM树，渲染树只会包括需要显示的节点和这些节点的样式信息。 CSS的Rule Tree主要是为了完成匹配并把CSS Rule附加上Rendering Tree上的每个ELement（也就是每个Frame）。 然后，计算每个Frame的位置，这又叫layout和reflow的过程 最好通过调用操作系统Native GUI的API绘制 接下来我们针对这其中所经历的重要步骤详细阐述 构建DOM浏览器会遵守一套步骤将HTML文件转换为DOM树。宏观上，可以分为几个步骤： 浏览器从磁盘或网络读取HTML的原始字节，并根据文件的指定编码（例如UTF-8）将它们转换成字符串。 在网络中传输的内容其实都是0与1这些字节数据，当浏览器接收到这些字节数据以后，它会将这些字节数据转换字符串，也就是我们写的代码。 将字符串转换Token，例如：、等。Token中会标识出当前Token是“开始标签”或是“结束标签”亦或是“文本”等信息。L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"log":false}); 这时候你一定会有疑问，节点与节点之间的关系如何维护？ 事实上，这就是Token要标识“起始标签”和“结束标签”等标识的作用。例如“title”Token的起始标签和结束标签之间的节点肯定是属于“head”的子节点 上图给出了节点之间的关系，例如：“Hello”Token位于“title”开始标签与“title”结束标签之间，表明“Hello”Token是“title”Token的子节点。同理“title”Token是“head”Token的子节点。 生成节点对象并构建DOM 事实上，构建DOM的过程中，不是等所有Token都转换完成后再去生成节点对象，而是一边生成Token一边消耗Token来生成节点对象。换句话说，每个Token被生成后，会立刻消耗这个Token创建出节点对象。注意：带有结束标签标识的Token不会创建节点对象。 接下来我们举个例子，假设有段HTML文本： 1234567891011&lt;html&gt;&lt;head&gt; &lt;title&gt;Web page parsing&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;h1&gt;Web page parsing&lt;/h1&gt; &lt;p&gt;This is an example Web page.&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 上面这段HTML会解析成这样： 构建CSSOMDOM会捕获页面的内容，但浏览器还需要知道页面如何展示，所以需要构建CSSOM。 构建CSSOM的过程与构建DOM的过程非常相似，当浏览器接收到一段CSS，浏览器首先要做的是识别出Token，然后构建节点并生成CSSOM。 在这一过程中，浏览器会确定下每一个节点的样式到底是什么，并且这一过程其实是很消耗资源的。因为样式你可以自行设置给某个节点，也可以通过继承获得。在这一过程中，浏览器得递归 CSSOM 树，然后确定具体的元素到底是什么样式。 注意：CSS匹配HTML元素是一个相当复杂和有性能问题的事情。所以，DOM树要小，CSS尽量用id和class，千万不要过渡层叠下去。 构架渲染树当我们生成 DOM 树和 CSSOM 树以后，就需要将这两棵树组合为渲染树。 在这一过程中，不是简单的将两者合并就行了。渲染树只会包括需要显示的节点和这些节点的样式信息，如果某个节点是 display: none 的，那么就不会在渲染树中显示。 我们或许有个疑惑：浏览器如果渲染过程中遇到JS文件怎么处理？ 渲染过程中，如果遇到&lt;script&gt;就停止渲染，执行 JS 代码。因为浏览器有GUI渲染线程与JS引擎线程，为了防止渲染出现不可预期的结果，这两个线程是互斥的关系。JavaScript的加载、解析与执行会阻塞DOM的构建，也就是说，在构建DOM时，HTML解析器若遇到了JavaScript，那么它会暂停构建DOM，将控制权移交给JavaScript引擎，等JavaScript引擎运行完毕，浏览器再从中断的地方恢复DOM构建。 也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。当然在当下，并不是说 script 标签必须放在底部，因为你可以给 script 标签添加 defer 或者 async 属性（下文会介绍这两者的区别）。 JS文件不只是阻塞DOM的构建，它会导致CSSOM也阻塞DOM的构建。 原本DOM和CSSOM的构建是互不影响，井水不犯河水，但是一旦引入了JavaScript，CSSOM也开始阻塞DOM的构建，只有CSSOM构建完毕后，DOM再恢复DOM构建。 这是什么情况？ 这是因为JavaScript不只是可以改DOM，它还可以更改样式，也就是它可以更改CSSOM。因为不完整的CSSOM是无法使用的，如果JavaScript想访问CSSOM并更改它，那么在执行JavaScript时，必须要能拿到完整的CSSOM。所以就导致了一个现象，如果浏览器尚未完成CSSOM的下载和构建，而我们却想在此时运行脚本，那么浏览器将延迟脚本执行和DOM构建，直至其完成CSSOM的下载和构建。也就是说，在这种情况下，浏览器会先下载和构建CSSOM，然后再执行JavaScript，最后在继续构建DOM。 布局与绘制当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动重排”。 布局流程的输出是一个“盒模型”，它会精确地捕获每个元素在视口内的确切位置和尺寸，所有相对测量值都将转换为屏幕上的绝对像素。 布局完成后，浏览器会立即发出“Paint Setup”和“Paint”事件，将渲染树转换成屏幕上的像素。 以上我们详细介绍了浏览器工作流程中的重要步骤，接下来我们讨论几个相关的问题： 几点补充说明 async和defer的作用是什么？有什么区别? 接下来我们对比下 defer 和 async 属性的区别： 其中蓝色线代表JavaScript加载；红色线代表JavaScript执行；绿色线代表 HTML 解析。 1）情况1&lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt;没有 defer 或 async，浏览器会立即加载并执行指定的脚本，也就是说不等待后续载入的文档元素，读到就加载并执行。 2）情况2&lt;script async src=&quot;script.js&quot;&gt;&lt;/script&gt; (异步下载)async 属性表示异步执行引入的 JavaScript，与 defer 的区别在于，如果已经加载好，就会开始执行——无论此刻是 HTML 解析阶段还是 DOMContentLoaded 触发之后。需要注意的是，这种方式加载的 JavaScript 依然会阻塞 load 事件。换句话说，async-script 可能在 DOMContentLoaded 触发之前或之后执行，但一定在 load 触发之前执行。 3）情况3 &lt;script defer src=&quot;script.js&quot;&gt;&lt;/script&gt;(延迟执行)defer 属性表示延迟执行引入的 JavaScript，即这段 JavaScript 加载时 HTML 并未停止解析，这两个过程是并行的。整个 document 解析完毕且 defer-script 也加载完成之后（这两件事情的顺序无关），会执行所有由 defer-script 加载的 JavaScript 代码，然后触发 DOMContentLoaded 事件。 defer 与相比普通 script，有两点区别：载入 JavaScript 文件时不阻塞 HTML 的解析，执行阶段被放到 HTML 标签解析完成之后。在加载多个JS脚本的时候，async是无顺序的加载，而defer是有顺序的加载。 为什么操作 DOM 慢 把 DOM 和 JavaScript 各自想象成一个岛屿，它们之间用收费桥梁连接。——《高性能 JavaScript》 JS 是很快的，在 JS 中修改 DOM 对象也是很快的。在JS的世界里，一切是简单的、迅速的。但 DOM 操作并非 JS 一个人的独舞，而是两个模块之间的协作。 因为 DOM 是属于渲染引擎中的东西，而 JS 又是 JS 引擎中的东西。当我们用 JS 去操作 DOM 时，本质上是 JS 引擎和渲染引擎之间进行了“跨界交流”。这个“跨界交流”的实现并不简单，它依赖了桥接接口作为“桥梁”（如下图）。 过“桥”要收费——这个开销本身就是不可忽略的。我们每操作一次 DOM（不管是为了修改还是仅仅为了访问其值），都要过一次“桥”。过“桥”的次数一多，就会产生比较明显的性能问题。因此“减少 DOM 操作”的建议，并非空穴来风。 你真的了解回流和重绘吗 渲染的流程基本上是这样（如下图黄色的四个步骤）：1.计算CSS样式 2.构建Render Tree 3.Layout – 定位坐标和大小 4.正式开画 注意：上图流程中有很多连接线，这表示了Javascript动态修改了DOM属性或是CSS属性会导致重新Layout，但有些改变不会重新Layout，就是上图中那些指到天上的箭头，比如修改后的CSS rule没有被匹配到元素。 这里重要要说两个概念，一个是Reflow，另一个是Repaint 重绘：当我们对 DOM 的修改导致了样式的变化、却并未影响其几何属性（比如修改了颜色或背景色）时，浏览器不需重新计算元素的几何属性、直接为该元素绘制新的样式（跳过了上图所示的回流环节）。 回流：当我们对 DOM 的修改引发了 DOM 几何尺寸的变化（比如修改元素的宽、高或隐藏元素等）时，浏览器需要重新计算元素的几何属性（其他元素的几何属性和位置也会因此受到影响），然后再将计算的结果绘制出来。这个过程就是回流（也叫重排） 我们知道，当网页生成的时候，至少会渲染一次。在用户访问的过程中，还会不断重新渲染。重新渲染会重复回流+重绘或者只有重绘。回流必定会发生重绘，重绘不一定会引发回流。重绘和回流会在我们设置节点样式时频繁出现，同时也会很大程度上影响性能。回流所需的成本比重绘高的多，改变父节点里的子节点很可能会导致父节点的一系列回流。 1）常见引起回流属性和方法任何会改变元素几何信息(元素的位置和尺寸大小)的操作，都会触发回流， 添加或者删除可见的DOM元素； 元素尺寸改变——边距、填充、边框、宽度和高度 内容变化，比如用户在input框中输入文字 浏览器窗口尺寸改变——resize事件发生时 计算 offsetWidth 和 offsetHeight 属性 设置 style 属性的值 2）常见引起重绘属性和方法 3）如何减少回流、重绘 使用 transform 替代 top 使用 visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回流（改变了布局） 不要把节点的属性值放在一个循环里当成循环里的变量。 1234for(let i = 0; i &lt; 1000; i++) &#123; // 获取 offsetTop 会导致回流，因为需要去获取正确的值 console.log(document.querySelector(&apos;.test&apos;).style.offsetTop)&#125; 不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局 动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 requestAnimationFrame CSS 选择符从右往左匹配查找，避免节点层级过多 将频繁重绘或者回流的节点设置为图层，图层能够阻止该节点的渲染行为影响别的节点。比如对于 video 标签来说，浏览器会自动将该节点变为图层。 性能优化策略基于上面介绍的浏览器渲染原理，DOM 和 CSSOM 结构构建顺序，初始化可以对页面渲染做些优化，提升页面性能。 JS优化： 1&lt;script&gt; 标签加上 defer属性 和 async属性 用于在不阻塞页面文档解析的前提下，控制脚本的下载和执行。 defer属性： 用于开启新的线程下载脚本文件，并使脚本在文档解析完成后执行。 async属性： HTML5新增属性，用于异步下载脚本文件，下载完毕立即解释执行代码。 CSS优化： &lt;link&gt; 标签的 rel属性 中的属性值设置为 preload 能够让你在你的HTML页面中可以指明哪些资源是在页面加载完成后即刻需要的,最优的配置加载顺序，提高渲染性能 总结综上所述，我们得出这样的结论： 浏览器工作流程：构建DOM -&gt; 构建CSSOM -&gt; 构建渲染树 -&gt; 布局 -&gt; 绘制。 CSSOM会阻塞渲染，只有当CSSOM构建完毕后才会进入下一个阶段构建渲染树。 通常情况下DOM和CSSOM是并行构建的，但是当浏览器遇到一个不带defer或async属性的script标签时，DOM构建将暂停，如果此时又恰巧浏览器尚未完成CSSOM的下载和构建，由于JavaScript可以修改CSSOM，所以需要等CSSOM构建完毕后再执行JS，最后才重新DOM构建。]]></content>
  </entry>
  <entry>
    <title><![CDATA[从URL输入到页面展现]]></title>
    <url>%2F2019%2F08%2F19%2F%E4%BB%8EURL%E8%BE%93%E5%85%A5%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[在浏览器中输入URL到整个页面显示在用户面前时这个过程中到底发生了什么？经历怎样的一个过程？ 总体来说分为以下几个过程： DNS解析：将域名分析成IP地址 TCP连接：TCP三次握手 发生HTTP请求 服务器处理请求并返回HTTP报文 浏览器解析渲染页面 断开连接：TCP四次握手 URL到底是啥URL（Uniform Resource Locator），统一资源定位符，用来定位互联网资源，俗称网址。 1scheme://host.domain:port/path/filename 各部分解释如下： scheme - 定义因特网服务的类型。常见的协议有http、https、ftp和file，其中最常见的类型是http，而https则是进行加密的网络传输。 host - 定义域主机(http的默认主机是www)。 domain - 定义因特网域名，比如w3school.com.cn。 port - 定义主机上的端口号（http的默认端口是80）。 path - 定义服务器上的路径（如果省略，则文档必须位于网站的根目录中）。 filename - 定义文档/资源的名称。 域名解析（DNS）在浏览器输入网址后，首先要经过域名解析，因为浏览器并不能直接通过域名找到对应的服务器，而是要通过IP地址。大家这里或许会有个疑问——计算机既可以被赋予IP地址，又可以被赋予主机名和域名。那怎么不一开始就赋予个 IP 地址？这样就可以省去解析麻烦。我们先来了解下什么是 IP 地址。 IP地址 IP地址是指互联网协议地址，是IP Address的缩写。IP地址是IP协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。IP地址是一个32位的二进制数，比如127.0.0.1为本机地址。 什么是域名解析 DNS协议提供通过域名查找IP地址，或逆向从IP地址反查找域名的服务。DNS是一个网络服务器，我们的域名解析简单来说就是在DNS上记录一条信息记录。 1例如 baidu.com 220.114.23.56（服务器外网IP地址）80（服务器端口号） 浏览器如何通过域名去查询URL对应的IP呢 浏览器缓存：浏览器会按照一定的频率缓存DNS记录。 操作系统缓存：如果浏览器缓存中找不到需要的DNS记录，那就去操作系统中找。 路由缓存：路由器也是有DNS缓存的。 ISP的DNS服务器：ISP是互联网服务提供商（Internet Service Provider）的简称，ISP有专门的DNS服务器应对DNS查询请求。 根服务器：ISP的DNS服务器还找不到的话，它就会向根服务器发出请求，进行递归查询（DNS 服务器先问根域名服务器.com 域名服务器的 IP 地址，然后再问.baidu 域名服务器，依次类推）。 小结 浏览器通过向 DNS 服务器发送域名，DNS 服务器查询到与域名相对应的 IP 地址，然后返回给浏览器，浏览器再将 IP 地址打在协议上，同时请求参数也会在协议搭载，然后一并发送给对应的服务器。接下来介绍向服务器发送 HTTP 请求阶段，HTTP 请求分为三个部分：TCP 三次握手、http 请求响应信息、关闭 TCP 连接。 TCP三次握手在客户端发送数据之前会发起 TCP 三次握手用以同步客户端和服务端的序列号和确认号，并交换 TCP 窗口大小信息。 TCP三次握手的过程如下： 客户端发送一个带SYN，Seq=X的数据包到服务器端口（第一次握手，由浏览器发起，告诉服务器我要发送请求了）。 服务器发回一个带 SYN=1， ACK=X+1， Seq=Y 的响应包以示传达确认信息（第二次握手，由服务器发起，告诉浏览器我准备接受了，你赶紧发送吧）。 客户端再回传一个带 ACK=Y+1， Seq=Z 的数据包，代表“握手结束”（第三次握手，由浏览器发送，告诉服务器，我马上就发了，准备接受吧）。 为什么需要三次握手 谢希仁著《计算机网络》中讲“三次握手”的目的是“为了防止已失效的连接请求报文段突然又传送到服务器端，因而产生错误”。 发送HTTP请求TCP三次握手结束后，开始发送HTTP请求报文。 请求报文由请求行（request line）、请求头（header）、空行、请求体四个部分组成，如下图所示： 请求行包含请求方法、URL、协议版本 请求方法包含8种：GET、POST、PUT、DELETE、PATCH、HEAD、OPTIONS、TRACE。 URL即请求地址，由&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;&lt;参数&gt;组成 协议版本即http版本号 1POST /chapter17/user.html HTTP/1.1 以上代码中“POST”代表请求方法，“/chapter17/user.html”表示 URL，“HTTP/1.1”代表协议和协议的版本。现在比较流行的是 Http1.1 版本。 请求头包含请求的附加信息，由关键字/值对组成，每行一对，关键字和值由英文冒号“:”分割。 请求头部通知服务器有关客户端请求的信息。它包含许多有关的客户端环境和请求正文的有用信息。其中比如：Host，表示主机名，虚拟主机；Connection，HTTP/1.1增加的，使用keep-alive，即持续连接，一个链接可以发送多个请求；User-Agent，请求发送者，兼容性以及定制化需求。 请求体，可以承载多个请求参数的数据，包含回车符、换行符和请求数据，并不是所有请求都具有请求数据。 1name=tom&amp;password=1234&amp;realName=tomson 上面代码，承载着 name、password、realName 三个请求参数。 服务器处理请求并返回HTTP报文 服务器 服务器是网络环境中的高性能计算机，它侦听网络上的其他计算机（客户机）提交的服务请求，并提供相应的服务，比如网页服务、文件下载服务、邮件服务、视频服务。而客户端主要的功能是浏览网页、看视频、听音乐等等，两者截然不同。 每台服务器上都会安装处理请求的应用——web server。常见的 web server 产品有 apache、nginx、IIS 或 Lighttpd 等。web server 担任管控的角色，对于不同用户发送的请求，会结合配置文件，把不同请求委托给服务器上处理相应请求的程序进行处理（例如 CGI 脚本，JSP 脚本，servlets，ASP 脚本，服务器端 JavaScript，或者一些其它的服务器端技术等），然后返回后台程序处理产生的结果作为响应。 2.MVC 后台处理阶段 后台开发现在有很多框架，但大部分都还是按照 MVC 设计模式进行搭建的。 MVC 是一个设计模式，将应用程序分成三个核心部件：模型（model）– 视图（view）–控制器（controller），它们各自处理自己的任务，实现输入、处理和输出的分离。 3.http 响应报文 响应报文由响应行（request line）、响应头部（header）、响应主体三个部分组成。如下图所示： 响应行包含：协议版本，状态码，状态码描述 状态码规则如下：1xx：指示信息–表示请求已接收，继续处理。2xx：成功–表示请求已被成功接收、理解、接受。3xx：重定向–要完成请求必须进行更进一步的操作。4xx：客户端错误–请求有语法错误或请求无法实现。5xx：服务器端错误–服务器未能实现合法的请求。 响应头部包含响应报文的附加信息，由 名/值 对组成 响应主体包含回车符、换行符和响应返回数据，并不是所有响应报文都有响应数据 浏览器解析渲染页面浏览器拿到响应文本HTML后，接下来介绍下浏览器渲染机制 浏览器解析渲染页面分为以下五个步骤： 根据HTML解析出DOM树 根据CSS解析生成CSS规则树 结合DOM树和CSS规则树，生成渲染树 根据渲染树计算每一个节点的信息 根据计算好的信息绘制页面 根据HTML解析DOM树 根据HTML的内容，将标签按照结构解析成为DOM树，DOM树解析的过程是一个深度优先遍历，即先构建当前节点的所有子节点，再构建下一个兄弟节点。 再读取HTML文档，构建DOM树的过程中，若遇到script标签则DOM树的构建会暂停，直到脚本执行完毕。 根据CSS解析生成CSS规则树 解析CSS规则树时js执行将暂停，直到CSS规则树就绪 浏览器在CSS规则树生成之前不会进行渲染 结合DOM树和CSS规则树，生成渲染树 DOM 树和 CSS 规则树全部准备好了以后，浏览器才会开始构建渲染树。 精简 CSS 并可以加快 CSS 规则树的构建，从而加快页面相应速度。 根据渲染树计算每一个节点的信息（布局） 布局：通过渲染树中渲染对象的信息，计算出每一个渲染对象的位置和尺寸 回流：在布局完成后，发现了某个部分发生了变化影响了布局，那就需要倒回去重新渲染 根据计算好的信息绘制页面 绘制阶段，系统会遍历呈现树，并调用呈现器的“paint”方法，将呈现器的内容显示在屏幕上。 重绘：某个元素的背景颜色，文字颜色等，不影响元素周围或内部布局的属性，将只会引起浏览器的重绘。 回流：某个元素的尺寸发生了变化，则需重新计算渲染树，重新渲染。 断开连接当数据传送完毕，需要断开 tcp 连接，此时发起 tcp 四次挥手 发起方向被动方发送报文，Fin、Ack、Seq，表示已经没有数据传输了。并进入 FIN_WAIT_1 状态。(第一次挥手：由浏览器发起的，发送给服务器，我请求报文发送完了，你准备关闭吧) 被动方发送报文，Ack、Seq，表示同意关闭请求。此时主机发起方进入 FIN_WAIT_2 状态。(第二次挥手：由服务器发起的，告诉浏览器，我请求报文接受完了，我准备关闭了，你也准备吧) 被动方向发起方发送报文段，Fin、Ack、Seq，请求关闭连接。并进入 LAST_ACK 状态。(第三次挥手：由服务器发起，告诉浏览器，我响应报文发送完了，你准备关闭吧) 发起方向被动方发送报文段，Ack、Seq。然后进入等待 TIME_WAIT 状态。被动方收到发起方的报文段以后关闭连接。发起方等待一定时间未收到回复，则正常关闭。(第四次挥手：由浏览器发起，告诉服务器，我响应报文接受完了，我准备关闭了，你也准备吧)]]></content>
  </entry>
  <entry>
    <title><![CDATA[如何居中一个元素]]></title>
    <url>%2F2019%2F08%2F18%2F%E5%A6%82%E4%BD%95%E5%B1%85%E4%B8%AD%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[水平居中行内元素水平居中利用text-align:center可以实现在块级元素内部的行内元素水平居中。此方法对inline、inline-block、inline-table和inline-flex元素水平居中都有效。 123.parent&#123;//在父容器设置 text-align:center; &#125; 此外，如果块级元素内部包着也是一个块级元素，我们可以先将其有块级元素改变为行内块元素，再通过设置行内块元素居中以达到水平居中。 1234567891011&lt;div class="parent"&gt; &lt;div class="child"&gt;Demo&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .parent&#123; text-align:center; &#125; .child &#123; display: inline-block; &#125;&lt;/style&gt; 块级元素的水平居中这种情形可以有多种实现方式，下面我们详细介绍： 将该块级元素左右外边距margin-left和margin-right设置为auto 1234.child&#123; width: 100px;//确保该块级元素定宽 margin:0 auto;&#125; 使用table+margin 先将子元素设置为块级表格来显示（类似），再将其设置水平居中。display:table在表现上类似block元素，但是宽度为内容宽。 123456789&lt;div class="parent"&gt; &lt;div class="child"&gt;Demo&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .child &#123; display: table; margin: 0 auto; &#125;&lt;/style&gt; 使用absolute+transform 先将父元素设置为相对定位，再将子元素设置为绝对定位，向右移动子元素，移动距离为父容器的一半，最后通过向左移动子元素的一半宽度以达到水平居中。 12345678910111213&lt;div class="parent"&gt; &lt;div class="child"&gt;Demo&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .child &#123; position:absolute; left:50%; transform:translateX(-50%); &#125; .parent &#123; position:relative; &#125;&lt;/style&gt; 不过transform属于css3内容，兼容性存在一定问题，高版本浏览器需要添加一些前缀。 使用flex+justify-content 通过CSS3中的布局利器flex中的justify-content属性来达到水平居中。 123456789&lt;div class="parent"&gt; &lt;div class="child"&gt;Demo&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .parent &#123; display: flex; justify-content:center; &#125;&lt;/style&gt; 使用flex-margin 通过flex将父容器设置为flex布局，再设置子元素居中。 1234567891011&lt;div class="parent"&gt; &lt;div class="child"&gt;Demo&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .parent &#123; display: flex; &#125; .child &#123; margin:0 auto; &#125;&lt;/style&gt; 多块级元素水平居中 利用flex布局 利用弹性布局(flex)，实现水平居中，其中justify-content用于设置弹性盒子元素在主轴(默认横轴)方向上的对齐方式，本例中设置子元素水平居中显示。 1234 #container &#123; display: flex; justify-content: center;&#125; 利用inline-block 将要水平排列的块级元素设为display:inline-block，然后在父级元素上设置text-align:center，达到与上面的行内元素的水平居中一样的效果。 123456.container &#123; text-align: center;&#125;.inline-block &#123; display: inline-block;&#125; 浮动元素水平居中 定宽的浮动元素，通过子元素设置relative+负margin 12345678.child &#123; position:relative; left:50%; margin-left:-250px;&#125;&lt;div class="parent"&gt; &lt;span class="child" style="float: left;width: 500px;"&gt;我是要居中的浮动元素&lt;/span&gt;&lt;/div&gt; 不定宽的浮动元素，父子容器都用相对定位 1234567891011121314&lt;div class="box"&gt; &lt;p&gt;我是浮动的&lt;/p&gt; &lt;p&gt;我也是居中的&lt;/p&gt;&lt;/div&gt;.box&#123; float:left; position:relative; left:50%;&#125;p&#123; float:left; position:relative; right:50%;&#125; 通用办法flex布局 利用弹性布局(flex)的justify-content属性，实现水平居中。 1234567891011.parent &#123; display:flex; justify-content:center;&#125;.chlid&#123; float: left; width: 200px;//有无宽度不影响居中&#125;&lt;div class="parent"&gt; &lt;span class="chlid"&gt;我是要居中的浮动元素&lt;/span&gt;&lt;/div&gt; 绝对定位元素水平居中 这种方式非常独特，通过子元素绝对定位，外加margin:0 auto来实现 123456789101112131415&lt;div class="parent"&gt; &lt;div class="child"&gt;让绝对定位的元素水平居中对齐。&lt;/div&gt;&lt;/div&gt; .parent&#123; position:relative; &#125; .child&#123; position: absolute; /*绝对定位*/ width: 200px; height:100px; background: yellow; margin: 0 auto; /*水平居中*/ left: 0; /*此处不能省略，且为0*/ right: 0;/*此处不能省略，且为0*/ &#125; 垂直居中单行内联元素垂直居中12345678910&lt;div id="box"&gt; &lt;span&gt;单行内联元素垂直居中。&lt;/span&gt;。&lt;/div&gt;&lt;style&gt; #box &#123; height: 120px; line-height: 120px; border: 2px dashed #f69c55; &#125;&lt;/style&gt; 多行内联元素垂直居中 利用flex布局 利用flex布局实现垂直居中，其中flex-direction:column定义主轴为纵向。这种方式在较老的浏览器存在兼容性问题。 1234567891011121314&lt;div class="parent"&gt; &lt;p&gt;Dance like nobody is watching, code like everybody is. Dance like nobody is watching, code like everybody is. Dance like nobody is watching, code like everybody is.&lt;/p&gt;&lt;/div&gt;&lt;style&gt; .parent &#123; height: 140px; display: flex; flex-direction: column; justify-content: center; border: 2px dashed #f69c55; &#125;&lt;/style&gt; 块级元素垂直居中 使用absolute+负margin(已知高度宽度) 通过绝对定位元素距离顶部50%，并设置margin-top向上偏移元素高度的一半，就可以实现了。 123456789101112&lt;div class="parent"&gt; &lt;div class="child"&gt;固定高度的块级元素垂直居中。&lt;/div&gt;&lt;/div&gt;.parent &#123; position: relative;&#125;.child &#123; position: absolute; top: 50%; height: 100px; margin-top: -50px;&#125; 使用absolute+tranform 当垂直居中的元素的高度和宽度未知时，可以借助CSS3的transform属性向Y轴反向偏移50%的方法实现垂直居中。但是部分浏览器存在兼容性的问题 1234567891011&lt;div class="parent"&gt; &lt;div class="child"&gt;未知高度的块级元素垂直居中。&lt;/div&gt;&lt;/div&gt;.parent &#123; position: relative;&#125;.child &#123; position: absolute; top: 50%; transform: translateY(-50%);&#125; 使用flex+align-items 通过设置flex布局中的属性align-items，使子元素垂直居中。 1234567&lt;div class="parent"&gt; &lt;div class="child"&gt;未知高度的块级元素垂直居中。&lt;/div&gt;&lt;/div&gt;.parent &#123; display:flex; align-items:center;&#125; 使用table-cell+vertical-align 通过将父元素转化为一个表格单元格显示（类似 和 ），再通过设置 vertical-align属性，使表格单元格内容垂直居中。 123456789&lt;div class="parent"&gt; &lt;div class="child"&gt;Demo&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .parent &#123; display: table-cell; vertical-align: middle; &#125;&lt;/style&gt; 水平垂直居中绝对定位与负边距实现(已知高度宽度) 这种方式需要知道被垂直居中元素的高和宽，才能计算出margin值，兼容所有浏览器 12345678910// css部分 #container &#123; position: relative; &#125; #center &#123; position: absolute; top: 50%; left: 50%; margin: -50px 0 0 -50px; &#125; 123456// html部分(这部分不做变化,下面例子直接共用)&lt;body&gt; &lt;div id='container'&gt; &lt;div id='center' style="width: 100px;height: 100px;background-color: #666"&gt;center&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;绝对定位与matgin：auto(已知高度宽度)这种方式无序知道被垂直居中元素的高和宽，但不能兼容低版本的IE浏览器 ​123456789101112#container &#123; position: relative; height:100px;//必须有个高度 &#125;#center &#123; position: absolute; top: 0; left: 0; right: 0; bottom: 0; margin: auto;//注意此处的写法 &#125; 绝对定位+CSS3(未知元素的高宽)利用CSS3的transform，可以轻松的在未知元素的高度的情况下实现元素的垂直居中。 123456789#container &#123; position: relative; &#125;#center &#123; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); &#125; flex布局利用flex布局，其中justify-content用于设置或检索弹性盒子元素在主轴(横轴)方向上的对齐方式，而align-items属性定义flex子项在容器的当前行的侧轴(纵轴)方向上的对齐方式。不兼容低版本的IE浏览器。 123456#container &#123;//直接在父容器设置即可 height: 100vh;//必须有高度 display: flex; justify-content: center; align-items: center; &#125; flex/grid与margin：auto(最简单写法)容器元素设为flex布局或是grid布局，子元素只要写margin：auto即可，不能兼容低版本的IE浏览器 1234567#container &#123; height: 100vh;//必须有高度 display: grid; &#125; #center &#123; margin: auto; &#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[懒加载和预加载]]></title>
    <url>%2F2019%2F08%2F16%2F%E6%87%92%E5%8A%A0%E8%BD%BD%E5%92%8C%E9%A2%84%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[懒加载什么是懒加载懒加载也叫延迟加载，指的是在长网页中延迟加载图像，是一种很好优化网页性能的方式。 用户滚动到他们之前，可视区域外的图像不会加载。这与图像预加载相反，在长网页上使用延迟加载将使网页加载更快。在某些情况下，它还可以帮助减少服务器负载。常适用图片很多，页面很长的电商网站场景中。 为什么要用懒加载 能提升用户的体验，不妨设想下，用户打开想手机淘宝长页面的时候，如果页面上所有的图片都需要加载，由于图片数目较大，等待时间很长，用户难免会心生抱怨，这就严重影响用户体验。 减少无效资源的加载，这样能明显减少服务器的压力和流量，也能够减少浏览器的负担。 防止并发加载的资源过多会阻塞js的加载，影响网站的正常使用。 懒加载的原理首先将页面上的图片的src属性设为空字符串，而图片的真实路径则设置在data-original属性中，当页面滚动的时候需要去监听scroll事件，在scrool事件的回调中，判断我们的懒加载的图片是否进入可视区域，如果图片在可视区内将图片的src属性设置为data-original的值，这样就可以实现延迟加载。 懒加载实现步骤12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Lazyload&lt;/title&gt; &lt;style&gt; .image-item &#123; display: block; margin-bottom: 50px; height: 200px;//一定记得设置图片高度 &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;img src="" class="image-item" lazyload="true" data-original="images/1.png"/&gt;&lt;img src="" class="image-item" lazyload="true" data-original="images/2.png"/&gt;&lt;img src="" class="image-item" lazyload="true" data-original="images/3.png"/&gt;&lt;img src="" class="image-item" lazyload="true" data-original="images/4.png"/&gt;&lt;img src="" class="image-item" lazyload="true" data-original="images/5.png"/&gt;&lt;img src="" class="image-item" lazyload="true" data-original="images/6.png"/&gt;&lt;img src="" class="image-item" lazyload="true" data-original="images/7.png"/&gt;&lt;img src="" class="image-item" lazyload="true" data-original="images/8.png"/&gt;&lt;img src="" class="image-item" lazyload="true" data-original="images/9.png"/&gt;&lt;img src="" class="image-item" lazyload="true" data-original="images/10.png"/&gt;&lt;img src="" class="image-item" lazyload="true" data-original="images/11.png"/&gt;&lt;img src="" class="image-item" lazyload="true" data-original="images/12.png"/&gt;&lt;script&gt;var viewHeight =document.documentElement.clientHeight//获取可视区高度function lazyload()&#123; var eles=document.querySelectorAll（'img[data-original][lazyload]'）Array.prototype.forEach.call(eles,function(item,index)&#123;var rectif(item.dataset.original==="") returnrect=item.getBoundingClientRect()// 用于获得页面中某个元素的左，上，右和下分别相对浏览器视窗的位置if(rect.bottom&gt;=0 &amp;&amp; rect.top &lt; viewHeight)&#123;!function()&#123; var img=new Image() img.src=item.dataset.original img.onload=function()&#123; item.src=img.src &#125;item.removeAttribute（"data-original"）//移除属性，下次不再遍历item.removeAttribute（"lazyload"） &#125;() &#125; &#125;)&#125;lazyload()//刚开始还没滚动屏幕时，要先触发一次函数，初始化首页的页面图片document.addEventListener（"scroll"，lazyload)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 预加载什么是预加载资源预加载是另一个性能优化技术，我们可以使用该技术来预先告知浏览器某些资源可能会被使用到。预加载简单来说就是将所有所需的资源提取请求到本地，这样后面在需要用时就直接从缓存取资源。 为什么要用预加载在网页全部加载之前，对一些主要内容进行加载，以提供给用户更好的体验，减少等待的时间。否则，如果一个页面的内容过于庞大，没有使用预加载技术的页面就会长时间的展现为一片空白，直到所有内容加载完毕。 实现预加载的几种办法 使用HTML标签 1&lt;img src="http://pic26.nipic.com/20121213/6168183 0044449030002.jpg" style="display:none"/&gt; 使用Image对象 1&lt;script src="./myPreload.js"&gt;&lt;/script&gt; 123//myPreload.js文件var image= new Image()image.src="http://pic26.nipic.com/20121213/6168183 004444903000 2.jpg" 使用XMLHttpReq对象，虽然存在跨域问题，但会精细控制预加载过程 123456789101112131415161718var xmlhttprequest = new XMLHttpRequest()xmlhttprequest.onreadystatechange = callbackxmlhttprequest.onprogress = progressCallbackxmlhttprequest.open("GET", "http://image.baidu.com/mouse,jpg", true)xmlhttprequest.send()function callback() &#123; if(xmlhttprequest.readyState==4&amp;&amp; xmlhttprequest.status==200)&#123; var responseText=xmlhttprequest.responseText &#125;else&#123; console.log("Request was unsuccessful:"+xmlhttprequest.status) &#125;&#125;function progressCallback(e) &#123; e= e || event if(e.lengthComputable) &#123; console.log("Received"+e.loaded+"of"+e.total+"bytes") &#125;&#125; 使用PreloadJS库 PreloadJS提供了一种预加载内容的一致方式，以便在HTML应用程序中使用。预加载可以使用HTML标签以及XHR来完成。默认情况下，PreloadJS会尝试使用XHR加载内容，因为它提供对进度和完成事件的更好支持，但是由于跨域问题，使用基于标记的加载可能更好。 1234567891011//使用preload.jsvar queue=new createjs.LoadQueue();//默认是xhr对象，如果是new createjs.LoadQueue(false)是指使用HTML标签，可以跨域queue.on("complete",handleComplete,this);queue.loadManifest([&#123;id:"myImage",src:"http://pic26.nipic.com/20121213/6168183 0044449030002.jpg"&#125;,&#123;id："myImage2"，src:"http://pic9.nipic.com/20100814/2839526 1931471581702.jpg"&#125;]);function handleComplete()&#123; var image=queue.getResuLt("myImage"); document.body.appendChild(image);&#125; 懒加载和预加载的对比两者都是提高页面性能有效的办法，两者主要区别是一个提前加载，一个是延迟甚至不加载。懒加载对服务器端有一定的缓解压力作用，预加载则会增加服务器前端压力。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Markdown语法]]></title>
    <url>%2F2019%2F07%2F09%2FMarkdown%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[标题在想要设置为标题的文字面前加#来表示，一个#是一级标题，两个#是二级标题以此类推。支持六级标题。 注：标准语法一般在#后跟一个空格再写文。 示例： 123456# 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题###### 这是六级标题 效果如下： 字体斜体要倾斜的文字左右分别用一个*号抱起来 加粗要加粗的文字左右分别用两个*号抱起来 斜体加粗要倾斜和加粗的文字左右分别用三个*号包起来 删除线要加删除线的文字左右分别用两个~号包起来 示例： 1234*这是倾斜的文字***这是加粗的文字*****这是斜体加粗的文字***~~这是加删除线的文字~~ 效果如下： 这是倾斜的文字这是加粗的文字这是斜体加粗的文字这是加删除线的文字 引用在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt; 示例： 123&gt;这是引用的内容&gt;&gt;这是引用的内容&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容 效果如下： 这是引用的内容 这是引用的内容 这是引用的内容 分割线三个或三个以上的-或者*都可以。示例： 1234-------******* 效果如下： 可以看到，显示效果都是一样的。 图片语法： 123![图片alt](图片位置 "图片titlle")图片alt就是显示在图片下面的文字，相当于对图片内容的解释。图片titile是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加 示例： 12![blockchain](https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=702257389,1274025419&amp;fm=27&amp;gp=0.jpg "区块链") 效果如下： ![blockchain](https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=702257389,1274025419&amp;fm=27&amp;gp=0.jpg “区块链”) 超链接语法： 12[超链接](超链接地址 "超链接title")title 可加不可加 示例： 12[简书](http://jianshu.com)[百度](http://baidu.com) 效果如下： 简书百度 列表无序列表语法： 无序列表用-、+、*任何一种都可以。 12345- 列表内容+ 列表内容* 列表内容注意： - + * 跟内容之间都要有一个空格 效果如下： 列表内容 列表内容 列表内容 有序列表语法：数字加点 123451. 列表内容2. 列表内容3. 列表内容注意： 序号跟内容之间要有空格 效果如下： 列表内容 列表内容 列表内容 列表嵌套上一级与下一级之间桥三个空格即可 一级无序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 一级无序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 一级无序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 表格语法： 1234567891011表头|表头|表头---| :--: |---:内容|内容|内容内容|内容|内容第二行分割表头和内容。- 有一个就行，为了对齐，就多加了几个文字默认居左-两边加：表示文字居中-右边加：表示文字居右注意：原生的语法两边都要用 示例： 姓名 技能 排行 刘备 哭 大哥 关羽 打 二哥 张飞 骂 三弟 代码语法：单行代码： 代码之间分别用一个反引号抱起来 1`代码内容` 代码块： 代码之间分别用三个反引号包起来，且两边的反引号单独占一行。 12345(```)代码...代码...代码...(```) 注意： 为了防止转义，前后三个反引号处加了小括号，实际是没有的。 示例： 单行代码 1`create database hero;` 代码块： 123456(```) function fun()&#123; echo "这是一句非常牛逼的代码"; &#125; fun();(```) 效果如下： 单行代码 create database hero; 代码块： 1234function fun()&#123; echo "这是一句非常牛逼的代码";&#125;fun(); 流程图123456789(```)flowst=&gt;start: 开始op=&gt;operation: My Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op&amp;(```) 注意： 为了防止转义，前后三个反引号处加了小括号，实际是没有的。 效果如下： ```st=>start: 开始 op=>operation: My Operation cond=>condition: Yes or No? e=>end st->op->cond cond(yes)->e cond(no)->op &{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12} var code = document.getElementById("flowchart-0-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value)); var diagram = flowchart.parse(code); diagram.drawSVG("flowchart-0", options);]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F06%2F15%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
