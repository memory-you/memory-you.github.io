<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[懒加载和预加载]]></title>
    <url>%2F2019%2F08%2F16%2F%E6%87%92%E5%8A%A0%E8%BD%BD%E5%92%8C%E9%A2%84%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[懒加载什么是懒加载懒加载也叫延迟加载，指的是在长网页中延迟加载图像，是一种很好优化网页性能的方式。 用户滚动到他们之前，可视区域外的图像不会加载。这与图像预加载相反，在长网页上使用延迟加载将使网页加载更快。在某些情况下，它还可以帮助减少服务器负载。常适用图片很多，页面很长的电商网站场景中。 为什么要用懒加载 能提升用户的体验，不妨设想下，用户打开想手机淘宝长页面的时候，如果页面上所有的图片都需要加载，由于图片数目较大，等待时间很长，用户难免会心生抱怨，这就严重影响用户体验。 减少无效资源的加载，这样能明显减少服务器的压力和流量，也能够减少浏览器的负担。 防止并发加载的资源过多会阻塞js的加载，影响网站的正常使用。 懒加载的原理首先将页面上的图片的src属性设为空字符串，而图片的真实路径则设置在data-original属性中，当页面滚动的时候需要去监听scroll事件，在scrool事件的回调中，判断我们的懒加载的图片是否进入可视区域，如果图片在可视区内将图片的src属性设置为data-original的值，这样就可以实现延迟加载。 懒加载实现步骤12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Lazyload&lt;/title&gt; &lt;style&gt; .image-item &#123; display: block; margin-bottom: 50px; height: 200px;//一定记得设置图片高度 &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;img src="" class="image-item" lazyload="true" data-original="images/1.png"/&gt;&lt;img src="" class="image-item" lazyload="true" data-original="images/2.png"/&gt;&lt;img src="" class="image-item" lazyload="true" data-original="images/3.png"/&gt;&lt;img src="" class="image-item" lazyload="true" data-original="images/4.png"/&gt;&lt;img src="" class="image-item" lazyload="true" data-original="images/5.png"/&gt;&lt;img src="" class="image-item" lazyload="true" data-original="images/6.png"/&gt;&lt;img src="" class="image-item" lazyload="true" data-original="images/7.png"/&gt;&lt;img src="" class="image-item" lazyload="true" data-original="images/8.png"/&gt;&lt;img src="" class="image-item" lazyload="true" data-original="images/9.png"/&gt;&lt;img src="" class="image-item" lazyload="true" data-original="images/10.png"/&gt;&lt;img src="" class="image-item" lazyload="true" data-original="images/11.png"/&gt;&lt;img src="" class="image-item" lazyload="true" data-original="images/12.png"/&gt;&lt;script&gt;var viewHeight =document.documentElement.clientHeight//获取可视区高度function lazyload()&#123; var eles=document.querySelectorAll（'img[data-original][lazyload]'）Array.prototype.forEach.call(eles,function(item,index)&#123;var rectif(item.dataset.original==="") returnrect=item.getBoundingClientRect()// 用于获得页面中某个元素的左，上，右和下分别相对浏览器视窗的位置if(rect.bottom&gt;=0 &amp;&amp; rect.top &lt; viewHeight)&#123;!function()&#123; var img=new Image() img.src=item.dataset.original img.onload=function()&#123; item.src=img.src &#125;item.removeAttribute（"data-original"）//移除属性，下次不再遍历item.removeAttribute（"lazyload"） &#125;() &#125; &#125;)&#125;lazyload()//刚开始还没滚动屏幕时，要先触发一次函数，初始化首页的页面图片document.addEventListener（"scroll"，lazyload)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 预加载什么是预加载资源预加载是另一个性能优化技术，我们可以使用该技术来预先告知浏览器某些资源可能会被使用到。预加载简单来说就是将所有所需的资源提取请求到本地，这样后面在需要用时就直接从缓存取资源。 为什么要用预加载在网页全部加载之前，对一些主要内容进行加载，以提供给用户更好的体验，减少等待的时间。否则，如果一个页面的内容过于庞大，没有使用预加载技术的页面就会长时间的展现为一片空白，直到所有内容加载完毕。 实现预加载的几种办法 使用HTML标签 1&lt;img src="http://pic26.nipic.com/20121213/6168183 0044449030002.jpg" style="display:none"/&gt; 使用Image对象 1&lt;script src="./myPreload.js"&gt;&lt;/script&gt; 123//myPreload.js文件var image= new Image()image.src="http://pic26.nipic.com/20121213/6168183 004444903000 2.jpg" 使用XMLHttpReq对象，虽然存在跨域问题，但会精细控制预加载过程 123456789101112131415161718var xmlhttprequest = new XMLHttpRequest()xmlhttprequest.onreadystatechange = callbackxmlhttprequest.onprogress = progressCallbackxmlhttprequest.open("GET", "http://image.baidu.com/mouse,jpg", true)xmlhttprequest.send()function callback() &#123; if(xmlhttprequest.readyState==4&amp;&amp; xmlhttprequest.status==200)&#123; var responseText=xmlhttprequest.responseText &#125;else&#123; console.log("Request was unsuccessful:"+xmlhttprequest.status) &#125;&#125;function progressCallback(e) &#123; e= e || event if(e.lengthComputable) &#123; console.log("Received"+e.loaded+"of"+e.total+"bytes") &#125;&#125; 使用PreloadJS库 PreloadJS提供了一种预加载内容的一致方式，以便在HTML应用程序中使用。预加载可以使用HTML标签以及XHR来完成。默认情况下，PreloadJS会尝试使用XHR加载内容，因为它提供对进度和完成事件的更好支持，但是由于跨域问题，使用基于标记的加载可能更好。 1234567891011//使用preload.jsvar queue=new createjs.LoadQueue();//默认是xhr对象，如果是new createjs.LoadQueue(false)是指使用HTML标签，可以跨域queue.on("complete",handleComplete,this);queue.loadManifest([&#123;id:"myImage",src:"http://pic26.nipic.com/20121213/6168183 0044449030002.jpg"&#125;,&#123;id："myImage2"，src:"http://pic9.nipic.com/20100814/2839526 1931471581702.jpg"&#125;]);function handleComplete()&#123; var image=queue.getResuLt("myImage"); document.body.appendChild(image);&#125; 懒加载和预加载的对比两者都是提高页面性能有效的办法，两者主要区别是一个提前加载，一个是延迟甚至不加载。懒加载对服务器端有一定的缓解压力作用，预加载则会增加服务器前端压力。]]></content>
  </entry>
  <entry>
    <title><![CDATA[HTTP常见的状态码]]></title>
    <url>%2F2019%2F07%2F10%2FHTTP%E5%B8%B8%E8%A7%81%E7%9A%84%E7%8A%B6%E6%80%81%E7%A0%81%2F</url>
    <content type="text"><![CDATA[状态码的职责是当客户端向服务器发送请求时，描述返回的请求结果。借助状态码，用户可以知道服务端时正常处理了请求还是出现了错误。 状态码的类别： 123 类别 原因短语 1XX Informational (信息性状态码) 接受的请求正在处理 2XX Success (成功状态码) 请求正常处理完毕 3XX Redirection (重定向状态码) 需要进行附加操作以完成请求 4XX Client Error (客户端错误状态码) 服务器无法处理请求 5XX Server Error (服务器错误状态码) 服务器处理请求出错 2XX——表明请求被正常处理了 200 OK：请求已正常处理。 204 No Content：请求处理成功，但没有任何资源可以返回给客户端。]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Markdown语法]]></title>
    <url>%2F2019%2F07%2F09%2FMarkdown%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[标题在想要设置为标题的文字面前加#来表示，一个#是一级标题，两个#是二级标题以此类推。支持六级标题。 注：标准语法一般在#后跟一个空格再写文。 示例： 123456# 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题###### 这是六级标题 效果如下： 字体斜体要倾斜的文字左右分别用一个*号抱起来 加粗要加粗的文字左右分别用两个*号抱起来 斜体加粗要倾斜和加粗的文字左右分别用三个*号包起来 删除线要加删除线的文字左右分别用两个~号包起来 示例： 1234*这是倾斜的文字***这是加粗的文字*****这是斜体加粗的文字***~~这是加删除线的文字~~ 效果如下： 这是倾斜的文字这是加粗的文字这是斜体加粗的文字这是加删除线的文字 引用在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt; 示例： 123&gt;这是引用的内容&gt;&gt;这是引用的内容&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容 效果如下： 这是引用的内容 这是引用的内容 这是引用的内容 分割线三个或三个以上的-或者*都可以。示例： 1234-------******* 效果如下： 可以看到，显示效果都是一样的。 图片语法： 123![图片alt](图片位置 "图片titlle")图片alt就是显示在图片下面的文字，相当于对图片内容的解释。图片titile是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加 示例： 12![blockchain](https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=702257389,1274025419&amp;fm=27&amp;gp=0.jpg "区块链") 效果如下： ![blockchain](https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=702257389,1274025419&amp;fm=27&amp;gp=0.jpg “区块链”) 超链接语法： 12[超链接](超链接地址 "超链接title")title 可加不可加 示例： 12[简书](http://jianshu.com)[百度](http://baidu.com) 效果如下： 简书百度 列表无序列表语法： 无序列表用-、+、*任何一种都可以。 12345- 列表内容+ 列表内容* 列表内容注意： - + * 跟内容之间都要有一个空格 效果如下： 列表内容 列表内容 列表内容 有序列表语法：数字加点 123451. 列表内容2. 列表内容3. 列表内容注意： 序号跟内容之间要有空格 效果如下： 列表内容 列表内容 列表内容 列表嵌套上一级与下一级之间桥三个空格即可 一级无序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 一级无序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 一级无序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 表格语法： 1234567891011表头|表头|表头---| :--: |---:内容|内容|内容内容|内容|内容第二行分割表头和内容。- 有一个就行，为了对齐，就多加了几个文字默认居左-两边加：表示文字居中-右边加：表示文字居右注意：原生的语法两边都要用 示例： 姓名 技能 排行 刘备 哭 大哥 关羽 打 二哥 张飞 骂 三弟 代码语法：单行代码： 代码之间分别用一个反引号抱起来 1`代码内容` 代码块： 代码之间分别用三个反引号包起来，且两边的反引号单独占一行。 12345(```)代码...代码...代码...(```) 注意： 为了防止转义，前后三个反引号处加了小括号，实际是没有的。 示例： 单行代码 1`create database hero;` 代码块： 123456(```) function fun()&#123; echo "这是一句非常牛逼的代码"; &#125; fun();(```) 效果如下： 单行代码 create database hero; 代码块： 1234function fun()&#123; echo "这是一句非常牛逼的代码";&#125;fun(); 流程图123456789(```)flowst=&gt;start: 开始op=&gt;operation: My Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op&amp;(```) 注意： 为了防止转义，前后三个反引号处加了小括号，实际是没有的。 效果如下： ```st=>start: 开始 op=>operation: My Operation cond=>condition: Yes or No? e=>end st->op->cond cond(yes)->e cond(no)->op &{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12} var code = document.getElementById("flowchart-0-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value)); var diagram = flowchart.parse(code); diagram.drawSVG("flowchart-0", options);]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F06%2F15%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
